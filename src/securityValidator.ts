// securityValidator.ts
// ───────────────────────────────────────────────────────────────────────────────
// セキュリティ検証とスクリプト実行サンドボックス

import { SecurityValidationResult, SecurityViolation, ValidationResult, ValidationError } from './types';
import { logger } from './errorHandler';

export class SecurityValidator {
  private dangerousPatterns: RegExp[] = [
    /eval\s*\(/,
    /Function\s*\(/,
    /setTimeout\s*\(/,
    /setInterval\s*\(/,
    /XMLHttpRequest/,
    /fetch\s*\(/,
    /WebSocket/,
    /Worker/,
    /SharedArrayBuffer/,
    /import\s*\(/,
    /require\s*\(/,
    /process\./,
    /global\./,
    /window\./,
    /document\./,
    /__proto__/,
    /constructor\.constructor/,
    /\.call\s*\(/,
    /\.apply\s*\(/,
    /\.bind\s*\(/
  ];
  
  private maxScriptLength = 50000; // 50KB
  private maxExecutionTime = 10000; // 10秒\n  \n  validateScript(script: string): SecurityValidationResult {\n    const violations: SecurityViolation[] = [];\n    \n    // 基本チェック\n    if (!script || typeof script !== 'string') {\n      return { isValid: true, violations: [] };\n    }\n    \n    // スクリプト長制限\n    if (script.length > this.maxScriptLength) {\n      violations.push({\n        type: 'SCRIPT_TOO_LONG',\n        message: `Script exceeds maximum length of ${this.maxScriptLength} characters`,\n        severity: 'HIGH'\n      });\n    }\n    \n    // 危険なパターンの検出\n    this.dangerousPatterns.forEach(pattern => {\n      if (pattern.test(script)) {\n        violations.push({\n          type: 'DANGEROUS_PATTERN',\n          message: `Dangerous pattern detected: ${pattern}`,\n          severity: 'CRITICAL',\n          pattern: pattern.toString()\n        });\n      }\n    });\n    \n    // 文字列リテラル内のコード検出\n    const sanitizedScript = this.removeStringLiterals(script);\n    if (this.hasObfuscatedCode(sanitizedScript)) {\n      violations.push({\n        type: 'OBFUSCATED_CODE',\n        message: 'Potentially obfuscated code detected',\n        severity: 'HIGH'\n      });\n    }\n    \n    return {\n      isValid: !violations.some(v => v.severity === 'CRITICAL'),\n      violations\n    };\n  }\n  \n  validateRequest(request: any): ValidationResult {\n    const errors: ValidationError[] = [];\n    \n    try {\n      // URL検証\n      this.validateURL(request.url, errors);\n      \n      // メソッド検証\n      this.validateMethod(request.method, errors);\n      \n      // ヘッダー検証\n      this.validateHeaders(request.headers, errors);\n      \n      // ボディ検証\n      this.validateBody(request.body, request.bodyType, errors);\n      \n      // 認証情報検証\n      this.validateAuth(request.auth, errors);\n      \n      return {\n        isValid: errors.length === 0,\n        errors\n      };\n      \n    } catch (error) {\n      return {\n        isValid: false,\n        errors: [new ValidationError('Validation failed', { originalError: error })]\n      };\n    }\n  }\n  \n  private validateURL(url: string, errors: ValidationError[]): void {\n    if (!url || typeof url !== 'string') {\n      errors.push(new ValidationError('URL is required'));\n      return;\n    }\n    \n    // プロトコル検証\n    if (!url.match(/^https?:\\/\\//)) {\n      errors.push(new ValidationError('URL must use HTTP or HTTPS protocol'));\n    }\n    \n    // URLの形式検証\n    try {\n      const parsed = new URL(url);\n      \n      // ローカルホストの制限（本番環境）\n      if (this.isProduction() && this.isLocalhost(parsed.hostname)) {\n        errors.push(new ValidationError('Localhost URLs are not allowed in production'));\n      }\n      \n      // プライベートIPアドレスの制限\n      if (this.isPrivateIP(parsed.hostname)) {\n        errors.push(new ValidationError('Private IP addresses are not allowed'));\n      }\n      \n    } catch (error) {\n      errors.push(new ValidationError('Invalid URL format'));\n    }\n  }\n  \n  private validateMethod(method: string, errors: ValidationError[]): void {\n    const allowedMethods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'];\n    \n    if (!method || !allowedMethods.includes(method.toUpperCase())) {\n      errors.push(new ValidationError(`Invalid HTTP method: ${method}`));\n    }\n  }\n  \n  private validateHeaders(\n    headers: Record<string, string>, \n    errors: ValidationError[]\n  ): void {\n    \n    if (!headers || typeof headers !== 'object') {\n      return;\n    }\n    \n    Object.entries(headers).forEach(([name, value]) => {\n      // ヘッダー名の検証\n      if (!this.isValidHeaderName(name)) {\n        errors.push(new ValidationError(`Invalid header name: ${name}`));\n      }\n      \n      // 危険なヘッダーの検出\n      if (this.isDangerousHeader(name)) {\n        errors.push(new ValidationError(`Dangerous header detected: ${name}`));\n      }\n      \n      // ヘッダー値の検証\n      if (!this.isValidHeaderValue(value)) {\n        errors.push(new ValidationError(`Invalid header value for ${name}`));\n      }\n    });\n  }\n  \n  private validateBody(body: any, bodyType: string, errors: ValidationError[]): void {\n    if (!body) return;\n    \n    // ボディサイズ制限\n    const bodyString = typeof body === 'string' ? body : JSON.stringify(body);\n    const maxBodySize = 10 * 1024 * 1024; // 10MB\n    \n    if (bodyString.length > maxBodySize) {\n      errors.push(new ValidationError(`Request body exceeds maximum size of ${maxBodySize} bytes`));\n    }\n    \n    // JSON形式の検証\n    if (bodyType === 'json' && typeof body === 'string') {\n      try {\n        JSON.parse(body);\n      } catch (error) {\n        errors.push(new ValidationError('Invalid JSON format in request body'));\n      }\n    }\n  }\n  \n  private validateAuth(auth: any, errors: ValidationError[]): void {\n    if (!auth || auth.type === 'none') return;\n    \n    switch (auth.type) {\n      case 'basic':\n        if (!auth.username) {\n          errors.push(new ValidationError('Username is required for Basic auth'));\n        }\n        break;\n      case 'bearer':\n        if (!auth.token) {\n          errors.push(new ValidationError('Token is required for Bearer auth'));\n        }\n        break;\n      case 'apikey':\n        if (!auth.key || !auth.value) {\n          errors.push(new ValidationError('Key and value are required for API Key auth'));\n        }\n        break;\n    }\n  }\n  \n  private removeStringLiterals(script: string): string {\n    // 文字列リテラルを除去してコード構造を分析\n    return script\n      .replace(/\"[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"/g, '\"\"')  // ダブルクォート文字列\n      .replace(/'[^'\\\\]*(?:\\\\.[^'\\\\]*)*'/g, \"''\")  // シングルクォート文字列\n      .replace(/`[^`\\\\]*(?:\\\\.[^`\\\\]*)*`/g, '``'); // テンプレートリテラル\n  }\n  \n  private hasObfuscatedCode(script: string): boolean {\n    // 難読化コードの特徴を検出\n    const obfuscationIndicators = [\n      /\\w{20,}/, // 異常に長い識別子\n      /[0-9a-fA-F]{32,}/, // 長い16進数文字列\n      /\\\\x[0-9a-fA-F]{2}/, // 16進エスケープシーケンス\n      /\\\\u[0-9a-fA-F]{4}/, // Unicode エスケープシーケンス\n      /eval\\s*\\(\\s*['\"]/ // eval with string literals\n    ];\n    \n    return obfuscationIndicators.some(pattern => pattern.test(script));\n  }\n  \n  private isValidHeaderName(name: string): boolean {\n    // RFC 7230に準拠したヘッダー名検証\n    return /^[a-zA-Z0-9!#$&'*+.^_`|~-]+$/.test(name);\n  }\n  \n  private isDangerousHeader(name: string): boolean {\n    const dangerousHeaders = [\n      'host',\n      'content-length',\n      'transfer-encoding',\n      'connection',\n      'upgrade',\n      'expect',\n      'proxy-authorization'\n    ];\n    \n    return dangerousHeaders.includes(name.toLowerCase());\n  }\n  \n  private isValidHeaderValue(value: string): boolean {\n    // 基本的なヘッダー値検証\n    return typeof value === 'string' && value.length < 8192; // 8KB制限\n  }\n  \n  private isProduction(): boolean {\n    return process?.env?.NODE_ENV === 'production' || \n           !window.location?.hostname?.includes('localhost');\n  }\n  \n  private isLocalhost(hostname: string): boolean {\n    return hostname === 'localhost' || \n           hostname === '127.0.0.1' || \n           hostname.endsWith('.localhost');\n  }\n  \n  private isPrivateIP(hostname: string): boolean {\n    const privateIPRanges = [\n      /^10\\./,           // 10.0.0.0/8\n      /^172\\.(1[6-9]|2[0-9]|3[01])\\./,  // 172.16.0.0/12\n      /^192\\.168\\./,     // 192.168.0.0/16\n      /^127\\./,          // 127.0.0.0/8 (loopback)\n      /^169\\.254\\./      // 169.254.0.0/16 (link-local)\n    ];\n    \n    return privateIPRanges.some(pattern => pattern.test(hostname));\n  }\n}\n\n// スクリプト実行サンドボックス\nexport class ScriptSandbox {\n  private readonly TIMEOUT = 10000; // 10秒\n  private readonly MEMORY_LIMIT = 10 * 1024 * 1024; // 10MB\n  private securityValidator = new SecurityValidator();\n  \n  async executeScript(script: string, context: any): Promise<any> {\n    // セキュリティ検証\n    const securityResult = this.securityValidator.validateScript(script);\n    if (!securityResult.isValid) {\n      throw new Error(`Script contains dangerous patterns: ${securityResult.violations.map(v => v.message).join(', ')}`);\n    }\n    \n    // 安全な実行環境作成\n    const safeEnvironment = this.createSafeEnvironment(context);\n    \n    try {\n      // スクリプト実行\n      return await this.executeInSandbox(script, safeEnvironment);\n    } catch (error) {\n      logger.error('Script execution failed', error, { script: script.substring(0, 100) });\n      throw error;\n    }\n  }\n  \n  private createSafeEnvironment(context: any): any {\n    const safeGlobals = {\n      // 許可されたグローバルオブジェクト\n      JSON: JSON,\n      Date: Date,\n      Math: Math,\n      parseInt: parseInt,\n      parseFloat: parseFloat,\n      isNaN: isNaN,\n      isFinite: isFinite,\n      \n      // 制限付きコンソール\n      console: {\n        log: (...args: any[]) => this.safeConsoleLog(args),\n        warn: (...args: any[]) => this.safeConsoleWarn(args),\n        error: (...args: any[]) => this.safeConsoleError(args)\n      },\n      \n      // コンテキストオブジェクト\n      ...context\n    };\n    \n    // 危険なオブジェクトを無効化\n    const restrictedGlobals = {\n      eval: undefined,\n      Function: undefined,\n      setTimeout: undefined,\n      setInterval: undefined,\n      XMLHttpRequest: undefined,\n      fetch: undefined,\n      WebSocket: undefined,\n      Worker: undefined,\n      SharedArrayBuffer: undefined,\n      window: undefined,\n      document: undefined,\n      location: undefined,\n      history: undefined,\n      localStorage: undefined,\n      sessionStorage: undefined,\n      indexedDB: undefined\n    };\n    \n    return { ...safeGlobals, ...restrictedGlobals };\n  }\n  \n  private async executeInSandbox(script: string, environment: any): Promise<any> {\n    return new Promise((resolve, reject) => {\n      // タイムアウト設定\n      const timeout = setTimeout(() => {\n        reject(new Error('Script execution timeout'));\n      }, this.TIMEOUT);\n      \n      try {\n        // Function constructor を使用した安全な実行\n        const scriptFunction = new Function(\n          ...Object.keys(environment),\n          `\"use strict\"; ${script}`\n        );\n        \n        const result = scriptFunction(...Object.values(environment));\n        clearTimeout(timeout);\n        resolve(result);\n      } catch (error) {\n        clearTimeout(timeout);\n        reject(error);\n      }\n    });\n  }\n  \n  private safeConsoleLog(args: any[]): void {\n    logger.info('Script console.log', { args: this.sanitizeArgs(args) });\n  }\n  \n  private safeConsoleWarn(args: any[]): void {\n    logger.warn('Script console.warn', { args: this.sanitizeArgs(args) });\n  }\n  \n  private safeConsoleError(args: any[]): void {\n    logger.error('Script console.error', undefined, { args: this.sanitizeArgs(args) });\n  }\n  \n  private sanitizeArgs(args: any[]): any[] {\n    return args.map(arg => {\n      if (typeof arg === 'object' && arg !== null) {\n        try {\n          return JSON.parse(JSON.stringify(arg));\n        } catch {\n          return '[Circular or Non-serializable Object]';\n        }\n      }\n      return arg;\n    });\n  }\n}\n\n// 暗号化サービス\nexport class EncryptionService {\n  private readonly ALGORITHM = 'AES-GCM';\n  private readonly KEY_LENGTH = 256;\n  private readonly IV_LENGTH = 12;\n  private readonly ITERATIONS = 100000;\n  \n  async generateMasterKey(password: string, salt: Uint8Array): Promise<CryptoKey> {\n    const encoder = new TextEncoder();\n    const passwordData = encoder.encode(password);\n    \n    // PBKDF2でキー導出\n    const baseKey = await crypto.subtle.importKey(\n      'raw',\n      passwordData,\n      'PBKDF2',\n      false,\n      ['deriveKey']\n    );\n    \n    return await crypto.subtle.deriveKey(\n      {\n        name: 'PBKDF2',\n        salt: salt,\n        iterations: this.ITERATIONS,\n        hash: 'SHA-256'\n      },\n      baseKey,\n      {\n        name: this.ALGORITHM,\n        length: this.KEY_LENGTH\n      },\n      false,\n      ['encrypt', 'decrypt']\n    );\n  }\n  \n  async encrypt(data: string, key: CryptoKey): Promise<EncryptedData> {\n    const encoder = new TextEncoder();\n    const dataBytes = encoder.encode(data);\n    \n    // ランダムIV生成\n    const iv = crypto.getRandomValues(new Uint8Array(this.IV_LENGTH));\n    \n    // 暗号化実行\n    const encryptedData = await crypto.subtle.encrypt(\n      {\n        name: this.ALGORITHM,\n        iv: iv\n      },\n      key,\n      dataBytes\n    );\n    \n    return {\n      algorithm: this.ALGORITHM,\n      iv: Array.from(iv),\n      data: Array.from(new Uint8Array(encryptedData)),\n      timestamp: Date.now()\n    };\n  }\n  \n  async decrypt(encryptedData: EncryptedData, key: CryptoKey): Promise<string> {\n    const iv = new Uint8Array(encryptedData.iv);\n    const data = new Uint8Array(encryptedData.data);\n    \n    const decryptedData = await crypto.subtle.decrypt(\n      {\n        name: this.ALGORITHM,\n        iv: iv\n      },\n      key,\n      data\n    );\n    \n    const decoder = new TextDecoder();\n    return decoder.decode(decryptedData);\n  }\n  \n  generateSalt(): Uint8Array {\n    return crypto.getRandomValues(new Uint8Array(32));\n  }\n}\n\ninterface EncryptedData {\n  algorithm: string;\n  iv: number[];\n  data: number[];\n  timestamp: number;\n}\n\n// グローバルインスタンス\nexport const securityValidator = new SecurityValidator();\nexport const scriptSandbox = new ScriptSandbox();\nexport const encryptionService = new EncryptionService();"