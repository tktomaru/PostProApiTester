# 構造設計文書：PostPro API Tester Chrome 拡張

## 1. 文書概要

### 1.1 文書の目的
本構造設計文書は、PostPro API Tester Chrome拡張機能のシステム全体の構造とデータフローを具体的に設計するものです。各コンポーネントの構成、相互関係、モジュール分割、インターフェース設計を明確にし、効率的なシステム構築を実現します。

### 1.2 文書の範囲
- システムアーキテクチャ設計
- コンポーネント構成と相互関係
- データフロー設計
- モジュール分割とインターフェース
- ストレージ構造設計
- 通信プロトコル設計

### 1.3 参照文書
- システム企画書（docs/01.sp.md）
- 要求定義文書（docs/02.sa.md）
- 要件定義文書（docs/03.rd.md）
- 基本設計文書（docs/03.bd.md）
- UI基本設計文書（docs/04.ui.md）
- 外部設計文書（docs/05.ed.md）
- プロジェクト構成ファイル（CLAUDE.md）

---

## 2. システムアーキテクチャ

### 2.1 全体アーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│                    Chrome Extension Runtime                  │
├─────────────────┬─────────────────┬─────────────────────────┤
│   Popup UI      │  Background     │    Content Script       │
│  (index.html)   │ Service Worker  │   (content.ts)          │
│                 │ (background.ts) │                         │
│  ┌─────────────┐│  ┌─────────────┐│  ┌─────────────────────┐│
│  │ App Layer   ││  │ Request     ││  │ Page Integration    ││
│  │ (app.ts)    ││  │ Orchestrator││  │                     ││
│  │             ││  │             ││  │ ┌─────────────────┐ ││
│  ├─────────────┤│  ├─────────────┤│  │ │ Injected Script │ ││
│  │ UI Layer    ││  │ Message     ││  │ │ (injected.ts)   │ ││
│  │ (utils.ts)  ││  │ Handler     ││  │ └─────────────────┘ ││
│  │             ││  │             ││  └─────────────────────┘│
│  ├─────────────┤│  ├─────────────┤│                         │
│  │ Core Layer  ││  │ Storage     ││                         │
│  │ Managers    ││  │ Manager     ││                         │
│  └─────────────┘│  └─────────────┘│                         │
├─────────────────┼─────────────────┼─────────────────────────┤
│                 │                 │                         │
│  Chrome Storage API               │  Web APIs               │
│  ├─ Local Storage                 │  ├─ XMLHttpRequest      │
│  ├─ Sync Storage                  │  ├─ Fetch API           │
│  └─ Session Storage               │  └─ WebSocket           │
│                                   │                         │
└─────────────────┴─────────────────┴─────────────────────────┘
                           │
                           ▼
                ┌─────────────────────┐
                │   External APIs     │
                ├─────────────────────┤
                │ Echo API Service    │
                │ (reply.tukutano.jp) │
                └─────────────────────┘
```

### 2.2 レイヤー構造

#### 2.2.1 プレゼンテーション層
```typescript
interface PresentationLayer {
  // UI コンポーネント
  components: {
    mainView: 'メイン画面表示とナビゲーション';
    requestEditor: 'リクエスト編集フォーム';
    responseViewer: 'レスポンス表示パネル';
    collectionTree: 'コレクション階層表示';
    environmentSelector: '環境選択コンポーネント';
    historyList: '履歴一覧表示';
    settingsPanel: '設定画面';
  };
  
  // イベントハンドリング
  eventHandlers: {
    userInteraction: 'ユーザー操作イベント処理';
    uiStateUpdate: 'UI状態更新処理';
    validation: 'フォーム検証処理';
    navigation: '画面遷移処理';
  };
  
  // レンダリング
  rendering: {
    domManipulation: 'DOM要素の動的生成・更新';
    templateRendering: 'テンプレートベースレンダリング';
    stateBinding: 'データバインディング';
    responsiveLayout: 'レスポンシブレイアウト';
  };
}
```

#### 2.2.2 アプリケーション層
```typescript
interface ApplicationLayer {
  // ビジネスロジック調整
  orchestration: {
    requestFlow: 'リクエスト実行フロー制御';
    collectionExecution: 'コレクション実行制御';
    scenarioExecution: 'シナリオ実行制御';
    testExecution: 'テスト実行制御';
  };
  
  // 状態管理
  stateManagement: {
    globalState: 'アプリケーション全体状態';
    sessionState: 'セッション状態管理';
    uiState: 'UI表示状態管理';
    cacheState: 'キャッシュ状態管理';
  };
  
  // 統合制御
  integration: {
    serviceCoordination: 'サービス間連携制御';
    errorHandling: 'エラーハンドリング統合';
    logging: 'ログ統合管理';
    monitoring: '監視・メトリクス統合';
  };
}
```

#### 2.2.3 ドメイン層
```typescript
interface DomainLayer {
  // コアビジネスロジック
  businessLogic: {
    requestManager: 'HTTPリクエスト管理';
    collectionManager: 'コレクション管理';
    variableManager: '変数管理';
    scenarioManager: 'シナリオ管理';
    historyManager: '履歴管理';
    settingsManager: '設定管理';
  };
  
  // ドメインサービス
  domainServices: {
    authenticationService: '認証サービス';
    encryptionService: '暗号化サービス';
    validationService: '検証サービス';
    scriptExecutionService: 'スクリプト実行サービス';
    importExportService: 'インポート・エクスポートサービス';
  };
  
  // ドメインモデル
  domainModels: {
    request: 'リクエストエンティティ';
    collection: 'コレクションエンティティ';
    environment: '環境エンティティ';
    variable: '変数エンティティ';
    scenario: 'シナリオエンティティ';
    testResult: 'テスト結果エンティティ';
  };
}
```

#### 2.2.4 インフラストラクチャ層
```typescript
interface InfrastructureLayer {
  // データ永続化
  persistence: {
    storageAdapter: 'Chrome Storage APIアダプター';
    cacheManager: 'キャッシュマネージャー';
    backupManager: 'バックアップマネージャー';
    migrationManager: 'データマイグレーションマネージャー';
  };
  
  // 外部通信
  communication: {
    httpClient: 'HTTPクライアント（XMLHttpRequest）';
    messageHandler: 'Chrome Extension メッセージハンドラー';
    webSocketClient: 'WebSocketクライアント（将来対応）';
  };
  
  // システムサービス
  systemServices: {
    logger: 'ログサービス';
    errorHandler: 'エラーハンドラー';
    securityManager: 'セキュリティマネージャー';
    performanceMonitor: 'パフォーマンス監視';
  };
}
```

---

## 3. コンポーネント構成

### 3.1 コアコンポーネント

#### 3.1.1 RequestManager（リクエスト管理）
```typescript
class RequestManager {
  // 依存関係
  private variableManager: VariableManager;
  private scriptExecutor: ScriptExecutor;
  private httpClient: HttpClient;
  private logger: Logger;
  
  // 公開メソッド
  async sendRequest(request: RequestData): Promise<ResponseData> {
    // 1. プリリクエストスクリプト実行
    // 2. 変数置換
    // 3. HTTPリクエスト送信
    // 4. レスポンス処理
    // 5. テストスクリプト実行
    // 6. 結果保存
  }
  
  async validateRequest(request: RequestData): Promise<ValidationResult> {
    // リクエストデータ検証
  }
  
  async executePreRequestScript(script: string, context: ScriptContext): Promise<void> {
    // プリリクエストスクリプト実行
  }
  
  async executeTestScript(script: string, response: ResponseData): Promise<TestResult[]> {
    // テストスクリプト実行
  }
  
  // 内部構造
  private processRequest(request: RequestData): ProcessedRequest;
  private handleResponse(response: XMLHttpRequest): ResponseData;
  private handleError(error: Error): ErrorData;
}
```

#### 3.1.2 CollectionManager（コレクション管理）
```typescript
class CollectionManager {
  // 依存関係
  private storageManager: StorageManager;
  private requestManager: RequestManager;
  private variableManager: VariableManager;
  
  // コレクション CRUD
  async createCollection(data: CreateCollectionData): Promise<Collection> {
    // コレクション作成ロジック
  }
  
  async updateCollection(id: string, updates: Partial<Collection>): Promise<Collection> {
    // コレクション更新ロジック
  }
  
  async deleteCollection(id: string): Promise<void> {
    // コレクション削除ロジック
  }
  
  async getCollection(id: string): Promise<Collection | null> {
    // コレクション取得ロジック
  }
  
  // リクエスト管理
  async addRequest(collectionId: string, request: RequestData): Promise<void> {
    // リクエスト追加ロジック
  }
  
  async moveRequest(requestId: string, targetCollectionId: string, targetFolderId?: string): Promise<void> {
    // リクエスト移動ロジック
  }
  
  // コレクション実行
  async runCollection(id: string, options?: RunOptions): Promise<CollectionRunResult> {
    // コレクション実行ロジック
  }
  
  // 階層構造管理
  private buildHierarchy(collection: Collection): HierarchyNode[];
  private validateHierarchy(hierarchy: HierarchyNode[]): boolean;
}
```

#### 3.1.3 VariableManager（変数管理）
```typescript
class VariableManager {
  // 変数スコープ管理
  private globalVariables: Map<string, VariableData>;
  private environmentVariables: Map<string, Map<string, VariableData>>;
  private collectionVariables: Map<string, Map<string, VariableData>>;
  private runtimeVariables: Map<string, VariableData>;
  
  // 変数取得（優先順位：runtime > collection > environment > global）
  getVariable(name: string, context: VariableContext): any {
    // 変数解決ロジック
  }
  
  // 変数設定
  setVariable(name: string, value: any, scope: VariableScope, contextId?: string): void {
    // 変数設定ロジック
  }
  
  // 変数置換
  replaceVariables(text: string, context: VariableContext): string {
    // {{variableName}} 形式の置換処理
    // 動的変数（$timestamp, $guid等）の処理
  }
  
  // 動的変数生成
  private generateBuiltInVariable(name: string): any {
    switch (name) {
      case '$timestamp': return Date.now();
      case '$isoTimestamp': return new Date().toISOString();
      case '$randomInt': return Math.floor(Math.random() * 1000);
      case '$guid': return this.generateGUID();
      case '$randomString': return this.generateRandomString(10);
    }
  }
  
  // 変数の循環参照チェック
  private checkCircularReference(variables: Map<string, VariableData>): boolean;
}
```

#### 3.1.4 ScenarioManager（シナリオ管理）
```typescript
class ScenarioManager {
  // 依存関係
  private requestManager: RequestManager;
  private variableManager: VariableManager;
  private storageManager: StorageManager;
  
  // シナリオ実行
  async runScenario(scenarioId: string, options?: ScenarioRunOptions): Promise<ScenarioRunResult> {
    // 1. シナリオ取得
    // 2. リクエスト順次実行
    // 3. 条件分岐処理
    // 4. エラーハンドリング
    // 5. 結果集計
  }
  
  // シナリオステップ実行
  private async executeStep(step: ScenarioStep, context: ScenarioContext): Promise<StepResult> {
    switch (step.type) {
      case 'request':
        return await this.executeRequestStep(step, context);
      case 'delay':
        return await this.executeDelayStep(step, context);
      case 'condition':
        return await this.executeConditionStep(step, context);
      case 'loop':
        return await this.executeLoopStep(step, context);
    }
  }
  
  // 条件分岐処理
  private evaluateCondition(condition: string, context: ScenarioContext): boolean {
    // JavaScript式の安全な評価
  }
  
  // シナリオ状態管理
  private async saveScenarioState(scenarioId: string, state: ScenarioState): Promise<void>;
  private async loadScenarioState(scenarioId: string): Promise<ScenarioState | null>;
}
```

### 3.2 サポートコンポーネント

#### 3.2.1 StorageManager（ストレージ管理）
```typescript
class StorageManager {
  private cache: Map<string, CacheEntry>;
  private writeQueue: WriteQueue;
  
  // 基本操作
  async get<T>(key: string): Promise<T | null> {
    // 1. キャッシュチェック
    // 2. Chrome Storage読み込み
    // 3. キャッシュ更新
  }
  
  async set(key: string, value: any): Promise<void> {
    // 1. 書き込みキューに追加
    // 2. キャッシュ更新
    // 3. バッチ書き込み実行
  }
  
  async remove(key: string): Promise<void> {
    // 削除処理
  }
  
  // バッチ操作
  async getBatch(keys: string[]): Promise<Record<string, any>> {
    // 複数キー一括読み込み
  }
  
  async setBatch(items: Record<string, any>): Promise<void> {
    // 複数キー一括書き込み
  }
  
  // ストレージ監視
  onStorageChange(callback: StorageChangeCallback): void {
    // ストレージ変更監視
  }
  
  // クォータ管理
  async getQuotaUsage(): Promise<QuotaInfo> {
    // ストレージ使用量取得
  }
  
  async cleanupOldData(): Promise<void> {
    // 古いデータのクリーンアップ
  }
  
  // キャッシュ管理
  private updateCache(key: string, value: any): void;
  private invalidateCache(key: string): void;
  private flushWriteQueue(): Promise<void>;
}
```

#### 3.2.2 ScriptExecutor（スクリプト実行）
```typescript
class ScriptExecutor {
  private sandbox: ScriptSandbox;
  private postmanAPI: PostmanAPIEmulator;
  
  // スクリプト実行
  async executeScript(script: string, context: ScriptContext): Promise<ScriptResult> {
    try {
      // 1. スクリプト検証
      this.validateScript(script);
      
      // 2. サンドボックス環境準備
      const env = this.prepareSandboxEnvironment(context);
      
      // 3. スクリプト実行
      const result = await this.runInSandbox(script, env);
      
      // 4. 結果処理
      return this.processResult(result);
    } catch (error) {
      return this.handleScriptError(error);
    }
  }
  
  // Postman API エミュレーション
  createPostmanAPI(context: ScriptContext): PostmanAPI {
    return {
      test: (name: string, fn: () => void) => this.registerTest(name, fn),
      expect: (actual: any) => new ChaiExpectEmulator(actual),
      response: this.createResponseObject(context.response),
      variables: this.createVariablesObject(context),
      environment: this.createEnvironmentObject(context),
      globals: this.createGlobalsObject(context)
    };
  }
  
  // セキュリティ検証
  private validateScript(script: string): void {
    // 危険なパターンの検出
    const dangerousPatterns = [
      /eval\s*\(/,
      /Function\s*\(/,
      /setTimeout\s*\(/,
      /setInterval\s*\(/,
      /XMLHttpRequest/,
      /fetch\s*\(/,
      /window\./,
      /document\./
    ];
    
    for (const pattern of dangerousPatterns) {
      if (pattern.test(script)) {
        throw new SecurityError(`Dangerous pattern detected: ${pattern}`);
      }
    }
  }
  
  // サンドボックス環境
  private prepareSandboxEnvironment(context: ScriptContext): SandboxEnvironment {
    return {
      // 許可されたグローバルオブジェクト
      JSON: JSON,
      Date: Date,
      Math: Math,
      console: new SafeConsole(),
      pm: this.createPostmanAPI(context),
      
      // セキュリティ制限
      eval: undefined,
      Function: undefined,
      setTimeout: undefined,
      setInterval: undefined,
      XMLHttpRequest: undefined,
      fetch: undefined,
      window: undefined,
      document: undefined
    };
  }
}
```

#### 3.2.3 HttpClient（HTTP通信）
```typescript
class HttpClient {
  private defaultTimeout: number = 30000;
  private interceptors: RequestInterceptor[] = [];
  
  // HTTPリクエスト送信
  async send(request: ProcessedRequest): Promise<ResponseData> {
    const xhr = new XMLHttpRequest();
    
    return new Promise((resolve, reject) => {
      // タイムアウト設定
      xhr.timeout = request.timeout || this.defaultTimeout;
      
      // イベントハンドラー設定
      xhr.onload = () => {
        if (xhr.readyState === XMLHttpRequest.DONE) {
          resolve(this.createResponseData(xhr));
        }
      };
      
      xhr.onerror = () => reject(new NetworkError('Request failed'));
      xhr.ontimeout = () => reject(new TimeoutError('Request timeout'));
      
      // リクエスト初期化
      xhr.open(request.method, request.url, true);
      
      // ヘッダー設定
      for (const [name, value] of Object.entries(request.headers)) {
        xhr.setRequestHeader(name, value);
      }
      
      // プログレス監視
      if (request.onProgress) {
        xhr.upload.onprogress = request.onProgress;
      }
      
      // リクエスト送信
      xhr.send(request.body);
    });
  }
  
  // レスポンスデータ作成
  private createResponseData(xhr: XMLHttpRequest): ResponseData {
    return {
      status: xhr.status,
      statusText: xhr.statusText,
      headers: this.parseHeaders(xhr.getAllResponseHeaders()),
      body: xhr.responseText,
      responseTime: performance.now() - this.requestStartTime,
      size: new Blob([xhr.responseText]).size,
      url: xhr.responseURL
    };
  }
  
  // ヘッダーパース
  private parseHeaders(headerString: string): Record<string, string> {
    const headers: Record<string, string> = {};
    headerString.split('\r\n').forEach(line => {
      const [name, value] = line.split(': ');
      if (name && value) {
        headers[name.toLowerCase()] = value;
      }
    });
    return headers;
  }
  
  // リクエストインターセプター
  addRequestInterceptor(interceptor: RequestInterceptor): void {
    this.interceptors.push(interceptor);
  }
  
  private async applyInterceptors(request: ProcessedRequest): Promise<ProcessedRequest> {
    let processedRequest = request;
    for (const interceptor of this.interceptors) {
      processedRequest = await interceptor.process(processedRequest);
    }
    return processedRequest;
  }
}
```

---

## 4. データフロー設計

### 4.1 リクエスト実行フロー

```
[User Action] → [UI Event] → [Request Creation] → [Pre-processing]
      ↓
[Variable Resolution] → [Pre-request Script] → [HTTP Request] → [Response Processing]
      ↓
[Test Script Execution] → [Result Storage] → [UI Update] → [History Save]
```

#### 4.1.1 詳細フロー定義
```typescript
interface RequestExecutionFlow {
  // Phase 1: Request Preparation
  preparation: {
    userInput: 'ユーザーからのリクエスト情報入力';
    validation: 'リクエストデータ検証';
    preprocessing: 'リクエスト前処理';
  };
  
  // Phase 2: Variable Processing
  variableProcessing: {
    contextBuilding: '変数コンテキスト構築';
    resolution: '変数参照解決';
    substitution: '変数値置換';
  };
  
  // Phase 3: Pre-request Processing
  preRequestProcessing: {
    scriptValidation: 'プリリクエストスクリプト検証';
    scriptExecution: 'プリリクエストスクリプト実行';
    variableUpdate: '実行時変数更新';
  };
  
  // Phase 4: HTTP Communication
  httpCommunication: {
    requestBuilding: 'HTTPリクエスト構築';
    transmission: 'リクエスト送信';
    responseReceiving: 'レスポンス受信';
  };
  
  // Phase 5: Response Processing
  responseProcessing: {
    parsing: 'レスポンスデータパース';
    validation: 'レスポンス検証';
    testExecution: 'テストスクリプト実行';
  };
  
  // Phase 6: Result Finalization
  finalization: {
    resultCompilation: '実行結果編集';
    historyStorage: '履歴保存';
    uiUpdate: 'UI更新';
    notification: 'ユーザー通知';
  };
}
```

### 4.2 コレクション実行フロー

```
[Collection Selection] → [Execution Planning] → [Request Queue Building]
      ↓
[Sequential Processing] → [Individual Request Execution] → [Result Aggregation]
      ↓
[Report Generation] → [History Storage] → [UI Update]
```

#### 4.2.1 コレクション実行詳細
```typescript
interface CollectionExecutionFlow {
  // 実行計画
  planning: {
    collectionAnalysis: 'コレクション構造解析';
    dependencyMapping: '依存関係マッピング';
    executionOrderDetermination: '実行順序決定';
    resourceAllocation: 'リソース割り当て';
  };
  
  // 実行制御
  execution: {
    queueManagement: '実行キュー管理';
    concurrencyControl: '並行実行制御';
    errorHandling: 'エラーハンドリング';
    progressReporting: '進捗レポート';
  };
  
  // 結果処理
  resultProcessing: {
    aggregation: '結果集約';
    analysis: '実行分析';
    reporting: 'レポート生成';
    notification: '完了通知';
  };
}
```

### 4.3 データ永続化フロー

```
[Data Change] → [Validation] → [Serialization] → [Encryption (if needed)]
      ↓
[Cache Update] → [Storage Write] → [Verification] → [Event Notification]
```

#### 4.3.1 ストレージ操作詳細
```typescript
interface StorageFlow {
  // 書き込みフロー
  write: {
    validation: 'データ妥当性検証';
    serialization: 'JSON シリアライゼーション';
    encryption: '機密データ暗号化';
    compression: 'データ圧縮（オプション）';
    atomicWrite: 'アトミック書き込み';
    verification: '書き込み検証';
    cacheUpdate: 'キャッシュ更新';
    eventNotification: '変更通知';
  };
  
  // 読み込みフロー
  read: {
    cacheCheck: 'キャッシュ確認';
    storageRead: 'ストレージ読み込み';
    verification: 'データ整合性確認';
    decryption: '暗号化データ復号';
    deserialization: 'デシリアライゼーション';
    validation: 'データ検証';
    cacheUpdate: 'キャッシュ更新';
    delivery: 'データ配信';
  };
}
```

---

## 5. モジュール分割とインターフェース

### 5.1 モジュール構造

```
src/
├── core/                    # コアビジネスロジック
│   ├── managers/           # ビジネスロジックマネージャー
│   │   ├── requestManager.ts
│   │   ├── collectionManager.ts
│   │   ├── variableManager.ts
│   │   ├── scenarioManager.ts
│   │   └── historyManager.ts
│   ├── services/           # ドメインサービス
│   │   ├── authService.ts
│   │   ├── encryptionService.ts
│   │   ├── validationService.ts
│   │   └── scriptExecutionService.ts
│   └── models/             # ドメインモデル
│       ├── request.ts
│       ├── collection.ts
│       ├── environment.ts
│       └── variable.ts
├── infrastructure/          # インフラストラクチャ層
│   ├── storage/
│   │   ├── storageManager.ts
│   │   ├── cacheManager.ts
│   │   └── migrationManager.ts
│   ├── communication/
│   │   ├── httpClient.ts
│   │   ├── messageHandler.ts
│   │   └── webSocketClient.ts
│   └── system/
│       ├── logger.ts
│       ├── errorHandler.ts
│       └── performanceMonitor.ts
├── application/             # アプリケーション層
│   ├── orchestrators/
│   │   ├── requestOrchestrator.ts
│   │   ├── collectionOrchestrator.ts
│   │   └── scenarioOrchestrator.ts
│   ├── state/
│   │   ├── appState.ts
│   │   ├── sessionState.ts
│   │   └── uiState.ts
│   └── integrations/
│       ├── serviceCoordinator.ts
│       └── errorIntegrator.ts
├── presentation/            # プレゼンテーション層
│   ├── components/
│   │   ├── requestEditor.ts
│   │   ├── responseViewer.ts
│   │   ├── collectionTree.ts
│   │   └── environmentSelector.ts
│   ├── handlers/
│   │   ├── eventHandlers.ts
│   │   ├── navigationHandlers.ts
│   │   └── validationHandlers.ts
│   └── rendering/
│       ├── domRenderer.ts
│       ├── templateEngine.ts
│       └── stateRenderer.ts
└── shared/                  # 共有モジュール
    ├── types/
    │   ├── request.types.ts
    │   ├── collection.types.ts
    │   └── common.types.ts
    ├── constants/
    │   ├── apiConstants.ts
    │   ├── errorConstants.ts
    │   └── uiConstants.ts
    └── utils/
        ├── dateUtils.ts
        ├── stringUtils.ts
        └── validationUtils.ts
```

### 5.2 モジュール間インターフェース

#### 5.2.1 マネージャー間通信
```typescript
interface ManagerCommunication {
  // RequestManager → VariableManager
  requestToVariable: {
    getVariable: '(name: string, context: VariableContext) => any';
    setVariable: '(name: string, value: any, scope: VariableScope) => void';
    replaceVariables: '(text: string, context: VariableContext) => string';
  };
  
  // RequestManager → ScriptExecutor
  requestToScript: {
    executePreRequest: '(script: string, context: ScriptContext) => Promise<ScriptResult>';
    executeTest: '(script: string, response: ResponseData) => Promise<TestResult[]>';
  };
  
  // CollectionManager → RequestManager
  collectionToRequest: {
    sendRequest: '(request: RequestData) => Promise<ResponseData>';
    validateRequest: '(request: RequestData) => ValidationResult';
  };
  
  // All Managers → StorageManager
  managersToStorage: {
    get: '<T>(key: string) => Promise<T | null>';
    set: '(key: string, value: any) => Promise<void>';
    remove: '(key: string) => Promise<void>';
    onStorageChange: '(callback: StorageChangeCallback) => void';
  };
}
```

#### 5.2.2 レイヤー間通信
```typescript
interface LayerCommunication {
  // Presentation → Application
  presentationToApplication: {
    // ユーザーアクション
    sendRequest: '(request: RequestData) => Promise<void>';
    runCollection: '(collectionId: string) => Promise<void>';
    updateSettings: '(settings: Partial<AppSettings>) => Promise<void>';
    
    // 状態取得
    getState: '() => AppState';
    subscribeToState: '(callback: StateChangeCallback) => void';
  };
  
  // Application → Domain
  applicationToDomain: {
    // ビジネスロジック呼び出し
    requestManager: RequestManagerInterface;
    collectionManager: CollectionManagerInterface;
    variableManager: VariableManagerInterface;
    scenarioManager: ScenarioManagerInterface;
  };
  
  // Domain → Infrastructure
  domainToInfrastructure: {
    // データ永続化
    storage: StorageManagerInterface;
    
    // 外部通信
    httpClient: HttpClientInterface;
    messageHandler: MessageHandlerInterface;
    
    // システムサービス
    logger: LoggerInterface;
    errorHandler: ErrorHandlerInterface;
  };
}
```

### 5.3 依存性注入設計

#### 5.3.1 DIコンテナ
```typescript
class DIContainer {
  private services: Map<string, any> = new Map();
  private factories: Map<string, () => any> = new Map();
  
  // サービス登録
  register<T>(name: string, factory: () => T): void {
    this.factories.set(name, factory);
  }
  
  // シングルトン登録
  registerSingleton<T>(name: string, factory: () => T): void {
    this.register(name, () => {
      if (!this.services.has(name)) {
        this.services.set(name, factory());
      }
      return this.services.get(name);
    });
  }
  
  // サービス取得
  resolve<T>(name: string): T {
    const factory = this.factories.get(name);
    if (!factory) {
      throw new Error(`Service ${name} not registered`);
    }
    return factory();
  }
  
  // 初期化
  static initializeContainer(): DIContainer {
    const container = new DIContainer();
    
    // Infrastructure Services
    container.registerSingleton('logger', () => new Logger());
    container.registerSingleton('storageManager', () => new StorageManager());
    container.registerSingleton('httpClient', () => new HttpClient());
    
    // Domain Services
    container.registerSingleton('variableManager', () => 
      new VariableManager(container.resolve('storageManager'))
    );
    container.registerSingleton('requestManager', () => 
      new RequestManager(
        container.resolve('variableManager'),
        container.resolve('httpClient'),
        container.resolve('logger')
      )
    );
    container.registerSingleton('collectionManager', () => 
      new CollectionManager(
        container.resolve('storageManager'),
        container.resolve('requestManager')
      )
    );
    
    return container;
  }
}
```

#### 5.3.2 サービスライフサイクル
```typescript
interface ServiceLifecycle {
  // シングルトンサービス（アプリケーション全体で1つのインスタンス）
  singletons: [
    'StorageManager',
    'Logger',
    'ErrorHandler',
    'VariableManager',
    'HistoryManager',
    'SettingsManager'
  ];
  
  // トランジェントサービス（呼び出し毎に新しいインスタンス）
  transients: [
    'HttpClient',
    'ScriptExecutor',
    'ValidationService',
    'EncryptionService'
  ];
  
  // スコープドサービス（特定のスコープ内で1つのインスタンス）
  scoped: [
    'RequestManager', // リクエスト実行スコープ
    'CollectionManager', // コレクション実行スコープ
    'ScenarioManager' // シナリオ実行スコープ
  ];
}
```

---

## 6. ストレージ構造設計

### 6.1 Chrome Storage スキーマ

#### 6.1.1 主要ストレージキー構造
```typescript
interface StorageSchema {
  // アプリケーション状態
  'postpro_app_state': {
    version: string;
    lastUpdated: string;
    currentRequest: RequestData | null;
    currentCollection: string | null;
    currentEnvironment: string | null;
    ui: UIState;
    settings: AppSettings;
  };
  
  // コレクションデータ
  'postpro_collections': {
    [collectionId: string]: Collection;
  };
  
  // 環境データ
  'postpro_environments': {
    [environmentId: string]: Environment;
  };
  
  // グローバル変数
  'postpro_global_variables': {
    [variableName: string]: VariableData;
  };
  
  // リクエスト履歴
  'postpro_history': {
    items: HistoryItem[];
    lastCleanup: string;
    maxItems: number;
  };
  
  // バックアップデータ
  'postpro_backups': {
    [backupId: string]: BackupData;
  };
  
  // キャッシュデータ
  'postpro_cache': {
    [cacheKey: string]: CacheEntry;
  };
}
```

#### 6.1.2 データ型定義
```typescript
interface Collection {
  id: string;
  name: string;
  description: string;
  created: string;
  updated: string;
  
  // 階層構造
  folders: Folder[];
  requests: RequestData[];
  
  // 変数とメタデータ
  variables: Record<string, VariableData>;
  metadata: CollectionMetadata;
}

interface RequestData {
  id: string;
  name: string;
  description: string;
  folderId: string | null;
  
  // HTTP設定
  method: HTTPMethod;
  url: string;
  headers: Record<string, string>;
  body: RequestBody;
  auth: AuthConfig;
  
  // スクリプト
  preRequestScript: string;
  testScript: string;
  
  // 設定
  settings: RequestSettings;
}

interface Environment {
  id: string;
  name: string;
  description: string;
  variables: Record<string, VariableData>;
  settings: EnvironmentSettings;
}

interface VariableData {
  value: any;
  type: 'string' | 'number' | 'boolean' | 'object';
  description: string;
  encrypted: boolean;
  created: string;
  updated: string;
}
```

### 6.2 ストレージアクセスパターン

#### 6.2.1 読み込みパターン
```typescript
interface StorageReadPatterns {
  // 起動時一括読み込み
  applicationBootstrap: {
    keys: ['postpro_app_state', 'postpro_environments', 'postpro_global_variables'];
    caching: 'メモリキャッシュ';
    frequency: '起動時1回';
  };
  
  // 遅延読み込み
  lazyLoading: {
    collections: 'コレクション選択時に読み込み';
    history: '履歴画面表示時に読み込み';
    backups: 'バックアップ管理画面表示時に読み込み';
  };
  
  // オンデマンド読み込み
  onDemand: {
    largeResponses: '大きなレスポンスデータは個別に読み込み';
    archives: 'アーカイブデータは必要時のみ';
  };
}
```

#### 6.2.2 書き込みパターン
```typescript
interface StorageWritePatterns {
  // リアルタイム書き込み
  realTime: {
    appState: 'アプリケーション状態の即座更新';
    currentRequest: '現在のリクエストの自動保存';
    settings: 'ユーザー設定の即座反映';
  };
  
  // バッチ書き込み
  batch: {
    history: '履歴アイテムの定期的なバッチ保存';
    cache: 'キャッシュデータの定期フラッシュ';
    metrics: 'メトリクスデータの集約保存';
  };
  
  // デバウンス書き込み
  debounced: {
    variables: '変数値の変更検知後の遅延保存';
    collections: 'コレクション編集の完了後保存';
    environments: '環境設定の編集完了後保存';
  };
}
```

### 6.3 データ整合性とマイグレーション

#### 6.3.1 データ検証
```typescript
interface DataValidation {
  // スキーマ検証
  schema: {
    validation: 'JSON Schema による構造検証';
    enforcement: '書き込み時の強制検証';
    migration: 'スキーマ変更時の自動マイグレーション';
  };
  
  // 整合性チェック
  integrity: {
    referentialIntegrity: '参照整合性チェック（コレクション→リクエスト等）';
    dataConsistency: 'データ一貫性チェック';
    checksumValidation: 'チェックサムによるデータ破損検知';
  };
  
  // 修復機能
  repair: {
    automaticRepair: '軽微な不整合の自動修復';
    guidedRepair: 'ユーザーガイド付き修復';
    backupRestore: 'バックアップからの復旧';
  };
}
```

#### 6.3.2 マイグレーション戦略
```typescript
interface MigrationStrategy {
  // バージョン管理
  versioning: {
    schemaVersion: 'データスキーマバージョン';
    appVersion: 'アプリケーションバージョン';
    compatibility: '下位互換性マトリクス';
  };
  
  // マイグレーション実行
  execution: {
    sequential: '順次マイグレーション実行';
    rollback: 'マイグレーション失敗時のロールバック';
    validation: 'マイグレーション後の検証';
    notification: 'ユーザーへの進捗通知';
  };
  
  // マイグレーションスクリプト
  scripts: {
    'v1.0_to_v2.0': 'コレクション構造の変更';
    'v2.0_to_v2.1': '環境変数暗号化の追加';
    'v2.1_to_v3.0': '新しい認証方式の追加';
  };
}
```

---

## 7. 通信プロトコル設計

### 7.1 Chrome Extension メッセージング

#### 7.1.1 メッセージ構造
```typescript
interface ExtensionMessage {
  // 基本構造
  type: MessageType;
  id: string; // メッセージ識別子
  timestamp: number;
  source: 'popup' | 'background' | 'content' | 'injected';
  target: 'popup' | 'background' | 'content' | 'injected';
  
  // ペイロード
  payload: {
    action: string;
    data?: any;
    error?: string;
    metadata?: Record<string, any>;
  };
  
  // 応答制御
  response?: {
    required: boolean;
    timeout: number;
    callback?: string;
  };
}
```

#### 7.1.2 メッセージタイプ定義
```typescript
enum MessageType {
  // リクエスト実行
  SEND_REQUEST = 'SEND_REQUEST',
  REQUEST_RESPONSE = 'REQUEST_RESPONSE',
  REQUEST_ERROR = 'REQUEST_ERROR',
  REQUEST_PROGRESS = 'REQUEST_PROGRESS',
  
  // 状態管理
  STATE_UPDATE = 'STATE_UPDATE',
  STATE_SYNC = 'STATE_SYNC',
  STATE_RESET = 'STATE_RESET',
  
  // コレクション管理
  COLLECTION_CREATE = 'COLLECTION_CREATE',
  COLLECTION_UPDATE = 'COLLECTION_UPDATE',
  COLLECTION_DELETE = 'COLLECTION_DELETE',
  COLLECTION_RUN = 'COLLECTION_RUN',
  
  // スクリプト実行
  SCRIPT_EXECUTE = 'SCRIPT_EXECUTE',
  SCRIPT_RESULT = 'SCRIPT_RESULT',
  SCRIPT_ERROR = 'SCRIPT_ERROR',
  
  // システム
  HEALTH_CHECK = 'HEALTH_CHECK',
  ERROR_REPORT = 'ERROR_REPORT',
  LOG_MESSAGE = 'LOG_MESSAGE'
}
```

#### 7.1.3 メッセージルーティング
```typescript
class MessageRouter {
  private handlers: Map<MessageType, MessageHandler> = new Map();
  private middlewares: MessageMiddleware[] = [];
  
  // ハンドラー登録
  registerHandler(type: MessageType, handler: MessageHandler): void {
    this.handlers.set(type, handler);
  }
  
  // ミドルウェア登録
  use(middleware: MessageMiddleware): void {
    this.middlewares.push(middleware);
  }
  
  // メッセージ処理
  async handleMessage(message: ExtensionMessage): Promise<ExtensionMessage | void> {
    try {
      // ミドルウェア処理
      for (const middleware of this.middlewares) {
        message = await middleware.process(message);
      }
      
      // ハンドラー実行
      const handler = this.handlers.get(message.type);
      if (handler) {
        return await handler.handle(message);
      }
      
      throw new Error(`Handler not found for message type: ${message.type}`);
    } catch (error) {
      return this.createErrorResponse(message, error);
    }
  }
  
  // エラーレスポンス作成
  private createErrorResponse(originalMessage: ExtensionMessage, error: Error): ExtensionMessage {
    return {
      type: MessageType.REQUEST_ERROR,
      id: originalMessage.id,
      timestamp: Date.now(),
      source: originalMessage.target,
      target: originalMessage.source,
      payload: {
        action: 'error',
        error: error.message,
        data: originalMessage
      }
    };
  }
}
```

### 7.2 HTTP通信プロトコル

#### 7.2.1 リクエスト構造
```typescript
interface HTTPRequestProtocol {
  // 基本構造
  structure: {
    method: HTTPMethod;
    url: URL;
    headers: Record<string, string>;
    body?: RequestBody;
    timeout: number;
  };
  
  // 認証情報
  authentication: {
    type: 'none' | 'basic' | 'bearer' | 'apikey' | 'oauth2';
    credentials: AuthCredentials;
    location: 'header' | 'query' | 'body';
  };
  
  // リクエスト設定
  settings: {
    followRedirects: boolean;
    validateSSL: boolean;
    proxy?: ProxyConfig;
    retryCount: number;
    retryDelay: number;
  };
  
  // メタデータ
  metadata: {
    requestId: string;
    timestamp: number;
    collectionId?: string;
    environmentId?: string;
    scenario?: string;
  };
}
```

#### 7.2.2 レスポンス処理
```typescript
interface HTTPResponseProtocol {
  // レスポンス構造
  structure: {
    status: number;
    statusText: string;
    headers: Record<string, string>;
    body: string | ArrayBuffer | Blob;
    url: string;
  };
  
  // メタデータ
  metadata: {
    responseTime: number;
    size: number;
    redirectCount: number;
    fromCache: boolean;
    timestamp: number;
  };
  
  // 処理設定
  processing: {
    maxSize: number; // 50MB
    timeout: number; // 30秒
    encoding: string; // UTF-8
    compression: boolean;
  };
}
```

### 7.3 WebSocket プロトコル（将来対応）

#### 7.3.1 接続管理
```typescript
interface WebSocketProtocol {
  // 接続設定
  connection: {
    url: string;
    protocols: string[];
    headers: Record<string, string>;
    timeout: number;
  };
  
  // メッセージフォーマット
  messageFormat: {
    type: 'text' | 'binary';
    encoding: 'utf-8' | 'base64';
    compression: boolean;
  };
  
  // 接続制御
  control: {
    autoReconnect: boolean;
    reconnectInterval: number;
    maxReconnectAttempts: number;
    heartbeatInterval: number;
  };
}
```

---

## 8. セキュリティアーキテクチャ

### 8.1 セキュリティレイヤー

#### 8.1.1 多層防御
```typescript
interface SecurityLayers {
  // 入力検証層
  inputValidation: {
    sanitization: 'ユーザー入力のサニタイゼーション';
    validation: 'データ形式・範囲検証';
    encoding: '安全なエンコーディング';
    filtering: '危険なパターンフィルタリング';
  };
  
  // 認証・認可層
  authentication: {
    credentialStorage: '認証情報の安全な保存';
    tokenManagement: 'トークンライフサイクル管理';
    sessionManagement: 'セッション管理';
    accessControl: 'アクセス制御';
  };
  
  // 暗号化層
  encryption: {
    dataAtRest: '保存データの暗号化';
    dataInTransit: '通信データの暗号化';
    keyManagement: '暗号鍵管理';
    randomGeneration: '暗号学的乱数生成';
  };
  
  // 実行環境層
  executionEnvironment: {
    sandboxing: 'スクリプト実行のサンドボックス化';
    privilegeSeparation: '特権分離';
    resourceLimiting: 'リソース制限';
    monitoring: 'セキュリティ監視';
  };
}
```

#### 8.1.2 コンテンツセキュリティポリシー
```typescript
interface ContentSecurityPolicy {
  // 基本ポリシー
  basePolicy: {
    'default-src': "'self'";
    'script-src': "'self' 'unsafe-eval'"; // スクリプト実行のため
    'style-src': "'self' 'unsafe-inline'"; // インラインスタイルのため
    'img-src': "'self' data: chrome-extension:";
    'font-src': "'self'";
    'connect-src': "'self' https:";
    'object-src': "'none'";
    'base-uri': "'none'";
    'form-action': "'none'";
  };
  
  // 例外設定
  exceptions: {
    'unsafe-eval': 'スクリプト実行エンジンのため必要';
    'unsafe-inline': 'CSS-in-JS使用のため必要';
    'https:': 'HTTPS APIアクセスのため必要';
  };
  
  // 監視
  reporting: {
    'report-uri': '/csp-report';
    'report-to': 'csp-endpoint';
  };
}
```

### 8.2 データ保護

#### 8.2.1 暗号化実装
```typescript
class EncryptionService {
  private readonly ALGORITHM = 'AES-GCM';
  private readonly KEY_LENGTH = 256;
  private readonly IV_LENGTH = 12;
  private readonly ITERATIONS = 100000;
  
  // マスターキー生成
  async generateMasterKey(password: string, salt: Uint8Array): Promise<CryptoKey> {
    const encoder = new TextEncoder();
    const passwordData = encoder.encode(password);
    
    // PBKDF2でキー導出
    const baseKey = await crypto.subtle.importKey(
      'raw',
      passwordData,
      'PBKDF2',
      false,
      ['deriveKey']
    );
    
    return await crypto.subtle.deriveKey(
      {
        name: 'PBKDF2',
        salt: salt,
        iterations: this.ITERATIONS,
        hash: 'SHA-256'
      },
      baseKey,
      {
        name: this.ALGORITHM,
        length: this.KEY_LENGTH
      },
      false,
      ['encrypt', 'decrypt']
    );
  }
  
  // データ暗号化
  async encrypt(data: string, key: CryptoKey): Promise<EncryptedData> {
    const encoder = new TextEncoder();
    const dataBytes = encoder.encode(data);
    
    // ランダムIV生成
    const iv = crypto.getRandomValues(new Uint8Array(this.IV_LENGTH));
    
    // 暗号化実行
    const encryptedData = await crypto.subtle.encrypt(
      {
        name: this.ALGORITHM,
        iv: iv
      },
      key,
      dataBytes
    );
    
    return {
      algorithm: this.ALGORITHM,
      iv: Array.from(iv),
      data: Array.from(new Uint8Array(encryptedData)),
      timestamp: Date.now()
    };
  }
  
  // データ復号化
  async decrypt(encryptedData: EncryptedData, key: CryptoKey): Promise<string> {
    const iv = new Uint8Array(encryptedData.iv);
    const data = new Uint8Array(encryptedData.data);
    
    const decryptedData = await crypto.subtle.decrypt(
      {
        name: this.ALGORITHM,
        iv: iv
      },
      key,
      data
    );
    
    const decoder = new TextDecoder();
    return decoder.decode(decryptedData);
  }
}
```

#### 8.2.2 機密データ分類
```typescript
interface DataClassification {
  // 公開データ（暗号化不要）
  public: [
    'コレクション名・説明',
    'リクエスト名・説明',
    'フォルダ構造',
    'UI設定',
    '非機密な環境変数'
  ];
  
  // 機密データ（暗号化必須）
  confidential: [
    'Basic認証のユーザー名・パスワード',
    'Bearer トークン',
    'API キー',
    'OAuth2 トークン',
    'カスタム認証ヘッダー',
    '機密な環境変数'
  ];
  
  // 制限データ（特別な保護）
  restricted: [
    'マスターパスワード',
    '暗号化キー',
    '個人識別情報',
    '決済情報'
  ];
}
```

### 8.3 スクリプト実行セキュリティ

#### 8.3.1 サンドボックス実装
```typescript
class ScriptSandbox {
  private readonly TIMEOUT = 10000; // 10秒
  private readonly MEMORY_LIMIT = 10 * 1024 * 1024; // 10MB
  
  // 安全な実行環境作成
  createSafeEnvironment(context: ScriptContext): SafeEnvironment {
    const safeGlobals = {
      // 許可されたグローバルオブジェクト
      JSON: JSON,
      Date: Date,
      Math: Math,
      parseInt: parseInt,
      parseFloat: parseFloat,
      isNaN: isNaN,
      isFinite: isFinite,
      
      // 制限付きコンソール
      console: {
        log: (...args: any[]) => this.safeConsoleLog(args),
        warn: (...args: any[]) => this.safeConsoleWarn(args),
        error: (...args: any[]) => this.safeConsoleError(args)
      },
      
      // Postman API エミュレーション
      pm: this.createPostmanAPI(context)
    };
    
    // 危険なオブジェクトを無効化
    const restrictedGlobals = {
      eval: undefined,
      Function: undefined,
      setTimeout: undefined,
      setInterval: undefined,
      XMLHttpRequest: undefined,
      fetch: undefined,
      WebSocket: undefined,
      Worker: undefined,
      SharedArrayBuffer: undefined,
      window: undefined,
      document: undefined,
      location: undefined,
      history: undefined,
      localStorage: undefined,
      sessionStorage: undefined,
      indexedDB: undefined
    };
    
    return { ...safeGlobals, ...restrictedGlobals };
  }
  
  // スクリプト実行
  async executeScript(script: string, environment: SafeEnvironment): Promise<any> {
    return new Promise((resolve, reject) => {
      // タイムアウト設定
      const timeout = setTimeout(() => {
        reject(new Error('Script execution timeout'));
      }, this.TIMEOUT);
      
      try {
        // Function constructor を使用した安全な実行
        const scriptFunction = new Function(
          ...Object.keys(environment),
          `"use strict"; ${script}`
        );
        
        const result = scriptFunction(...Object.values(environment));
        clearTimeout(timeout);
        resolve(result);
      } catch (error) {
        clearTimeout(timeout);
        reject(error);
      }
    });
  }
  
  // スクリプト静的解析
  analyzeScript(script: string): SecurityAnalysisResult {
    const dangerousPatterns = [
      { pattern: /eval\s*\(/, risk: 'HIGH', description: 'eval() usage detected' },
      { pattern: /Function\s*\(/, risk: 'HIGH', description: 'Function constructor usage' },
      { pattern: /XMLHttpRequest/, risk: 'MEDIUM', description: 'Direct XMLHttpRequest usage' },
      { pattern: /fetch\s*\(/, risk: 'MEDIUM', description: 'Fetch API usage' },
      { pattern: /window\./, risk: 'HIGH', description: 'Window object access' },
      { pattern: /document\./, risk: 'HIGH', description: 'Document object access' },
      { pattern: /location\./, risk: 'MEDIUM', description: 'Location object access' },
      { pattern: /import\s*\(/, risk: 'HIGH', description: 'Dynamic import usage' }
    ];
    
    const violations = dangerousPatterns
      .filter(p => p.pattern.test(script))
      .map(p => ({
        risk: p.risk,
        description: p.description,
        pattern: p.pattern.toString()
      }));
    
    return {
      safe: violations.length === 0,
      violations: violations,
      riskLevel: this.calculateRiskLevel(violations)
    };
  }
}
```

---

## 9. パフォーマンス最適化設計

### 9.1 メモリ管理

#### 9.1.1 メモリ使用量最適化
```typescript
interface MemoryOptimization {
  // オブジェクトプール
  objectPooling: {
    requestObjects: 'リクエストオブジェクトの再利用';
    responseObjects: 'レスポンスオブジェクトの再利用';
    domElements: 'DOM要素の再利用';
    eventHandlers: 'イベントハンドラーの再利用';
  };
  
  // 遅延初期化
  lazyInitialization: {
    heavyComponents: '重いコンポーネントの遅延初期化';
    largeData: '大きなデータセットの遅延読み込み';
    optionalFeatures: 'オプション機能の遅延初期化';
  };
  
  // メモリリーク防止
  leakPrevention: {
    eventListenerCleanup: 'イベントリスナーの適切なクリーンアップ';
    timerCleanup: 'タイマーの適切なクリーンアップ';
    referenceCleanup: '循環参照の防止';
    observerCleanup: 'Observerの適切なクリーンアップ';
  };
}
```

#### 9.1.2 ガベージコレクション最適化
```typescript
class MemoryManager {
  private objectPool: Map<string, any[]> = new Map();
  private cleanupTasks: Set<() => void> = new Set();
  
  // オブジェクトプール管理
  getPooledObject<T>(type: string, factory: () => T): T {
    const pool = this.objectPool.get(type) || [];
    
    if (pool.length > 0) {
      return pool.pop();
    }
    
    return factory();
  }
  
  returnToPool<T>(type: string, object: T): void {
    const pool = this.objectPool.get(type) || [];
    
    // プールサイズ制限
    if (pool.length < 10) {
      // オブジェクトをリセット
      this.resetObject(object);
      pool.push(object);
      this.objectPool.set(type, pool);
    }
  }
  
  // 定期的なメモリクリーンアップ
  scheduleCleanup(): void {
    setInterval(() => {
      this.performCleanup();
    }, 60000); // 1分ごと
  }
  
  private performCleanup(): void {
    // オブジェクトプールのクリーンアップ
    for (const [type, pool] of this.objectPool.entries()) {
      if (pool.length > 5) {
        this.objectPool.set(type, pool.slice(0, 5));
      }
    }
    
    // 登録されたクリーンアップタスクの実行
    for (const cleanup of this.cleanupTasks) {
      try {
        cleanup();
      } catch (error) {
        console.error('Cleanup task failed:', error);
      }
    }
    
    // 強制的なガベージコレクション（可能な場合）
    if (typeof window !== 'undefined' && 'gc' in window) {
      (window as any).gc();
    }
  }
  
  // クリーンアップタスク登録
  registerCleanupTask(cleanup: () => void): void {
    this.cleanupTasks.add(cleanup);
  }
  
  // クリーンアップタスク解除
  unregisterCleanupTask(cleanup: () => void): void {
    this.cleanupTasks.delete(cleanup);
  }
}
```

### 9.2 レンダリング最適化

#### 9.2.1 仮想スクロール
```typescript
class VirtualScrollManager {
  private container: HTMLElement;
  private itemHeight: number;
  private bufferSize: number = 5;
  private visibleItems: Map<number, HTMLElement> = new Map();
  
  constructor(container: HTMLElement, itemHeight: number) {
    this.container = container;
    this.itemHeight = itemHeight;
    this.setupScrollListener();
  }
  
  // 仮想スクロール実装
  renderVisibleItems(items: any[], renderItem: (item: any, index: number) => HTMLElement): void {
    const scrollTop = this.container.scrollTop;
    const containerHeight = this.container.clientHeight;
    
    // 表示範囲計算
    const startIndex = Math.max(0, Math.floor(scrollTop / this.itemHeight) - this.bufferSize);
    const endIndex = Math.min(
      items.length - 1,
      Math.ceil((scrollTop + containerHeight) / this.itemHeight) + this.bufferSize
    );
    
    // 不要なアイテムを削除
    for (const [index, element] of this.visibleItems.entries()) {
      if (index < startIndex || index > endIndex) {
        element.remove();
        this.visibleItems.delete(index);
      }
    }
    
    // 必要なアイテムを追加
    for (let i = startIndex; i <= endIndex; i++) {
      if (!this.visibleItems.has(i)) {
        const element = renderItem(items[i], i);
        element.style.position = 'absolute';
        element.style.top = `${i * this.itemHeight}px`;
        element.style.height = `${this.itemHeight}px`;
        
        this.container.appendChild(element);
        this.visibleItems.set(i, element);
      }
    }
    
    // コンテナの高さ設定
    this.container.style.height = `${items.length * this.itemHeight}px`;
  }
  
  private setupScrollListener(): void {
    let scrollTimeout: number;
    
    this.container.addEventListener('scroll', () => {
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        this.handleScroll();
      }, 16); // 60fps
    });
  }
  
  private handleScroll(): void {
    // スクロールイベントの処理
    const event = new CustomEvent('virtualscroll', {
      detail: {
        scrollTop: this.container.scrollTop,
        scrollLeft: this.container.scrollLeft
      }
    });
    this.container.dispatchEvent(event);
  }
}
```

#### 9.2.2 DOM操作最適化
```typescript
class DOMOptimizer {
  private batchOperations: (() => void)[] = [];
  private scheduledUpdate: boolean = false;
  
  // バッチDOM更新
  batchUpdate(operation: () => void): void {
    this.batchOperations.push(operation);
    
    if (!this.scheduledUpdate) {
      this.scheduleUpdate();
    }
  }
  
  private scheduleUpdate(): void {
    this.scheduledUpdate = true;
    
    requestAnimationFrame(() => {
      // すべての操作を一度に実行
      const operations = this.batchOperations.slice();
      this.batchOperations.length = 0;
      this.scheduledUpdate = false;
      
      // DOM書き込み前に読み込みを先に実行
      const readOperations: (() => void)[] = [];
      const writeOperations: (() => void)[] = [];
      
      for (const operation of operations) {
        if (this.isReadOperation(operation)) {
          readOperations.push(operation);
        } else {
          writeOperations.push(operation);
        }
      }
      
      // 読み込み→書き込みの順で実行（リフロー最小化）
      for (const operation of readOperations) {
        operation();
      }
      
      for (const operation of writeOperations) {
        operation();
      }
    });
  }
  
  // DocumentFragment使用による効率的なDOM構築
  buildDOMFragment(builder: (fragment: DocumentFragment) => void): DocumentFragment {
    const fragment = document.createDocumentFragment();
    builder(fragment);
    return fragment;
  }
  
  // テンプレート要素の再利用
  cloneTemplate(templateId: string): HTMLElement {
    const template = document.getElementById(templateId) as HTMLTemplateElement;
    if (!template) {
      throw new Error(`Template ${templateId} not found`);
    }
    
    return template.content.cloneNode(true) as HTMLElement;
  }
  
  private isReadOperation(operation: () => void): boolean {
    // 操作の種類を判定（実装は簡略化）
    const operationString = operation.toString();
    return operationString.includes('offsetHeight') ||
           operationString.includes('offsetWidth') ||
           operationString.includes('getBoundingClientRect') ||
           operationString.includes('scrollTop') ||
           operationString.includes('scrollLeft');
  }
}
```

### 9.3 ネットワーク最適化

#### 9.3.1 リクエスト最適化
```typescript
class NetworkOptimizer {
  private requestQueue: Map<string, RequestQueueItem> = new Map();
  private activeRequests: Set<string> = new Set();
  private maxConcurrentRequests: number = 6;
  
  // リクエストキューイング
  async queueRequest(request: RequestData): Promise<ResponseData> {
    const requestId = this.generateRequestId(request);
    
    // 重複リクエスト検出
    if (this.activeRequests.has(requestId)) {
      return this.waitForExistingRequest(requestId);
    }
    
    // 並行制限チェック
    if (this.activeRequests.size >= this.maxConcurrentRequests) {
      return this.enqueueRequest(request);
    }
    
    return this.executeRequest(request);
  }
  
  // リクエスト実行
  private async executeRequest(request: RequestData): Promise<ResponseData> {
    const requestId = this.generateRequestId(request);
    this.activeRequests.add(requestId);
    
    try {
      const startTime = performance.now();
      const response = await this.sendRequest(request);
      const endTime = performance.now();
      
      // パフォーマンス記録
      this.recordRequestMetrics(request, response, endTime - startTime);
      
      return response;
    } finally {
      this.activeRequests.delete(requestId);
      this.processQueue();
    }
  }
  
  // リクエスト圧縮
  private compressRequest(request: RequestData): RequestData {
    const compressed = { ...request };
    
    // Gzip Accept-Encoding追加
    if (!compressed.headers['Accept-Encoding']) {
      compressed.headers['Accept-Encoding'] = 'gzip, deflate, br';
    }
    
    // 不要なヘッダー削除
    delete compressed.headers[''];
    delete compressed.headers[' '];
    
    return compressed;
  }
  
  // レスポンスキャッシュ
  private cache: Map<string, CachedResponse> = new Map();
  
  getCachedResponse(request: RequestData): ResponseData | null {
    const cacheKey = this.generateCacheKey(request);
    const cached = this.cache.get(cacheKey);
    
    if (cached && !this.isCacheExpired(cached)) {
      return cached.response;
    }
    
    return null;
  }
  
  setCachedResponse(request: RequestData, response: ResponseData): void {
    const cacheKey = this.generateCacheKey(request);
    const ttl = this.calculateCacheTTL(response);
    
    this.cache.set(cacheKey, {
      response,
      timestamp: Date.now(),
      ttl
    });
    
    // キャッシュサイズ制限
    if (this.cache.size > 100) {
      this.evictOldestCache();
    }
  }
}
```

---

## 10. 監視・ログ設計

### 10.1 パフォーマンス監視

#### 10.1.1 メトリクス収集
```typescript
class PerformanceMonitor {
  private metrics: Map<string, MetricData[]> = new Map();
  private observers: PerformanceObserver[] = [];
  
  // パフォーマンス監視開始
  startMonitoring(): void {
    this.observeNavigationTiming();
    this.observeResourceTiming();
    this.observeUserTiming();
    this.observeMemoryUsage();
  }
  
  // Navigation Timing監視
  private observeNavigationTiming(): void {
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.entryType === 'navigation') {
          this.recordMetric('navigation', {
            name: 'page_load',
            value: entry.loadEventEnd - entry.navigationStart,
            timestamp: Date.now()
          });
        }
      }
    });
    
    observer.observe({ entryTypes: ['navigation'] });
    this.observers.push(observer);
  }
  
  // Resource Timing監視
  private observeResourceTiming(): void {
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.entryType === 'resource') {
          this.recordMetric('resource', {
            name: entry.name,
            value: entry.responseEnd - entry.requestStart,
            timestamp: Date.now(),
            size: (entry as any).transferSize || 0
          });
        }
      }
    });
    
    observer.observe({ entryTypes: ['resource'] });
    this.observers.push(observer);
  }
  
  // カスタムメトリクス記録
  recordCustomMetric(category: string, name: string, value: number, metadata?: any): void {
    this.recordMetric(category, {
      name,
      value,
      timestamp: Date.now(),
      metadata
    });
  }
  
  // メトリクス集計
  getMetricsSummary(category: string, timeRange: number = 3600000): MetricsSummary {
    const metrics = this.metrics.get(category) || [];
    const recent = metrics.filter(m => Date.now() - m.timestamp < timeRange);
    
    if (recent.length === 0) {
      return { count: 0, avg: 0, min: 0, max: 0, p95: 0 };
    }
    
    const values = recent.map(m => m.value).sort((a, b) => a - b);
    
    return {
      count: recent.length,
      avg: values.reduce((sum, v) => sum + v, 0) / values.length,
      min: values[0],
      max: values[values.length - 1],
      p95: values[Math.floor(values.length * 0.95)]
    };
  }
}
```

#### 10.1.2 アラート機能
```typescript
class AlertManager {
  private thresholds: Map<string, AlertThreshold> = new Map();
  private alertCallbacks: Map<string, AlertCallback[]> = new Map();
  
  // しきい値設定
  setThreshold(metric: string, threshold: AlertThreshold): void {
    this.thresholds.set(metric, threshold);
  }
  
  // アラートコールバック登録
  onAlert(metric: string, callback: AlertCallback): void {
    const callbacks = this.alertCallbacks.get(metric) || [];
    callbacks.push(callback);
    this.alertCallbacks.set(metric, callbacks);
  }
  
  // メトリクスチェック
  checkMetric(metric: string, value: number): void {
    const threshold = this.thresholds.get(metric);
    if (!threshold) return;
    
    const alert = this.evaluateThreshold(threshold, value);
    if (alert) {
      this.triggerAlert(metric, alert);
    }
  }
  
  private evaluateThreshold(threshold: AlertThreshold, value: number): Alert | null {
    if (threshold.critical && value >= threshold.critical) {
      return {
        level: 'critical',
        metric: threshold.metric,
        value,
        threshold: threshold.critical,
        message: `Critical threshold exceeded: ${value} >= ${threshold.critical}`
      };
    }
    
    if (threshold.warning && value >= threshold.warning) {
      return {
        level: 'warning',
        metric: threshold.metric,
        value,
        threshold: threshold.warning,
        message: `Warning threshold exceeded: ${value} >= ${threshold.warning}`
      };
    }
    
    return null;
  }
  
  private triggerAlert(metric: string, alert: Alert): void {
    const callbacks = this.alertCallbacks.get(metric) || [];
    
    for (const callback of callbacks) {
      try {
        callback(alert);
      } catch (error) {
        console.error('Alert callback failed:', error);
      }
    }
  }
}
```

### 10.2 ログシステム

#### 10.2.1 構造化ログ
```typescript
class StructuredLogger {
  private logBuffer: LogEntry[] = [];
  private maxBufferSize: number = 1000;
  private logLevel: LogLevel = LogLevel.INFO;
  
  // ログ出力
  log(level: LogLevel, message: string, data?: any, error?: Error): void {
    if (level < this.logLevel) return;
    
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level: LogLevel[level],
      message,
      data: this.sanitizeData(data),
      error: error ? {
        name: error.name,
        message: error.message,
        stack: error.stack
      } : undefined,
      context: this.gatherContext()
    };
    
    this.addToBuffer(entry);
    this.outputLog(entry);
  }
  
  // コンテキスト情報収集
  private gatherContext(): LogContext {
    return {
      userAgent: navigator.userAgent,
      url: window.location?.href || 'extension',
      timestamp: Date.now(),
      sessionId: this.getSessionId(),
      userId: this.getUserId() // 匿名化されたID
    };
  }
  
  // データサニタイゼーション
  private sanitizeData(data: any): any {
    if (!data) return data;
    
    const sanitized = JSON.parse(JSON.stringify(data));
    
    // 機密データをマスク
    this.maskSensitiveData(sanitized);
    
    return sanitized;
  }
  
  private maskSensitiveData(obj: any): void {
    const sensitiveKeys = ['password', 'token', 'key', 'secret', 'authorization'];
    
    if (typeof obj === 'object' && obj !== null) {
      for (const [key, value] of Object.entries(obj)) {
        if (sensitiveKeys.some(k => key.toLowerCase().includes(k))) {
          obj[key] = '***MASKED***';
        } else if (typeof value === 'object') {
          this.maskSensitiveData(value);
        }
      }
    }
  }
  
  // ログエクスポート
  exportLogs(filter?: LogFilter): string {
    let logs = this.logBuffer;
    
    if (filter) {
      logs = logs.filter(log => this.matchesFilter(log, filter));
    }
    
    return JSON.stringify(logs, null, 2);
  }
  
  // ログクリーンアップ
  cleanup(): void {
    const cutoff = Date.now() - (7 * 24 * 60 * 60 * 1000); // 7日前
    
    this.logBuffer = this.logBuffer.filter(log => 
      new Date(log.timestamp).getTime() > cutoff
    );
  }
}
```

---

## 11. まとめ

### 11.1 設計原則の実現

本構造設計文書では、以下の設計原則を実現しています：

#### 11.1.1 モジュラー設計
- **単一責任の原則**: 各コンポーネントは明確に定義された単一の責任を持つ
- **依存性の逆転**: 高レベルモジュールは低レベルモジュールの抽象に依存
- **オープン・クローズド原則**: 拡張に対してオープン、修正に対してクローズド

#### 11.1.2 スケーラビリティ
- **水平スケーリング**: コンポーネントの並列実行と分散処理
- **垂直スケーリング**: リソース効率的な実装とメモリ管理
- **機能拡張性**: 新機能の追加が既存システムに影響を与えない設計

#### 11.1.3 保守性
- **明確な責任分離**: レイヤー間の明確な境界と責任
- **テスタビリティ**: 各コンポーネントの独立したテストが可能
- **ドキュメント化**: 包括的な設計文書と実装ガイド

### 11.2 技術的成果

#### 11.2.1 アーキテクチャの確立
- 4層アーキテクチャ（プレゼンテーション、アプリケーション、ドメイン、インフラストラクチャ）
- Chrome Extension 特有の制約に最適化された設計
- セキュリティを最優先とした多層防御アーキテクチャ

#### 11.2.2 パフォーマンス最適化
- メモリ効率的なオブジェクト管理
- 非同期処理とバッチ処理の効果的な活用
- ネットワーク通信の最適化とキャッシュ戦略

#### 11.2.3 運用品質
- 包括的な監視・ログシステム
- 自動復旧機能とエラーハンドリング
- データ整合性とバックアップ・復旧機能

### 11.3 今後の展開

#### 11.3.1 実装フェーズ
1. **コアコンポーネント実装** (Phase 1)
   - StorageManager, RequestManager, VariableManager
   - 基本的なHTTP通信機能
   - 基本UI実装

2. **高度な機能実装** (Phase 2)
   - ScriptExecutor, CollectionManager, ScenarioManager
   - セキュリティ機能（暗号化、サンドボックス）
   - パフォーマンス最適化機能

3. **統合・テスト** (Phase 3)
   - システム統合テスト
   - パフォーマンステスト
   - セキュリティテスト

#### 11.3.2 継続的改善
- **監視データの活用**: 実際の使用データに基づく最適化
- **ユーザーフィードバック反映**: UX改善とフィーチャー追加
- **技術トレンド対応**: 新しい技術スタックの導入検討

---

**この構造設計文書は、PostPro API Tester Chrome拡張機能の技術的基盤を定義し、効率的で保守性の高い、セキュアなシステム構築を実現するための詳細な設計指針です。実装チームはこの設計に基づいて、高品質なソフトウェアを開発してください。**