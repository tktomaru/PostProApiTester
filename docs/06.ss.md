# 構造設計文書：PostPro API Tester Chrome 拡張

## 1. 文書概要

### 1.1 文書の目的
本構造設計文書は、PostPro API Tester Chrome拡張機能のシステム全体の構造とデータフローを具体的に設計するものです。各コンポーネントの構成、相互関係、モジュール分割、インターフェース設計を明確にし、効率的なシステム構築を実現します。

### 1.2 文書の範囲
- システムアーキテクチャ設計
- コンポーネント構成と相互関係
- データフロー設計
- モジュール分割とインターフェース
- ストレージ構造設計
- 通信プロトコル設計

### 1.3 参照文書
- システム企画書（docs/01.sp.md）
- 要求定義文書（docs/02.sa.md）
- 要件定義文書（docs/03.rd.md）
- 基本設計文書（docs/03.bd.md）
- UI基本設計文書（docs/04.ui.md）
- 外部設計文書（docs/05.ed.md）
- プロジェクト構成ファイル（CLAUDE.md）

### 1.4 要件トレーサビリティ
本構造設計文書は以下の要件との対応関係を明確にしています：

| 要件ID | 要件名 | 対応構造設計要素 | 実装優先度 |
|--------|--------|------------------|------------|
| FR-001 | HTTPリクエスト送信機能 | RequestManager, EnhancedRequestManager, HttpClient | 高 |
| FR-002 | 認証機能 | SecurityValidator, AuthenticationService | 高 |
| FR-005 | Pre-requestスクリプト実行 | ScriptExecutor, SecurityValidator, ScriptSandbox | 高 |
| FR-006 | テストスクリプト実行 | PostmanTestAPI, PostmanAPIEmulator, ScriptSandbox | 高 |
| FR-007 | 変数システム | VariableManager, VariableResolver | 高 |
| FR-009 | コレクション管理 | CollectionManager, CollectionRepository | 中 |
| FR-010 | シナリオ実行 | ScenarioManager, CollectionExecutor | 中 |
| NF-001 | 性能要件 | PerformanceMonitor, MemoryManager, MetricsCollector | 高 |
| NF-003 | 可用性要件 | ErrorHandler, RetryManager, RecoveryService | 高 |
| NF-004 | セキュリティ要件 | SecurityValidator, EncryptionService, SandboxManager | 高 |

### 1.5 設計重要ポイント

⭐ **アーキテクチャの核心設計原則**
1. **セキュリティファースト**: スクリプト実行のサンドボックス化、認証情報の暗号化
2. **パフォーマンス最適化**: メモリ効率、仮想スクロール、キャッシュ戦略
3. **Chrome拡張機能制約への適応**: Manifest V3準拠、ストレージ制限対応
4. **テスタビリティ**: モック可能な設計、依存性注入、単体テスト容易性

---

## 2. システムアーキテクチャ

### 2.1 全体アーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│                    Chrome Extension Runtime                  │
├─────────────────┬─────────────────┬─────────────────────────┤
│   Popup UI      │  Background     │    Content Script       │
│  (index.html)   │ Service Worker  │   (content.ts)          │
│                 │ (background.ts) │                         │
│  ┌─────────────┐│  ┌─────────────┐│  ┌─────────────────────┐│
│  │ App Layer   ││  │ Request     ││  │ Page Integration    ││
│  │ (app.ts)    ││  │ Orchestrator││  │                     ││
│  │             ││  │             ││  │ ┌─────────────────┐ ││
│  ├─────────────┤│  ├─────────────┤│  │ │ Injected Script │ ││
│  │ UI Layer    ││  │ Message     ││  │ │ (injected.ts)   │ ││
│  │ (utils.ts)  ││  │ Handler     ││  │ └─────────────────┘ ││
│  │             ││  │             ││  └─────────────────────┘│
│  ├─────────────┤│  ├─────────────┤│                         │
│  │ Core Layer  ││  │ Storage     ││                         │
│  │ Managers    ││  │ Manager     ││                         │
│  └─────────────┘│  └─────────────┘│                         │
├─────────────────┼─────────────────┼─────────────────────────┤
│                 │                 │                         │
│  Chrome Storage API               │  Web APIs               │
│  ├─ Local Storage                 │  ├─ XMLHttpRequest      │
│  ├─ Sync Storage                  │  ├─ Fetch API           │
│  └─ Session Storage               │  └─ WebSocket           │
│                                   │                         │
└─────────────────┴─────────────────┴─────────────────────────┘
                           │
                           ▼
                ┌─────────────────────┐
                │   External APIs     │
                ├─────────────────────┤
                │ Echo API Service    │
                │ (reply.tukutano.jp) │
                └─────────────────────┘
```

### 2.2 レイヤー構造

#### 2.2.1 プレゼンテーション層

**UIコンポーネント**
- mainView: メイン画面表示とナビゲーション
- requestEditor: リクエスト編集フォーム
- responseViewer: レスポンス表示パネル
- collectionTree: コレクション階層表示
- environmentSelector: 環境選択コンポーネント
- historyList: 履歴一覧表示
- settingsPanel: 設定画面

**イベントハンドリング**
- userInteraction: ユーザー操作イベント処理
- uiStateUpdate: UI状態更新処理
- validation: フォーム検証処理
- navigation: 画面遷移処理

**レンダリング**
- domManipulation: DOM要素の動的生成・更新
- templateRendering: テンプレートベースレンダリング
- stateBinding: データバインディング
- responsiveLayout: レスポンシブレイアウト

#### 2.2.2 アプリケーション層

**ビジネスロジック調整**
- requestFlow: リクエスト実行フロー制御
- collectionExecution: コレクション実行制御
- scenarioExecution: シナリオ実行制御
- testExecution: テスト実行制御

**状態管理**
- globalState: アプリケーション全体状態
- sessionState: セッション状態管理
- uiState: UI表示状態管理
- cacheState: キャッシュ状態管理

**統合制御**
- serviceCoordination: サービス間連携制御
- errorHandling: エラーハンドリング統合
- logging: ログ統合管理
- monitoring: 監視・メトリクス統合

#### 2.2.3 ドメイン層
```typescript
interface DomainLayer {
  // コアビジネスロジック
  businessLogic: {
    requestManager: 'HTTPリクエスト管理';
    collectionManager: 'コレクション管理';
    variableManager: '変数管理';
    scenarioManager: 'シナリオ管理';
    historyManager: '履歴管理';
    settingsManager: '設定管理';
  };
  
  // ドメインサービス
  domainServices: {
    authenticationService: '認証サービス';
    encryptionService: '暗号化サービス';
    validationService: '検証サービス';
    scriptExecutionService: 'スクリプト実行サービス';
    importExportService: 'インポート・エクスポートサービス';
  };
  
  // ドメインモデル
  domainModels: {
    request: 'リクエストエンティティ';
    collection: 'コレクションエンティティ';
    environment: '環境エンティティ';
    variable: '変数エンティティ';
    scenario: 'シナリオエンティティ';
    testResult: 'テスト結果エンティティ';
  };
}
```

#### 2.2.4 インフラストラクチャ層
```typescript
interface InfrastructureLayer {
  // データ永続化
  persistence: {
    storageAdapter: 'Chrome Storage APIアダプター';
    cacheManager: 'キャッシュマネージャー';
    backupManager: 'バックアップマネージャー';
    migrationManager: 'データマイグレーションマネージャー';
  };
  
  // 外部通信
  communication: {
    httpClient: 'HTTPクライアント（XMLHttpRequest）';
    messageHandler: 'Chrome Extension メッセージハンドラー';
    webSocketClient: 'WebSocketクライアント（将来対応）';
  };
  
  // システムサービス
  systemServices: {
    logger: 'ログサービス';
    errorHandler: 'エラーハンドラー';
    securityManager: 'セキュリティマネージャー';
    performanceMonitor: 'パフォーマンス監視';
  };
}
```

---

## 3. テスタビリティ設計

### 3.1 テスト容易性アーキテクチャ

#### 3.1.1 依存性注入設計原則
```typescript
// テスト容易性を重視した依存性注入パターン
interface TestableComponent {
  // テスト用の依存性注入インターフェース
  setDependencies(dependencies: ComponentDependencies): void;
  reset(): void; // テスト間のクリーンアップ
  getState(): ComponentState; // 内部状態の検証用
}

interface ComponentDependencies {
  storage?: StorageAdapter;
  httpClient?: HttpClientAdapter;
  logger?: LoggerAdapter;
  timeProvider?: TimeProvider;
  randomProvider?: RandomProvider;
}

// テスト用のファクトリーパターン
class TestableComponentFactory {
  static createRequestManager(overrides?: Partial<ComponentDependencies>): RequestManager {
    const dependencies = {
      storage: new MockStorageAdapter(),
      httpClient: new MockHttpClientAdapter(),
      logger: new MockLoggerAdapter(),
      timeProvider: new MockTimeProvider(),
      ...overrides
    };
    
    const manager = new RequestManager();
    manager.setDependencies(dependencies);
    return manager;
  }
}
```

#### 3.1.2 モック・スタブ対応設計
```typescript
// モック化容易性のためのアダプターパターン
interface StorageAdapter {
  get<T>(key: string): Promise<T | null>;
  set(key: string, value: any): Promise<void>;
  remove(key: string): Promise<void>;
}

class ChromeStorageAdapter implements StorageAdapter {
  async get<T>(key: string): Promise<T | null> {
    const result = await chrome.storage.local.get(key);
    return result[key] || null;
  }
  
  async set(key: string, value: any): Promise<void> {
    await chrome.storage.local.set({ [key]: value });
  }
  
  async remove(key: string): Promise<void> {
    await chrome.storage.local.remove(key);
  }
}

class MockStorageAdapter implements StorageAdapter {
  private storage: Map<string, any> = new Map();
  
  async get<T>(key: string): Promise<T | null> {
    return this.storage.get(key) || null;
  }
  
  async set(key: string, value: any): Promise<void> {
    this.storage.set(key, value);
  }
  
  async remove(key: string): Promise<void> {
    this.storage.delete(key);
  }
  
  // テスト用の追加メソッド
  clear(): void {
    this.storage.clear();
  }
  
  getAll(): Record<string, any> {
    return Object.fromEntries(this.storage);
  }
}
```

#### 3.1.3 単体テスト設計指針
```typescript
interface TestDesignPrinciples {
  // Given-When-Then パターンの適用
  testStructure: {
    given: 'テスト前提条件の明確な設定';
    when: '単一のアクション実行';
    then: '期待結果の検証';
  };
  
  // テストケース分類
  testCategories: {
    happy: '正常系テストケース';
    edge: '境界値テストケース';
    error: '異常系テストケース';
    integration: '統合テストケース';
  };
  
  // テストデータ管理
  testData: {
    fixtures: 'テスト用固定データ';
    factories: 'テストデータ生成ファクトリー';
    builders: 'テストオブジェクトビルダー';
  };
}

// テスト用のデータビルダーパターン
class RequestTestDataBuilder {
  private request: Partial<Request> = {};
  
  withMethod(method: HttpMethod): this {
    this.request.method = method;
    return this;
  }
  
  withUrl(url: string): this {
    this.request.url = url;
    return this;
  }
  
  withHeaders(headers: Record<string, string>): this {
    this.request.headers = headers;
    return this;
  }
  
  withAuth(auth: AuthConfig): this {
    this.request.auth = auth;
    return this;
  }
  
  build(): Request {
    return {
      id: this.request.id || 'test-request-id',
      name: this.request.name || 'Test Request',
      method: this.request.method || 'GET',
      url: this.request.url || 'https://api.example.com/test',
      headers: this.request.headers || {},
      params: this.request.params || {},
      body: this.request.body || { mode: 'none', data: null },
      auth: this.request.auth || { type: 'none', config: {} },
      preRequestScript: this.request.preRequestScript || '',
      testScript: this.request.testScript || '',
      createdAt: new Date(),
      updatedAt: new Date(),
      tags: this.request.tags || []
    };
  }
}
```

### 3.2 テストアーキテクチャ層

#### 3.2.1 テスト層の分離
```typescript
interface TestArchitectureLayers {
  // Unit Tests (単体テスト層)
  unit: {
    scope: '個別クラス・関数のテスト';
    isolation: '依存関係をモック化';
    speed: '高速実行';
    coverage: '80%以上のカバレッジ目標';
  };
  
  // Integration Tests (統合テスト層)
  integration: {
    scope: 'コンポーネント間の連携テスト';
    realDependencies: '実際の依存関係を使用';
    scenarios: '実用的なシナリオベース';
    environment: 'テスト専用環境';
  };
  
  // E2E Tests (エンドツーエンドテスト層)
  e2e: {
    scope: 'ユーザーシナリオの完全テスト';
    browser: '実際のChrome拡張機能環境';
    automation: 'Puppeteerによる自動化';
    validation: 'UI・UX観点での検証';
  };
  
  // Contract Tests (契約テスト層)
  contract: {
    scope: 'API契約の検証';
    specification: 'OpenAPI/JSON Schema準拠';
    compatibility: '下位互換性の確認';
    documentation: '生きたドキュメントとしての機能';
  };
}
```

---

## 4. コンポーネント構成

### 3.1 コアコンポーネント

#### 3.1.1 RequestManager（リクエスト管理）
**要件対応**: FR-001, FR-002, FR-005, FR-006
**テスト識別子**: COMP-001

```typescript
class RequestManager {
  // 依存関係 (Dependency Injection対応)
  private variableManager: VariableManager;
  private scriptExecutor: ScriptExecutor;
  private httpClient: HttpClient;
  private logger: Logger;
  
  // テスタビリティ向上のための設計
  constructor(
    variableManager?: VariableManager,
    scriptExecutor?: ScriptExecutor,
    httpClient?: HttpClient,
    logger?: Logger
  ) {
    this.variableManager = variableManager || new VariableManager();
    this.scriptExecutor = scriptExecutor || new ScriptExecutor();
    this.httpClient = httpClient || new HttpClient();
    this.logger = logger || new Logger();
  }
  
  // 公開メソッド
  async sendRequest(request: RequestData): Promise<ResponseData> {
    // 1. プリリクエストスクリプト実行
    // 2. 変数置換
    // 3. HTTPリクエスト送信
    // 4. レスポンス処理
    // 5. テストスクリプト実行
    // 6. 結果保存
  }
  
  async validateRequest(request: RequestData): Promise<ValidationResult> {
    // リクエストデータ検証
  }
  
  async executePreRequestScript(script: string, context: ScriptContext): Promise<void> {
    // プリリクエストスクリプト実行
  }
  
  async executeTestScript(script: string, response: ResponseData): Promise<TestResult[]> {
    // テストスクリプト実行
  }
  
  // 内部構造
  private processRequest(request: RequestData): ProcessedRequest;
  private handleResponse(response: XMLHttpRequest): ResponseData;
  private handleError(error: Error): ErrorData;
}
```

#### 3.1.2 CollectionManager（コレクション管理）
**要件対応**: FR-009, FR-010
**テスト識別子**: COMP-002

```typescript
class CollectionManager {
  // 依存関係 (テスト容易性を考慮)
  private storageManager: StorageManager;
  private requestManager: RequestManager;
  private variableManager: VariableManager;
  
  // モック化可能なコンストラクタ設計
  constructor(
    storageManager?: StorageManager,
    requestManager?: RequestManager,
    variableManager?: VariableManager
  ) {
    this.storageManager = storageManager || new StorageManager();
    this.requestManager = requestManager || new RequestManager();
    this.variableManager = variableManager || new VariableManager();
  }
  
  // コレクション CRUD
  async createCollection(data: CreateCollectionData): Promise<Collection> {
    // コレクション作成ロジック
  }
  
  async updateCollection(id: string, updates: Partial<Collection>): Promise<Collection> {
    // コレクション更新ロジック
  }
  
  async deleteCollection(id: string): Promise<void> {
    // コレクション削除ロジック
  }
  
  async getCollection(id: string): Promise<Collection | null> {
    // コレクション取得ロジック
  }
  
  // リクエスト管理
  async addRequest(collectionId: string, request: RequestData): Promise<void> {
    // リクエスト追加ロジック
  }
  
  async moveRequest(requestId: string, targetCollectionId: string, targetFolderId?: string): Promise<void> {
    // リクエスト移動ロジック
  }
  
  // コレクション実行
  async runCollection(id: string, options?: RunOptions): Promise<CollectionRunResult> {
    // コレクション実行ロジック
  }
  
  // 階層構造管理
  private buildHierarchy(collection: Collection): HierarchyNode[];
  private validateHierarchy(hierarchy: HierarchyNode[]): boolean;
}
```

#### 3.1.3 VariableManager（変数管理）
**要件対応**: FR-007, FR-008
**テスト識別子**: COMP-003

```typescript
interface VariableStorage {
  get(scope: string, key: string): any;
  set(scope: string, key: string, value: any): void;
  delete(scope: string, key: string): void;
}

class VariableManager {
  // 変数スコープ管理 (テスト容易性のため抽象化)
  private globalVariables: Map<string, VariableData>;
  private environmentVariables: Map<string, Map<string, VariableData>>;
  private collectionVariables: Map<string, Map<string, VariableData>>;
  private runtimeVariables: Map<string, VariableData>;
  private storage: VariableStorage;
  
  // テスト用のストレージインジェクション
  constructor(storage?: VariableStorage) {
    this.storage = storage || new ChromeStorageAdapter();
    this.initializeVariableMaps();
  }
  
  private initializeVariableMaps(): void {
    this.globalVariables = new Map();
    this.environmentVariables = new Map();
    this.collectionVariables = new Map();
    this.runtimeVariables = new Map();
  }
  
  // 変数取得（優先順位：runtime > collection > environment > global）
  getVariable(name: string, context: VariableContext): any {
    // 変数解決ロジック
  }
  
  // 変数設定
  setVariable(name: string, value: any, scope: VariableScope, contextId?: string): void {
    // 変数設定ロジック
  }
  
  // 変数置換
  replaceVariables(text: string, context: VariableContext): string {
    // {{variableName}} 形式の置換処理
    // 動的変数（$timestamp, $guid等）の処理
  }
  
  // 動的変数生成
  private generateBuiltInVariable(name: string): any {
    switch (name) {
      case '$timestamp': return Date.now();
      case '$isoTimestamp': return new Date().toISOString();
      case '$randomInt': return Math.floor(Math.random() * 1000);
      case '$guid': return this.generateGUID();
      case '$randomString': return this.generateRandomString(10);
    }
  }
  
  // 変数の循環参照チェック
  private checkCircularReference(variables: Map<string, VariableData>): boolean;
}
```

#### 3.1.4 ScenarioManager（シナリオ管理）
**要件対応**: FR-010
**テスト識別子**: COMP-004

```typescript
interface ScenarioExecutionStrategy {
  execute(scenario: Scenario, context: ScenarioContext): Promise<ScenarioResult>;
}

class ScenarioManager {
  // 依存関係 (Strategy Patternでテスト容易性向上)
  private requestManager: RequestManager;
  private variableManager: VariableManager;
  private storageManager: StorageManager;
  private executionStrategy: ScenarioExecutionStrategy;
  
  constructor(
    requestManager?: RequestManager,
    variableManager?: VariableManager,
    storageManager?: StorageManager,
    executionStrategy?: ScenarioExecutionStrategy
  ) {
    this.requestManager = requestManager || new RequestManager();
    this.variableManager = variableManager || new VariableManager();
    this.storageManager = storageManager || new StorageManager();
    this.executionStrategy = executionStrategy || new SequentialExecutionStrategy();
  }
  
  // シナリオ実行
  async runScenario(scenarioId: string, options?: ScenarioRunOptions): Promise<ScenarioRunResult> {
    // 1. シナリオ取得
    // 2. リクエスト順次実行
    // 3. 条件分岐処理
    // 4. エラーハンドリング
    // 5. 結果集計
  }
  
  // シナリオステップ実行
  private async executeStep(step: ScenarioStep, context: ScenarioContext): Promise<StepResult> {
    switch (step.type) {
      case 'request':
        return await this.executeRequestStep(step, context);
      case 'delay':
        return await this.executeDelayStep(step, context);
      case 'condition':
        return await this.executeConditionStep(step, context);
      case 'loop':
        return await this.executeLoopStep(step, context);
    }
  }
  
  // 条件分岐処理
  private evaluateCondition(condition: string, context: ScenarioContext): boolean {
    // JavaScript式の安全な評価
  }
  
  // シナリオ状態管理
  private async saveScenarioState(scenarioId: string, state: ScenarioState): Promise<void>;
  private async loadScenarioState(scenarioId: string): Promise<ScenarioState | null>;
}
```

### 3.2 サポートコンポーネント

#### 3.2.1 StorageManager（ストレージ管理）
```typescript
class StorageManager {
  private cache: Map<string, CacheEntry>;
  private writeQueue: WriteQueue;
  
  // 基本操作
  async get<T>(key: string): Promise<T | null> {
    // 1. キャッシュチェック
    // 2. Chrome Storage読み込み
    // 3. キャッシュ更新
  }
  
  async set(key: string, value: any): Promise<void> {
    // 1. 書き込みキューに追加
    // 2. キャッシュ更新
    // 3. バッチ書き込み実行
  }
  
  async remove(key: string): Promise<void> {
    // 削除処理
  }
  
  // バッチ操作
  async getBatch(keys: string[]): Promise<Record<string, any>> {
    // 複数キー一括読み込み
  }
  
  async setBatch(items: Record<string, any>): Promise<void> {
    // 複数キー一括書き込み
  }
  
  // ストレージ監視
  onStorageChange(callback: StorageChangeCallback): void {
    // ストレージ変更監視
  }
  
  // クォータ管理
  async getQuotaUsage(): Promise<QuotaInfo> {
    // ストレージ使用量取得
  }
  
  async cleanupOldData(): Promise<void> {
    // 古いデータのクリーンアップ
  }
  
  // キャッシュ管理
  private updateCache(key: string, value: any): void;
  private invalidateCache(key: string): void;
  private flushWriteQueue(): Promise<void>;
}
```

#### 3.2.2 ScriptExecutor（スクリプト実行）
```typescript
class ScriptExecutor {
  private sandbox: ScriptSandbox;
  private postmanAPI: PostmanAPIEmulator;
  
  // スクリプト実行
  async executeScript(script: string, context: ScriptContext): Promise<ScriptResult> {
    try {
      // 1. スクリプト検証
      this.validateScript(script);
      
      // 2. サンドボックス環境準備
      const env = this.prepareSandboxEnvironment(context);
      
      // 3. スクリプト実行
      const result = await this.runInSandbox(script, env);
      
      // 4. 結果処理
      return this.processResult(result);
    } catch (error) {
      return this.handleScriptError(error);
    }
  }
  
  // Postman API エミュレーション
  createPostmanAPI(context: ScriptContext): PostmanAPI {
    return {
      test: (name: string, fn: () => void) => this.registerTest(name, fn),
      expect: (actual: any) => new ChaiExpectEmulator(actual),
      response: this.createResponseObject(context.response),
      variables: this.createVariablesObject(context),
      environment: this.createEnvironmentObject(context),
      globals: this.createGlobalsObject(context)
    };
  }
  
  // セキュリティ検証
  private validateScript(script: string): void {
    // 危険なパターンの検出
    const dangerousPatterns = [
      /eval\s*\(/,
      /Function\s*\(/,
      /setTimeout\s*\(/,
      /setInterval\s*\(/,
      /XMLHttpRequest/,
      /fetch\s*\(/,
      /window\./,
      /document\./
    ];
    
    for (const pattern of dangerousPatterns) {
      if (pattern.test(script)) {
        throw new SecurityError(`Dangerous pattern detected: ${pattern}`);
      }
    }
  }
  
  // サンドボックス環境
  private prepareSandboxEnvironment(context: ScriptContext): SandboxEnvironment {
    return {
      // 許可されたグローバルオブジェクト
      JSON: JSON,
      Date: Date,
      Math: Math,
      console: new SafeConsole(),
      pm: this.createPostmanAPI(context),
      
      // セキュリティ制限
      eval: undefined,
      Function: undefined,
      setTimeout: undefined,
      setInterval: undefined,
      XMLHttpRequest: undefined,
      fetch: undefined,
      window: undefined,
      document: undefined
    };
  }
}
```

#### 3.2.3 HttpClient（HTTP通信）
```typescript
class HttpClient {
  private defaultTimeout: number = 30000;
  private interceptors: RequestInterceptor[] = [];
  
  // HTTPリクエスト送信
  async send(request: ProcessedRequest): Promise<ResponseData> {
    const xhr = new XMLHttpRequest();
    
    return new Promise((resolve, reject) => {
      // タイムアウト設定
      xhr.timeout = request.timeout || this.defaultTimeout;
      
      // イベントハンドラー設定
      xhr.onload = () => {
        if (xhr.readyState === XMLHttpRequest.DONE) {
          resolve(this.createResponseData(xhr));
        }
      };
      
      xhr.onerror = () => reject(new NetworkError('Request failed'));
      xhr.ontimeout = () => reject(new TimeoutError('Request timeout'));
      
      // リクエスト初期化
      xhr.open(request.method, request.url, true);
      
      // ヘッダー設定
      for (const [name, value] of Object.entries(request.headers)) {
        xhr.setRequestHeader(name, value);
      }
      
      // プログレス監視
      if (request.onProgress) {
        xhr.upload.onprogress = request.onProgress;
      }
      
      // リクエスト送信
      xhr.send(request.body);
    });
  }
  
  // レスポンスデータ作成
  private createResponseData(xhr: XMLHttpRequest): ResponseData {
    return {
      status: xhr.status,
      statusText: xhr.statusText,
      headers: this.parseHeaders(xhr.getAllResponseHeaders()),
      body: xhr.responseText,
      responseTime: performance.now() - this.requestStartTime,
      size: new Blob([xhr.responseText]).size,
      url: xhr.responseURL
    };
  }
  
  // ヘッダーパース
  private parseHeaders(headerString: string): Record<string, string> {
    const headers: Record<string, string> = {};
    headerString.split('\r\n').forEach(line => {
      const [name, value] = line.split(': ');
      if (name && value) {
        headers[name.toLowerCase()] = value;
      }
    });
    return headers;
  }
  
  // リクエストインターセプター
  addRequestInterceptor(interceptor: RequestInterceptor): void {
    this.interceptors.push(interceptor);
  }
  
  private async applyInterceptors(request: ProcessedRequest): Promise<ProcessedRequest> {
    let processedRequest = request;
    for (const interceptor of this.interceptors) {
      processedRequest = await interceptor.process(processedRequest);
    }
    return processedRequest;
  }
}
```

---

## 4. データフロー設計

### 4.1 リクエスト実行フロー

```
[User Action] → [UI Event] → [Request Creation] → [Pre-processing]
      ↓
[Variable Resolution] → [Pre-request Script] → [HTTP Request] → [Response Processing]
      ↓
[Test Script Execution] → [Result Storage] → [UI Update] → [History Save]
```

#### 4.1.1 詳細フロー定義
```typescript
interface RequestExecutionFlow {
  // Phase 1: Request Preparation
  preparation: {
    userInput: 'ユーザーからのリクエスト情報入力';
    validation: 'リクエストデータ検証';
    preprocessing: 'リクエスト前処理';
  };
  
  // Phase 2: Variable Processing
  variableProcessing: {
    contextBuilding: '変数コンテキスト構築';
    resolution: '変数参照解決';
    substitution: '変数値置換';
  };
  
  // Phase 3: Pre-request Processing
  preRequestProcessing: {
    scriptValidation: 'プリリクエストスクリプト検証';
    scriptExecution: 'プリリクエストスクリプト実行';
    variableUpdate: '実行時変数更新';
  };
  
  // Phase 4: HTTP Communication
  httpCommunication: {
    requestBuilding: 'HTTPリクエスト構築';
    transmission: 'リクエスト送信';
    responseReceiving: 'レスポンス受信';
  };
  
  // Phase 5: Response Processing
  responseProcessing: {
    parsing: 'レスポンスデータパース';
    validation: 'レスポンス検証';
    testExecution: 'テストスクリプト実行';
  };
  
  // Phase 6: Result Finalization
  finalization: {
    resultCompilation: '実行結果編集';
    historyStorage: '履歴保存';
    uiUpdate: 'UI更新';
    notification: 'ユーザー通知';
  };
}
```

### 4.2 コレクション実行フロー

```
[Collection Selection] → [Execution Planning] → [Request Queue Building]
      ↓
[Sequential Processing] → [Individual Request Execution] → [Result Aggregation]
      ↓
[Report Generation] → [History Storage] → [UI Update]
```

#### 4.2.1 コレクション実行詳細
```typescript
interface CollectionExecutionFlow {
  // 実行計画
  planning: {
    collectionAnalysis: 'コレクション構造解析';
    dependencyMapping: '依存関係マッピング';
    executionOrderDetermination: '実行順序決定';
    resourceAllocation: 'リソース割り当て';
  };
  
  // 実行制御
  execution: {
    queueManagement: '実行キュー管理';
    concurrencyControl: '並行実行制御';
    errorHandling: 'エラーハンドリング';
    progressReporting: '進捗レポート';
  };
  
  // 結果処理
  resultProcessing: {
    aggregation: '結果集約';
    analysis: '実行分析';
    reporting: 'レポート生成';
    notification: '完了通知';
  };
}
```

### 4.3 データ永続化フロー

```
[Data Change] → [Validation] → [Serialization] → [Encryption (if needed)]
      ↓
[Cache Update] → [Storage Write] → [Verification] → [Event Notification]
```

#### 4.3.1 ストレージ操作詳細
```typescript
interface StorageFlow {
  // 書き込みフロー
  write: {
    validation: 'データ妥当性検証';
    serialization: 'JSON シリアライゼーション';
    encryption: '機密データ暗号化';
    compression: 'データ圧縮（オプション）';
    atomicWrite: 'アトミック書き込み';
    verification: '書き込み検証';
    cacheUpdate: 'キャッシュ更新';
    eventNotification: '変更通知';
  };
  
  // 読み込みフロー
  read: {
    cacheCheck: 'キャッシュ確認';
    storageRead: 'ストレージ読み込み';
    verification: 'データ整合性確認';
    decryption: '暗号化データ復号';
    deserialization: 'デシリアライゼーション';
    validation: 'データ検証';
    cacheUpdate: 'キャッシュ更新';
    delivery: 'データ配信';
  };
}
```

---

## 5. モジュール分割とインターフェース

### 5.1 モジュール構造

```
src/                         # フラット構造による実装（Chrome拡張制約・開発効率考慮）
├── # エントリーポイント・初期化
│   ├── index.ts            # メインエントリーポイント
│   ├── init.ts             # 初期化処理・設定読み込み
│   └── app.ts              # アプリケーションメインロジック
├── # Chrome拡張機能コア
│   ├── background.ts       # Service Worker・バックグラウンド処理
│   ├── content.ts          # Content Script・ページ統合
│   └── injected.ts         # Injected Script・DOM操作
├── # リクエスト管理・実行
│   ├── requestManager.ts         # 基本リクエスト管理・HTTP送信
│   ├── enhancedRequestManager.ts # 拡張リクエスト管理（エラーハンドリング・監視統合）
│   └── interceptorManager.ts     # HTTPリクエストインターセプト
├── # テスト・スクリプト実行
│   ├── postmanTestAPI.ts   # Postman互換テストAPI（pm.test, pm.expect等）
│   └── securityValidator.ts # スクリプト実行セキュリティ検証・サンドボックス
├── # データ管理
│   ├── collectionManager.ts # コレクション・フォルダ管理
│   ├── scenarioManager.ts   # シナリオ実行制御・順次処理
│   ├── variableManager.ts   # 変数管理（Global/Environment/Collection 3階層）
│   ├── historyManager.ts    # リクエスト履歴管理・検索
│   └── importExport.ts      # データインポート・エクスポート（Postman等）
├── # システム基盤
│   ├── state.ts            # グローバル状態管理・Chrome Storage連携
│   ├── settings.ts         # アプリケーション設定管理
│   ├── errorHandler.ts     # エラーハンドリング・ログ出力
│   ├── performanceMonitor.ts # パフォーマンス監視・メトリクス収集
│   └── defaultData.ts      # サンプルデータ・デフォルト設定・初期化データ
├── # UI・ユーティリティ
│   ├── utils.ts            # UI操作・DOM管理・ユーティリティ関数
│   └── types.ts            # TypeScript型定義・インターフェース統合
```

### 5.1.1 実装アーキテクチャの特徴

**フラット構造採用理由**:
- **Chrome拡張機能制約**: Manifest V3のService Worker制約による単純化
- **開発効率**: 小規模チームでの高速開発とメンテナンス性
- **モジュール依存**: 循環依存回避とシンプルなインポート構造
- **バンドルサイズ**: 拡張機能配布サイズの最適化

**論理的レイヤー分離**:
実装はフラットだが、機能的には4層アーキテクチャを維持：
- **Presentation**: utils.ts（UI操作）、app.ts（メインUI制御）
- **Application**: state.ts（状態統合）、settings.ts（アプリ制御）
- **Domain**: *Manager.ts群（ビジネスロジック）
- **Infrastructure**: Chrome APIs連携、ストレージ、通信

### 5.2 モジュール間インターフェース

#### 5.2.1 核心モジュール間通信
```typescript
interface CoreModuleCommunication {
  // EnhancedRequestManager → 統合リクエスト管理
  enhancedRequestManager: {
    sendRequest: '(request: RequestData) => Promise<RequestResult>';
    validateRequest: '(request: RequestData) => ValidationResult';
    executeWithMonitoring: '(request: RequestData) => Promise<RequestResult>';
    abortRequest: '(requestId: string) => void';
  };
  
  // PostmanTestAPI → テストスクリプト実行
  postmanTestAPI: {
    executeTest: '(script: string, response: ResponseData) => Promise<TestResult[]>';
    createTestContext: '(request: RequestData, response: ResponseData) => TestContext';
    pm: {
      test: '(name: string, fn: Function) => void';
      expect: '(value: any) => ChaiExpectStatic';
      response: 'ResponseAccessor';
      request: 'RequestAccessor';
      environment: 'EnvironmentAccessor';
      globals: 'GlobalsAccessor';
    };
  };
  
  // PerformanceMonitor → メトリクス監視
  performanceMonitor: {
    startTimer: '(category: string, name?: string) => string';
    endTimer: '(timerId: string) => number';
    recordMetric: '(category: string, data: MetricData) => void';
    getSummary: '(category?: string) => MetricsSummary';
    startMonitoring: '() => void';
    stopMonitoring: '() => void';
  };
  
  // SecurityValidator → セキュリティ検証
  securityValidator: {
    validateScript: '(script: string) => ValidationResult';
    executeSafely: '(script: string, context: ScriptContext) => Promise<ScriptResult>';
    checkPermissions: '(request: RequestData) => SecurityCheck';
    sanitizeInput: '(input: string) => string';
  };
  
  // VariableManager → 変数管理
  variableManager: {
    getVariable: '(name: string, context?: VariableContext) => any';
    setVariable: '(name: string, value: any, scope: VariableScope) => void';
    replaceVariables: '(text: string, context?: VariableContext) => string';
    resolveAllVariables: '(request: RequestData) => ProcessedRequest';
  };
}
```

#### 5.2.2 レイヤー間通信
```typescript
interface LayerCommunication {
  // Presentation → Application
  presentationToApplication: {
    // ユーザーアクション
    sendRequest: '(request: RequestData) => Promise<void>';
    runCollection: '(collectionId: string) => Promise<void>';
    updateSettings: '(settings: Partial<AppSettings>) => Promise<void>';
    
    // 状態取得
    getState: '() => AppState';
    subscribeToState: '(callback: StateChangeCallback) => void';
  };
  
  // Application → Domain
  applicationToDomain: {
    // ビジネスロジック呼び出し
    requestManager: RequestManagerInterface;
    collectionManager: CollectionManagerInterface;
    variableManager: VariableManagerInterface;
    scenarioManager: ScenarioManagerInterface;
  };
  
  // Domain → Infrastructure
  domainToInfrastructure: {
    // データ永続化
    storage: StorageManagerInterface;
    
    // 外部通信
    httpClient: HttpClientInterface;
    messageHandler: MessageHandlerInterface;
    
    // システムサービス
    logger: LoggerInterface;
    errorHandler: ErrorHandlerInterface;
  };
}
```

### 5.3 依存性注入設計

#### 5.3.1 DIコンテナ
```typescript
class DIContainer {
  private services: Map<string, any> = new Map();
  private factories: Map<string, () => any> = new Map();
  
  // サービス登録
  register<T>(name: string, factory: () => T): void {
    this.factories.set(name, factory);
  }
  
  // シングルトン登録
  registerSingleton<T>(name: string, factory: () => T): void {
    this.register(name, () => {
      if (!this.services.has(name)) {
        this.services.set(name, factory());
      }
      return this.services.get(name);
    });
  }
  
  // サービス取得
  resolve<T>(name: string): T {
    const factory = this.factories.get(name);
    if (!factory) {
      throw new Error(`Service ${name} not registered`);
    }
    return factory();
  }
  
  // 初期化
  static initializeContainer(): DIContainer {
    const container = new DIContainer();
    
    // Infrastructure Services
    container.registerSingleton('logger', () => new Logger());
    container.registerSingleton('storageManager', () => new StorageManager());
    container.registerSingleton('httpClient', () => new HttpClient());
    
    // Domain Services
    container.registerSingleton('variableManager', () => 
      new VariableManager(container.resolve('storageManager'))
    );
    container.registerSingleton('requestManager', () => 
      new RequestManager(
        container.resolve('variableManager'),
        container.resolve('httpClient'),
        container.resolve('logger')
      )
    );
    container.registerSingleton('collectionManager', () => 
      new CollectionManager(
        container.resolve('storageManager'),
        container.resolve('requestManager')
      )
    );
    
    return container;
  }
}
```

#### 5.3.2 サービスライフサイクル
```typescript
interface ServiceLifecycle {
  // シングルトンサービス（アプリケーション全体で1つのインスタンス）
  singletons: [
    'StorageManager',
    'Logger',
    'ErrorHandler',
    'VariableManager',
    'HistoryManager',
    'SettingsManager'
  ];
  
  // トランジェントサービス（呼び出し毎に新しいインスタンス）
  transients: [
    'HttpClient',
    'ScriptExecutor',
    'ValidationService',
    'EncryptionService'
  ];
  
  // スコープドサービス（特定のスコープ内で1つのインスタンス）
  scoped: [
    'RequestManager', // リクエスト実行スコープ
    'CollectionManager', // コレクション実行スコープ
    'ScenarioManager' // シナリオ実行スコープ
  ];
}
```

---

## 6. ストレージ構造設計

### 6.1 Chrome Storage スキーマ

#### 6.1.1 主要ストレージキー構造
```typescript
interface StorageSchema {
  // アプリケーション状態
  'postpro_app_state': {
    version: string;
    lastUpdated: string;
    currentRequest: RequestData | null;
    currentCollection: string | null;
    currentEnvironment: string | null;
    ui: UIState;
    settings: AppSettings;
  };
  
  // コレクションデータ
  'postpro_collections': {
    [collectionId: string]: Collection;
  };
  
  // 環境データ
  'postpro_environments': {
    [environmentId: string]: Environment;
  };
  
  // グローバル変数
  'postpro_global_variables': {
    [variableName: string]: VariableData;
  };
  
  // リクエスト履歴
  'postpro_history': {
    items: HistoryItem[];
    lastCleanup: string;
    maxItems: number;
  };
  
  // バックアップデータ
  'postpro_backups': {
    [backupId: string]: BackupData;
  };
  
  // キャッシュデータ
  'postpro_cache': {
    [cacheKey: string]: CacheEntry;
  };
}
```

#### 6.1.2 データ型定義
```typescript
interface Collection {
  id: string;
  name: string;
  description: string;
  created: string;
  updated: string;
  
  // 階層構造
  folders: Folder[];
  requests: RequestData[];
  
  // 変数とメタデータ
  variables: Record<string, VariableData>;
  metadata: CollectionMetadata;
}

interface RequestData {
  id: string;
  name: string;
  description: string;
  folderId: string | null;
  
  // HTTP設定
  method: HTTPMethod;
  url: string;
  headers: Record<string, string>;
  body: RequestBody;
  auth: AuthConfig;
  
  // スクリプト
  preRequestScript: string;
  testScript: string;
  
  // 設定
  settings: RequestSettings;
}

interface Environment {
  id: string;
  name: string;
  description: string;
  variables: Record<string, VariableData>;
  settings: EnvironmentSettings;
}

interface VariableData {
  value: any;
  type: 'string' | 'number' | 'boolean' | 'object';
  description: string;
  encrypted: boolean;
  created: string;
  updated: string;
}
```

### 6.2 ストレージアクセスパターン

#### 6.2.1 読み込みパターン
```typescript
interface StorageReadPatterns {
  // 起動時一括読み込み
  applicationBootstrap: {
    keys: ['postpro_app_state', 'postpro_environments', 'postpro_global_variables'];
    caching: 'メモリキャッシュ';
    frequency: '起動時1回';
  };
  
  // 遅延読み込み
  lazyLoading: {
    collections: 'コレクション選択時に読み込み';
    history: '履歴画面表示時に読み込み';
    backups: 'バックアップ管理画面表示時に読み込み';
  };
  
  // オンデマンド読み込み
  onDemand: {
    largeResponses: '大きなレスポンスデータは個別に読み込み';
    archives: 'アーカイブデータは必要時のみ';
  };
}
```

#### 6.2.2 書き込みパターン
```typescript
interface StorageWritePatterns {
  // リアルタイム書き込み
  realTime: {
    appState: 'アプリケーション状態の即座更新';
    currentRequest: '現在のリクエストの自動保存';
    settings: 'ユーザー設定の即座反映';
  };
  
  // バッチ書き込み
  batch: {
    history: '履歴アイテムの定期的なバッチ保存';
    cache: 'キャッシュデータの定期フラッシュ';
    metrics: 'メトリクスデータの集約保存';
  };
  
  // デバウンス書き込み
  debounced: {
    variables: '変数値の変更検知後の遅延保存';
    collections: 'コレクション編集の完了後保存';
    environments: '環境設定の編集完了後保存';
  };
}
```

### 6.3 データ整合性とマイグレーション

#### 6.3.1 データ検証
```typescript
interface DataValidation {
  // スキーマ検証
  schema: {
    validation: 'JSON Schema による構造検証';
    enforcement: '書き込み時の強制検証';
    migration: 'スキーマ変更時の自動マイグレーション';
  };
  
  // 整合性チェック
  integrity: {
    referentialIntegrity: '参照整合性チェック（コレクション→リクエスト等）';
    dataConsistency: 'データ一貫性チェック';
    checksumValidation: 'チェックサムによるデータ破損検知';
  };
  
  // 修復機能
  repair: {
    automaticRepair: '軽微な不整合の自動修復';
    guidedRepair: 'ユーザーガイド付き修復';
    backupRestore: 'バックアップからの復旧';
  };
}
```

#### 6.3.2 マイグレーション戦略
```typescript
interface MigrationStrategy {
  // バージョン管理
  versioning: {
    schemaVersion: 'データスキーマバージョン';
    appVersion: 'アプリケーションバージョン';
    compatibility: '下位互換性マトリクス';
  };
  
  // マイグレーション実行
  execution: {
    sequential: '順次マイグレーション実行';
    rollback: 'マイグレーション失敗時のロールバック';
    validation: 'マイグレーション後の検証';
    notification: 'ユーザーへの進捗通知';
  };
  
  // マイグレーションスクリプト
  scripts: {
    'v1.0_to_v2.0': 'コレクション構造の変更';
    'v2.0_to_v2.1': '環境変数暗号化の追加';
    'v2.1_to_v3.0': '新しい認証方式の追加';
  };
}
```

---

## 7. 通信プロトコル設計

### 7.1 Chrome Extension メッセージング

#### 7.1.1 メッセージ構造
```typescript
interface ExtensionMessage {
  // 基本構造
  type: MessageType;
  id: string; // メッセージ識別子
  timestamp: number;
  source: 'popup' | 'background' | 'content' | 'injected';
  target: 'popup' | 'background' | 'content' | 'injected';
  
  // ペイロード
  payload: {
    action: string;
    data?: any;
    error?: string;
    metadata?: Record<string, any>;
  };
  
  // 応答制御
  response?: {
    required: boolean;
    timeout: number;
    callback?: string;
  };
}
```

#### 7.1.2 メッセージタイプ定義
```typescript
enum MessageType {
  // リクエスト実行
  SEND_REQUEST = 'SEND_REQUEST',
  REQUEST_RESPONSE = 'REQUEST_RESPONSE',
  REQUEST_ERROR = 'REQUEST_ERROR',
  REQUEST_PROGRESS = 'REQUEST_PROGRESS',
  
  // 状態管理
  STATE_UPDATE = 'STATE_UPDATE',
  STATE_SYNC = 'STATE_SYNC',
  STATE_RESET = 'STATE_RESET',
  
  // コレクション管理
  COLLECTION_CREATE = 'COLLECTION_CREATE',
  COLLECTION_UPDATE = 'COLLECTION_UPDATE',
  COLLECTION_DELETE = 'COLLECTION_DELETE',
  COLLECTION_RUN = 'COLLECTION_RUN',
  
  // スクリプト実行
  SCRIPT_EXECUTE = 'SCRIPT_EXECUTE',
  SCRIPT_RESULT = 'SCRIPT_RESULT',
  SCRIPT_ERROR = 'SCRIPT_ERROR',
  
  // システム
  HEALTH_CHECK = 'HEALTH_CHECK',
  ERROR_REPORT = 'ERROR_REPORT',
  LOG_MESSAGE = 'LOG_MESSAGE'
}
```

#### 7.1.3 メッセージルーティング
```typescript
class MessageRouter {
  private handlers: Map<MessageType, MessageHandler> = new Map();
  private middlewares: MessageMiddleware[] = [];
  
  // ハンドラー登録
  registerHandler(type: MessageType, handler: MessageHandler): void {
    this.handlers.set(type, handler);
  }
  
  // ミドルウェア登録
  use(middleware: MessageMiddleware): void {
    this.middlewares.push(middleware);
  }
  
  // メッセージ処理
  async handleMessage(message: ExtensionMessage): Promise<ExtensionMessage | void> {
    try {
      // ミドルウェア処理
      for (const middleware of this.middlewares) {
        message = await middleware.process(message);
      }
      
      // ハンドラー実行
      const handler = this.handlers.get(message.type);
      if (handler) {
        return await handler.handle(message);
      }
      
      throw new Error(`Handler not found for message type: ${message.type}`);
    } catch (error) {
      return this.createErrorResponse(message, error);
    }
  }
  
  // エラーレスポンス作成
  private createErrorResponse(originalMessage: ExtensionMessage, error: Error): ExtensionMessage {
    return {
      type: MessageType.REQUEST_ERROR,
      id: originalMessage.id,
      timestamp: Date.now(),
      source: originalMessage.target,
      target: originalMessage.source,
      payload: {
        action: 'error',
        error: error.message,
        data: originalMessage
      }
    };
  }
}
```

### 7.2 HTTP通信プロトコル

#### 7.2.1 リクエスト構造
```typescript
interface HTTPRequestProtocol {
  // 基本構造
  structure: {
    method: HTTPMethod;
    url: URL;
    headers: Record<string, string>;
    body?: RequestBody;
    timeout: number;
  };
  
  // 認証情報
  authentication: {
    type: 'none' | 'basic' | 'bearer' | 'apikey' | 'oauth2';
    credentials: AuthCredentials;
    location: 'header' | 'query' | 'body';
  };
  
  // リクエスト設定
  settings: {
    followRedirects: boolean;
    validateSSL: boolean;
    proxy?: ProxyConfig;
    retryCount: number;
    retryDelay: number;
  };
  
  // メタデータ
  metadata: {
    requestId: string;
    timestamp: number;
    collectionId?: string;
    environmentId?: string;
    scenario?: string;
  };
}
```

#### 7.2.2 レスポンス処理
```typescript
interface HTTPResponseProtocol {
  // レスポンス構造
  structure: {
    status: number;
    statusText: string;
    headers: Record<string, string>;
    body: string | ArrayBuffer | Blob;
    url: string;
  };
  
  // メタデータ
  metadata: {
    responseTime: number;
    size: number;
    redirectCount: number;
    fromCache: boolean;
    timestamp: number;
  };
  
  // 処理設定
  processing: {
    maxSize: number; // 50MB
    timeout: number; // 30秒
    encoding: string; // UTF-8
    compression: boolean;
  };
}
```

### 7.3 WebSocket プロトコル（将来対応）

#### 7.3.1 接続管理
```typescript
interface WebSocketProtocol {
  // 接続設定
  connection: {
    url: string;
    protocols: string[];
    headers: Record<string, string>;
    timeout: number;
  };
  
  // メッセージフォーマット
  messageFormat: {
    type: 'text' | 'binary';
    encoding: 'utf-8' | 'base64';
    compression: boolean;
  };
  
  // 接続制御
  control: {
    autoReconnect: boolean;
    reconnectInterval: number;
    maxReconnectAttempts: number;
    heartbeatInterval: number;
  };
}
```

---

## 8. セキュリティアーキテクチャ

### 8.1 セキュリティレイヤー

#### 8.1.1 多層防御
```typescript
interface SecurityLayers {
  // 入力検証層
  inputValidation: {
    sanitization: 'ユーザー入力のサニタイゼーション';
    validation: 'データ形式・範囲検証';
    encoding: '安全なエンコーディング';
    filtering: '危険なパターンフィルタリング';
  };
  
  // 認証・認可層
  authentication: {
    credentialStorage: '認証情報の安全な保存';
    tokenManagement: 'トークンライフサイクル管理';
    sessionManagement: 'セッション管理';
    accessControl: 'アクセス制御';
  };
  
  // 暗号化層
  encryption: {
    dataAtRest: '保存データの暗号化';
    dataInTransit: '通信データの暗号化';
    keyManagement: '暗号鍵管理';
    randomGeneration: '暗号学的乱数生成';
  };
  
  // 実行環境層
  executionEnvironment: {
    sandboxing: 'スクリプト実行のサンドボックス化';
    privilegeSeparation: '特権分離';
    resourceLimiting: 'リソース制限';
    monitoring: 'セキュリティ監視';
  };
}
```

#### 8.1.2 コンテンツセキュリティポリシー
```typescript
interface ContentSecurityPolicy {
  // 基本ポリシー
  basePolicy: {
    'default-src': "'self'";
    'script-src': "'self' 'unsafe-eval'"; // スクリプト実行のため
    'style-src': "'self' 'unsafe-inline'"; // インラインスタイルのため
    'img-src': "'self' data: chrome-extension:";
    'font-src': "'self'";
    'connect-src': "'self' https:";
    'object-src': "'none'";
    'base-uri': "'none'";
    'form-action': "'none'";
  };
  
  // 例外設定
  exceptions: {
    'unsafe-eval': 'スクリプト実行エンジンのため必要';
    'unsafe-inline': 'CSS-in-JS使用のため必要';
    'https:': 'HTTPS APIアクセスのため必要';
  };
  
  // 監視
  reporting: {
    'report-uri': '/csp-report';
    'report-to': 'csp-endpoint';
  };
}
```

### 8.2 データ保護

#### 8.2.1 暗号化実装
```typescript
class EncryptionService {
  private readonly ALGORITHM = 'AES-GCM';
  private readonly KEY_LENGTH = 256;
  private readonly IV_LENGTH = 12;
  private readonly ITERATIONS = 100000;
  
  // マスターキー生成
  async generateMasterKey(password: string, salt: Uint8Array): Promise<CryptoKey> {
    const encoder = new TextEncoder();
    const passwordData = encoder.encode(password);
    
    // PBKDF2でキー導出
    const baseKey = await crypto.subtle.importKey(
      'raw',
      passwordData,
      'PBKDF2',
      false,
      ['deriveKey']
    );
    
    return await crypto.subtle.deriveKey(
      {
        name: 'PBKDF2',
        salt: salt,
        iterations: this.ITERATIONS,
        hash: 'SHA-256'
      },
      baseKey,
      {
        name: this.ALGORITHM,
        length: this.KEY_LENGTH
      },
      false,
      ['encrypt', 'decrypt']
    );
  }
  
  // データ暗号化
  async encrypt(data: string, key: CryptoKey): Promise<EncryptedData> {
    const encoder = new TextEncoder();
    const dataBytes = encoder.encode(data);
    
    // ランダムIV生成
    const iv = crypto.getRandomValues(new Uint8Array(this.IV_LENGTH));
    
    // 暗号化実行
    const encryptedData = await crypto.subtle.encrypt(
      {
        name: this.ALGORITHM,
        iv: iv
      },
      key,
      dataBytes
    );
    
    return {
      algorithm: this.ALGORITHM,
      iv: Array.from(iv),
      data: Array.from(new Uint8Array(encryptedData)),
      timestamp: Date.now()
    };
  }
  
  // データ復号化
  async decrypt(encryptedData: EncryptedData, key: CryptoKey): Promise<string> {
    const iv = new Uint8Array(encryptedData.iv);
    const data = new Uint8Array(encryptedData.data);
    
    const decryptedData = await crypto.subtle.decrypt(
      {
        name: this.ALGORITHM,
        iv: iv
      },
      key,
      data
    );
    
    const decoder = new TextDecoder();
    return decoder.decode(decryptedData);
  }
}
```

#### 8.2.2 機密データ分類
```typescript
interface DataClassification {
  // 公開データ（暗号化不要）
  public: [
    'コレクション名・説明',
    'リクエスト名・説明',
    'フォルダ構造',
    'UI設定',
    '非機密な環境変数'
  ];
  
  // 機密データ（暗号化必須）
  confidential: [
    'Basic認証のユーザー名・パスワード',
    'Bearer トークン',
    'API キー',
    'OAuth2 トークン',
    'カスタム認証ヘッダー',
    '機密な環境変数'
  ];
  
  // 制限データ（特別な保護）
  restricted: [
    'マスターパスワード',
    '暗号化キー',
    '個人識別情報',
    '決済情報'
  ];
}
```

### 8.3 スクリプト実行セキュリティ

#### 8.3.1 サンドボックス実装
```typescript
class ScriptSandbox {
  private readonly TIMEOUT = 10000; // 10秒
  private readonly MEMORY_LIMIT = 10 * 1024 * 1024; // 10MB
  
  // 安全な実行環境作成
  createSafeEnvironment(context: ScriptContext): SafeEnvironment {
    const safeGlobals = {
      // 許可されたグローバルオブジェクト
      JSON: JSON,
      Date: Date,
      Math: Math,
      parseInt: parseInt,
      parseFloat: parseFloat,
      isNaN: isNaN,
      isFinite: isFinite,
      
      // 制限付きコンソール
      console: {
        log: (...args: any[]) => this.safeConsoleLog(args),
        warn: (...args: any[]) => this.safeConsoleWarn(args),
        error: (...args: any[]) => this.safeConsoleError(args)
      },
      
      // Postman API エミュレーション
      pm: this.createPostmanAPI(context)
    };
    
    // 危険なオブジェクトを無効化
    const restrictedGlobals = {
      eval: undefined,
      Function: undefined,
      setTimeout: undefined,
      setInterval: undefined,
      XMLHttpRequest: undefined,
      fetch: undefined,
      WebSocket: undefined,
      Worker: undefined,
      SharedArrayBuffer: undefined,
      window: undefined,
      document: undefined,
      location: undefined,
      history: undefined,
      localStorage: undefined,
      sessionStorage: undefined,
      indexedDB: undefined
    };
    
    return { ...safeGlobals, ...restrictedGlobals };
  }
  
  // スクリプト実行
  async executeScript(script: string, environment: SafeEnvironment): Promise<any> {
    return new Promise((resolve, reject) => {
      // タイムアウト設定
      const timeout = setTimeout(() => {
        reject(new Error('Script execution timeout'));
      }, this.TIMEOUT);
      
      try {
        // Function constructor を使用した安全な実行
        const scriptFunction = new Function(
          ...Object.keys(environment),
          `"use strict"; ${script}`
        );
        
        const result = scriptFunction(...Object.values(environment));
        clearTimeout(timeout);
        resolve(result);
      } catch (error) {
        clearTimeout(timeout);
        reject(error);
      }
    });
  }
  
  // スクリプト静的解析
  analyzeScript(script: string): SecurityAnalysisResult {
    const dangerousPatterns = [
      { pattern: /eval\s*\(/, risk: 'HIGH', description: 'eval() usage detected' },
      { pattern: /Function\s*\(/, risk: 'HIGH', description: 'Function constructor usage' },
      { pattern: /XMLHttpRequest/, risk: 'MEDIUM', description: 'Direct XMLHttpRequest usage' },
      { pattern: /fetch\s*\(/, risk: 'MEDIUM', description: 'Fetch API usage' },
      { pattern: /window\./, risk: 'HIGH', description: 'Window object access' },
      { pattern: /document\./, risk: 'HIGH', description: 'Document object access' },
      { pattern: /location\./, risk: 'MEDIUM', description: 'Location object access' },
      { pattern: /import\s*\(/, risk: 'HIGH', description: 'Dynamic import usage' }
    ];
    
    const violations = dangerousPatterns
      .filter(p => p.pattern.test(script))
      .map(p => ({
        risk: p.risk,
        description: p.description,
        pattern: p.pattern.toString()
      }));
    
    return {
      safe: violations.length === 0,
      violations: violations,
      riskLevel: this.calculateRiskLevel(violations)
    };
  }
}
```

---

## 9. パフォーマンス最適化設計

### 9.1 メモリ管理

#### 9.1.1 メモリ使用量最適化
```typescript
interface MemoryOptimization {
  // オブジェクトプール
  objectPooling: {
    requestObjects: 'リクエストオブジェクトの再利用';
    responseObjects: 'レスポンスオブジェクトの再利用';
    domElements: 'DOM要素の再利用';
    eventHandlers: 'イベントハンドラーの再利用';
  };
  
  // 遅延初期化
  lazyInitialization: {
    heavyComponents: '重いコンポーネントの遅延初期化';
    largeData: '大きなデータセットの遅延読み込み';
    optionalFeatures: 'オプション機能の遅延初期化';
  };
  
  // メモリリーク防止
  leakPrevention: {
    eventListenerCleanup: 'イベントリスナーの適切なクリーンアップ';
    timerCleanup: 'タイマーの適切なクリーンアップ';
    referenceCleanup: '循環参照の防止';
    observerCleanup: 'Observerの適切なクリーンアップ';
  };
}
```

#### 9.1.2 ガベージコレクション最適化
```typescript
class MemoryManager {
  private objectPool: Map<string, any[]> = new Map();
  private cleanupTasks: Set<() => void> = new Set();
  
  // オブジェクトプール管理
  getPooledObject<T>(type: string, factory: () => T): T {
    const pool = this.objectPool.get(type) || [];
    
    if (pool.length > 0) {
      return pool.pop();
    }
    
    return factory();
  }
  
  returnToPool<T>(type: string, object: T): void {
    const pool = this.objectPool.get(type) || [];
    
    // プールサイズ制限
    if (pool.length < 10) {
      // オブジェクトをリセット
      this.resetObject(object);
      pool.push(object);
      this.objectPool.set(type, pool);
    }
  }
  
  // 定期的なメモリクリーンアップ
  scheduleCleanup(): void {
    setInterval(() => {
      this.performCleanup();
    }, 60000); // 1分ごと
  }
  
  private performCleanup(): void {
    // オブジェクトプールのクリーンアップ
    for (const [type, pool] of this.objectPool.entries()) {
      if (pool.length > 5) {
        this.objectPool.set(type, pool.slice(0, 5));
      }
    }
    
    // 登録されたクリーンアップタスクの実行
    for (const cleanup of this.cleanupTasks) {
      try {
        cleanup();
      } catch (error) {
        console.error('Cleanup task failed:', error);
      }
    }
    
    // 強制的なガベージコレクション（可能な場合）
    if (typeof window !== 'undefined' && 'gc' in window) {
      (window as any).gc();
    }
  }
  
  // クリーンアップタスク登録
  registerCleanupTask(cleanup: () => void): void {
    this.cleanupTasks.add(cleanup);
  }
  
  // クリーンアップタスク解除
  unregisterCleanupTask(cleanup: () => void): void {
    this.cleanupTasks.delete(cleanup);
  }
}
```

### 9.2 レンダリング最適化

#### 9.2.1 仮想スクロール
```typescript
class VirtualScrollManager {
  private container: HTMLElement;
  private itemHeight: number;
  private bufferSize: number = 5;
  private visibleItems: Map<number, HTMLElement> = new Map();
  
  constructor(container: HTMLElement, itemHeight: number) {
    this.container = container;
    this.itemHeight = itemHeight;
    this.setupScrollListener();
  }
  
  // 仮想スクロール実装
  renderVisibleItems(items: any[], renderItem: (item: any, index: number) => HTMLElement): void {
    const scrollTop = this.container.scrollTop;
    const containerHeight = this.container.clientHeight;
    
    // 表示範囲計算
    const startIndex = Math.max(0, Math.floor(scrollTop / this.itemHeight) - this.bufferSize);
    const endIndex = Math.min(
      items.length - 1,
      Math.ceil((scrollTop + containerHeight) / this.itemHeight) + this.bufferSize
    );
    
    // 不要なアイテムを削除
    for (const [index, element] of this.visibleItems.entries()) {
      if (index < startIndex || index > endIndex) {
        element.remove();
        this.visibleItems.delete(index);
      }
    }
    
    // 必要なアイテムを追加
    for (let i = startIndex; i <= endIndex; i++) {
      if (!this.visibleItems.has(i)) {
        const element = renderItem(items[i], i);
        element.style.position = 'absolute';
        element.style.top = `${i * this.itemHeight}px`;
        element.style.height = `${this.itemHeight}px`;
        
        this.container.appendChild(element);
        this.visibleItems.set(i, element);
      }
    }
    
    // コンテナの高さ設定
    this.container.style.height = `${items.length * this.itemHeight}px`;
  }
  
  private setupScrollListener(): void {
    let scrollTimeout: number;
    
    this.container.addEventListener('scroll', () => {
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        this.handleScroll();
      }, 16); // 60fps
    });
  }
  
  private handleScroll(): void {
    // スクロールイベントの処理
    const event = new CustomEvent('virtualscroll', {
      detail: {
        scrollTop: this.container.scrollTop,
        scrollLeft: this.container.scrollLeft
      }
    });
    this.container.dispatchEvent(event);
  }
}
```

#### 9.2.2 DOM操作最適化
```typescript
class DOMOptimizer {
  private batchOperations: (() => void)[] = [];
  private scheduledUpdate: boolean = false;
  
  // バッチDOM更新
  batchUpdate(operation: () => void): void {
    this.batchOperations.push(operation);
    
    if (!this.scheduledUpdate) {
      this.scheduleUpdate();
    }
  }
  
  private scheduleUpdate(): void {
    this.scheduledUpdate = true;
    
    requestAnimationFrame(() => {
      // すべての操作を一度に実行
      const operations = this.batchOperations.slice();
      this.batchOperations.length = 0;
      this.scheduledUpdate = false;
      
      // DOM書き込み前に読み込みを先に実行
      const readOperations: (() => void)[] = [];
      const writeOperations: (() => void)[] = [];
      
      for (const operation of operations) {
        if (this.isReadOperation(operation)) {
          readOperations.push(operation);
        } else {
          writeOperations.push(operation);
        }
      }
      
      // 読み込み→書き込みの順で実行（リフロー最小化）
      for (const operation of readOperations) {
        operation();
      }
      
      for (const operation of writeOperations) {
        operation();
      }
    });
  }
  
  // DocumentFragment使用による効率的なDOM構築
  buildDOMFragment(builder: (fragment: DocumentFragment) => void): DocumentFragment {
    const fragment = document.createDocumentFragment();
    builder(fragment);
    return fragment;
  }
  
  // テンプレート要素の再利用
  cloneTemplate(templateId: string): HTMLElement {
    const template = document.getElementById(templateId) as HTMLTemplateElement;
    if (!template) {
      throw new Error(`Template ${templateId} not found`);
    }
    
    return template.content.cloneNode(true) as HTMLElement;
  }
  
  private isReadOperation(operation: () => void): boolean {
    // 操作の種類を判定（実装は簡略化）
    const operationString = operation.toString();
    return operationString.includes('offsetHeight') ||
           operationString.includes('offsetWidth') ||
           operationString.includes('getBoundingClientRect') ||
           operationString.includes('scrollTop') ||
           operationString.includes('scrollLeft');
  }
}
```

### 9.3 ネットワーク最適化

#### 9.3.1 リクエスト最適化
```typescript
class NetworkOptimizer {
  private requestQueue: Map<string, RequestQueueItem> = new Map();
  private activeRequests: Set<string> = new Set();
  private maxConcurrentRequests: number = 6;
  
  // リクエストキューイング
  async queueRequest(request: RequestData): Promise<ResponseData> {
    const requestId = this.generateRequestId(request);
    
    // 重複リクエスト検出
    if (this.activeRequests.has(requestId)) {
      return this.waitForExistingRequest(requestId);
    }
    
    // 並行制限チェック
    if (this.activeRequests.size >= this.maxConcurrentRequests) {
      return this.enqueueRequest(request);
    }
    
    return this.executeRequest(request);
  }
  
  // リクエスト実行
  private async executeRequest(request: RequestData): Promise<ResponseData> {
    const requestId = this.generateRequestId(request);
    this.activeRequests.add(requestId);
    
    try {
      const startTime = performance.now();
      const response = await this.sendRequest(request);
      const endTime = performance.now();
      
      // パフォーマンス記録
      this.recordRequestMetrics(request, response, endTime - startTime);
      
      return response;
    } finally {
      this.activeRequests.delete(requestId);
      this.processQueue();
    }
  }
  
  // リクエスト圧縮
  private compressRequest(request: RequestData): RequestData {
    const compressed = { ...request };
    
    // Gzip Accept-Encoding追加
    if (!compressed.headers['Accept-Encoding']) {
      compressed.headers['Accept-Encoding'] = 'gzip, deflate, br';
    }
    
    // 不要なヘッダー削除
    delete compressed.headers[''];
    delete compressed.headers[' '];
    
    return compressed;
  }
  
  // レスポンスキャッシュ
  private cache: Map<string, CachedResponse> = new Map();
  
  getCachedResponse(request: RequestData): ResponseData | null {
    const cacheKey = this.generateCacheKey(request);
    const cached = this.cache.get(cacheKey);
    
    if (cached && !this.isCacheExpired(cached)) {
      return cached.response;
    }
    
    return null;
  }
  
  setCachedResponse(request: RequestData, response: ResponseData): void {
    const cacheKey = this.generateCacheKey(request);
    const ttl = this.calculateCacheTTL(response);
    
    this.cache.set(cacheKey, {
      response,
      timestamp: Date.now(),
      ttl
    });
    
    // キャッシュサイズ制限
    if (this.cache.size > 100) {
      this.evictOldestCache();
    }
  }
}
```

---

## 10. 監視・ログ設計

### 10.1 パフォーマンス監視

#### 10.1.1 メトリクス収集
```typescript
class PerformanceMonitor {
  private metrics: Map<string, MetricData[]> = new Map();
  private observers: PerformanceObserver[] = [];
  
  // パフォーマンス監視開始
  startMonitoring(): void {
    this.observeNavigationTiming();
    this.observeResourceTiming();
    this.observeUserTiming();
    this.observeMemoryUsage();
  }
  
  // Navigation Timing監視
  private observeNavigationTiming(): void {
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.entryType === 'navigation') {
          this.recordMetric('navigation', {
            name: 'page_load',
            value: entry.loadEventEnd - entry.navigationStart,
            timestamp: Date.now()
          });
        }
      }
    });
    
    observer.observe({ entryTypes: ['navigation'] });
    this.observers.push(observer);
  }
  
  // Resource Timing監視
  private observeResourceTiming(): void {
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.entryType === 'resource') {
          this.recordMetric('resource', {
            name: entry.name,
            value: entry.responseEnd - entry.requestStart,
            timestamp: Date.now(),
            size: (entry as any).transferSize || 0
          });
        }
      }
    });
    
    observer.observe({ entryTypes: ['resource'] });
    this.observers.push(observer);
  }
  
  // カスタムメトリクス記録
  recordCustomMetric(category: string, name: string, value: number, metadata?: any): void {
    this.recordMetric(category, {
      name,
      value,
      timestamp: Date.now(),
      metadata
    });
  }
  
  // メトリクス集計
  getMetricsSummary(category: string, timeRange: number = 3600000): MetricsSummary {
    const metrics = this.metrics.get(category) || [];
    const recent = metrics.filter(m => Date.now() - m.timestamp < timeRange);
    
    if (recent.length === 0) {
      return { count: 0, avg: 0, min: 0, max: 0, p95: 0 };
    }
    
    const values = recent.map(m => m.value).sort((a, b) => a - b);
    
    return {
      count: recent.length,
      avg: values.reduce((sum, v) => sum + v, 0) / values.length,
      min: values[0],
      max: values[values.length - 1],
      p95: values[Math.floor(values.length * 0.95)]
    };
  }
}
```

#### 10.1.2 アラート機能
```typescript
class AlertManager {
  private thresholds: Map<string, AlertThreshold> = new Map();
  private alertCallbacks: Map<string, AlertCallback[]> = new Map();
  
  // しきい値設定
  setThreshold(metric: string, threshold: AlertThreshold): void {
    this.thresholds.set(metric, threshold);
  }
  
  // アラートコールバック登録
  onAlert(metric: string, callback: AlertCallback): void {
    const callbacks = this.alertCallbacks.get(metric) || [];
    callbacks.push(callback);
    this.alertCallbacks.set(metric, callbacks);
  }
  
  // メトリクスチェック
  checkMetric(metric: string, value: number): void {
    const threshold = this.thresholds.get(metric);
    if (!threshold) return;
    
    const alert = this.evaluateThreshold(threshold, value);
    if (alert) {
      this.triggerAlert(metric, alert);
    }
  }
  
  private evaluateThreshold(threshold: AlertThreshold, value: number): Alert | null {
    if (threshold.critical && value >= threshold.critical) {
      return {
        level: 'critical',
        metric: threshold.metric,
        value,
        threshold: threshold.critical,
        message: `Critical threshold exceeded: ${value} >= ${threshold.critical}`
      };
    }
    
    if (threshold.warning && value >= threshold.warning) {
      return {
        level: 'warning',
        metric: threshold.metric,
        value,
        threshold: threshold.warning,
        message: `Warning threshold exceeded: ${value} >= ${threshold.warning}`
      };
    }
    
    return null;
  }
  
  private triggerAlert(metric: string, alert: Alert): void {
    const callbacks = this.alertCallbacks.get(metric) || [];
    
    for (const callback of callbacks) {
      try {
        callback(alert);
      } catch (error) {
        console.error('Alert callback failed:', error);
      }
    }
  }
}
```

### 10.2 ログシステム

#### 10.2.1 構造化ログ
```typescript
class StructuredLogger {
  private logBuffer: LogEntry[] = [];
  private maxBufferSize: number = 1000;
  private logLevel: LogLevel = LogLevel.INFO;
  
  // ログ出力
  log(level: LogLevel, message: string, data?: any, error?: Error): void {
    if (level < this.logLevel) return;
    
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level: LogLevel[level],
      message,
      data: this.sanitizeData(data),
      error: error ? {
        name: error.name,
        message: error.message,
        stack: error.stack
      } : undefined,
      context: this.gatherContext()
    };
    
    this.addToBuffer(entry);
    this.outputLog(entry);
  }
  
  // コンテキスト情報収集
  private gatherContext(): LogContext {
    return {
      userAgent: navigator.userAgent,
      url: window.location?.href || 'extension',
      timestamp: Date.now(),
      sessionId: this.getSessionId(),
      userId: this.getUserId() // 匿名化されたID
    };
  }
  
  // データサニタイゼーション
  private sanitizeData(data: any): any {
    if (!data) return data;
    
    const sanitized = JSON.parse(JSON.stringify(data));
    
    // 機密データをマスク
    this.maskSensitiveData(sanitized);
    
    return sanitized;
  }
  
  private maskSensitiveData(obj: any): void {
    const sensitiveKeys = ['password', 'token', 'key', 'secret', 'authorization'];
    
    if (typeof obj === 'object' && obj !== null) {
      for (const [key, value] of Object.entries(obj)) {
        if (sensitiveKeys.some(k => key.toLowerCase().includes(k))) {
          obj[key] = '***MASKED***';
        } else if (typeof value === 'object') {
          this.maskSensitiveData(value);
        }
      }
    }
  }
  
  // ログエクスポート
  exportLogs(filter?: LogFilter): string {
    let logs = this.logBuffer;
    
    if (filter) {
      logs = logs.filter(log => this.matchesFilter(log, filter));
    }
    
    return JSON.stringify(logs, null, 2);
  }
  
  // ログクリーンアップ
  cleanup(): void {
    const cutoff = Date.now() - (7 * 24 * 60 * 60 * 1000); // 7日前
    
    this.logBuffer = this.logBuffer.filter(log => 
      new Date(log.timestamp).getTime() > cutoff
    );
  }
}
```

---

## 11. 依存関係とデプロイメント設計

### 11.1 モジュール依存関係マップ

#### 11.1.1 詳細依存関係図
```
┌─────────────────────────────────────────────────────────────┐
│                  Presentation Layer                        │
├─────────────────────────────────────────────────────────────┤
│  app.ts ──→ RequestManager ──→ VariableManager             │
│    │            │                    │                     │
│    │            ├──→ ScriptExecutor   │                     │
│    │            │      │              │                     │
│    │            └──→ HttpClient       │                     │
│    │                   │              │                     │
│    ├──→ CollectionManager ─────────────┘                   │
│    │      │                                                 │
│    │      └──→ StorageManager                               │
│    │             │                                          │
│    └──→ ScenarioManager                                     │
│              │                                              │
│              └──→ PerformanceMonitor                       │
├─────────────────────────────────────────────────────────────┤
│                 Infrastructure Layer                        │
├─────────────────────────────────────────────────────────────┤
│  Chrome Storage API │ XMLHttpRequest │ Web Crypto API      │
└─────────────────────────────────────────────────────────────┘

依存関係の制約:
1. 上位層は下位層にのみ依存
2. 同一層内のコンポーネント間は最小限の依存
3. インターフェースを通した依存関係
4. 循環依存の禁止
```

#### 11.1.2 パッケージ構造と依存関係
```typescript
interface PackageDependencyRules {
  // パッケージ依存ルール
  rules: {
    'presentation': ['application', 'domain', 'infrastructure'];
    'application': ['domain', 'infrastructure'];
    'domain': ['infrastructure'];
    'infrastructure': [];
  };
  
  // 禁止依存関係
  forbidden: {
    'infrastructure': ['domain', 'application', 'presentation'];
    'domain': ['application', 'presentation'];
    'application': ['presentation'];
  };
  
  // 依存関係検証
  validation: {
    tool: 'dependency-cruiser';
    rules: './dependency-rules.json';
    enforcement: 'CI/CD pipeline';
  };
}
```

### 11.2 デプロイメント戦略

#### 11.2.1 環境別設定管理
```typescript
interface DeploymentEnvironments {
  development: {
    features: {
      debugMode: true;
      verboseLogging: true;
      devTools: true;
      hotReload: true;
    };
    
    security: {
      scriptValidation: 'warning';
      httpsOnly: false;
      corsStrict: false;
    };
    
    performance: {
      caching: false;
      bundleOptimization: false;
      sourceMap: true;
    };
  };
  
  staging: {
    features: {
      debugMode: false;
      verboseLogging: true;
      devTools: false;
      hotReload: false;
    };
    
    security: {
      scriptValidation: 'error';
      httpsOnly: true;
      corsStrict: true;
    };
    
    performance: {
      caching: true;
      bundleOptimization: true;
      sourceMap: false;
    };
  };
  
  production: {
    features: {
      debugMode: false;
      verboseLogging: false;
      devTools: false;
      hotReload: false;
    };
    
    security: {
      scriptValidation: 'error';
      httpsOnly: true;
      corsStrict: true;
    };
    
    performance: {
      caching: true;
      bundleOptimization: true;
      sourceMap: false;
    };
  };
}
```

#### 11.2.2 継続的デプロイメント設計
```typescript
interface ContinuousDeployment {
  // ビルドパイプライン
  buildPipeline: {
    steps: [
      'dependency-check',
      'static-analysis',
      'unit-tests',
      'integration-tests',
      'security-scan',
      'bundle-optimization',
      'e2e-tests',
      'performance-tests',
      'package-signing'
    ];
    
    qualityGates: {
      testCoverage: '80%';
      securityScore: 'A';
      performanceScore: '90+';
      accessibilityScore: '95+';
    };
  };
  
  // デプロイメント戦略
  deploymentStrategy: {
    blueGreen: {
      description: '本番環境の無停止デプロイ';
      rollbackTime: '< 5分';
      healthCheck: '自動ヘルスチェック';
    };
    
    canaryRelease: {
      description: '段階的リリース';
      userPercentage: '5% → 25% → 100%';
      monitoringPeriod: '24時間';
    };
  };
  
  // 監視とアラート
  monitoring: {
    metrics: [
      'deployment-success-rate',
      'rollback-frequency',
      'deployment-duration',
      'user-error-rate-post-deploy'
    ];
    
    alerts: {
      deploymentFailure: 'Slack + Email';
      performanceDegradation: 'Auto-rollback';
      securityIncident: 'Immediate escalation';
    };
  };
}
```

---

## 12. まとめ

### 12.1 設計原則の実現

本構造設計文書では、以下の設計原則を実現しています：

#### 11.1.1 モジュラー設計
- **単一責任の原則**: 各コンポーネントは明確に定義された単一の責任を持つ
- **依存性の逆転**: 高レベルモジュールは低レベルモジュールの抽象に依存
- **オープン・クローズド原則**: 拡張に対してオープン、修正に対してクローズド

#### 11.1.2 スケーラビリティ
- **水平スケーリング**: コンポーネントの並列実行と分散処理
- **垂直スケーリング**: リソース効率的な実装とメモリ管理
- **機能拡張性**: 新機能の追加が既存システムに影響を与えない設計

#### 11.1.3 保守性
- **明確な責任分離**: レイヤー間の明確な境界と責任
- **テスタビリティ**: 各コンポーネントの独立したテストが可能
- **ドキュメント化**: 包括的な設計文書と実装ガイド

### 11.2 技術的成果

#### 11.2.1 アーキテクチャの確立
- 4層アーキテクチャ（プレゼンテーション、アプリケーション、ドメイン、インフラストラクチャ）
- Chrome Extension 特有の制約に最適化された設計
- セキュリティを最優先とした多層防御アーキテクチャ

#### 11.2.2 パフォーマンス最適化
- メモリ効率的なオブジェクト管理
- 非同期処理とバッチ処理の効果的な活用
- ネットワーク通信の最適化とキャッシュ戦略

#### 11.2.3 運用品質
- 包括的な監視・ログシステム
- 自動復旧機能とエラーハンドリング
- データ整合性とバックアップ・復旧機能

### 12.3 今後の展開

#### 12.3.1 実装フェーズ
1. **コアコンポーネント実装** (Phase 1)
   - StorageManager, RequestManager, VariableManager
   - 基本的なHTTP通信機能
   - 基本UI実装

2. **高度な機能実装** (Phase 2)
   - ScriptExecutor, CollectionManager, ScenarioManager
   - セキュリティ機能（暗号化、サンドボックス）
   - パフォーマンス最適化機能

3. **統合・テスト** (Phase 3)
   - システム統合テスト
   - パフォーマンステスト
   - セキュリティテスト

#### 12.3.2 継続的改善
- **監視データの活用**: 実際の使用データに基づく最適化
- **ユーザーフィードバック反映**: UX改善とフィーチャー追加
- **技術トレンド対応**: 新しい技術スタックの導入検討

---

## 13. 構造設計レビュー結果

### 13.1 チェックリスト準拠確認

#### 13.1.1 アーキテクチャ設計の妥当性
✅ **システム全体の可視化**: 4層アーキテクチャによる明確な責任分離  
✅ **コンポーネント依存関係**: DIパターンによる疎結合設計  
✅ **モジュール分割**: 高凝集・低結合の原則に準拠  
✅ **インターフェース定義**: 型安全なAPI設計と契約の明確化  

#### 13.1.2 品質特性の実現
✅ **テスタビリティ**: モック化対応設計、依存性注入、テストビルダーパターン  
✅ **保守性**: 明確なレイヤー分離、標準化されたコーディング規約  
✅ **拡張性**: プラグイン対応アーキテクチャ、設定駆動型設計  
✅ **セキュリティ**: 多層防御、暗号化、サンドボックス化  

#### 13.1.3 非機能要件の設計反映
✅ **パフォーマンス**: メモリ最適化、キャッシュ戦略、仮想スクロール  
✅ **可用性**: 自動復旧機能、エラーハンドリング、フォールバック  
✅ **運用性**: 監視ポイント、ログ設計、アラート機能  
✅ **Chrome拡張制約**: Manifest V3準拠、ストレージ制限対応  

### 13.2 設計品質評価

#### 13.2.1 要件トレーサビリティ
✅ **要件カバレッジ**: 全機能要件に対応する構造設計要素を特定  
✅ **非機能要件反映**: 性能・セキュリティ・可用性要件の設計への落とし込み  
✅ **UI設計整合性**: UI基本設計との一貫性確保  
✅ **実装優先度**: ビジネス価値に基づく実装順序の明確化  

#### 13.2.2 技術的妥当性
✅ **アーキテクチャパターン**: 実績ある設計パターンの適用  
✅ **技術選択**: Chrome拡張機能環境に適した技術スタック  
✅ **スケーラビリティ**: 将来の機能拡張に対応可能な設計  
✅ **互換性**: ブラウザ・OS環境への適切な対応  

### 13.3 実装準備度

#### 13.3.1 開発チーム支援
✅ **実装ガイドライン**: 詳細なコーディング標準と品質基準  
✅ **テスト戦略**: 包括的なテスト設計とツール選定  
✅ **デプロイメント**: CI/CD対応の自動化戦略  
✅ **監視・運用**: 本番運用を見据えた監視設計  

---

## 14. 更新履歴

| 日付 | バージョン | 更新内容 | レビュー担当 | 承認状況 |
|------|-----------|----------|------------|----------|
| 2025-01-10 | 1.0 | 初版作成 | Claude Code | 承認 |
| 2025-01-10 | 2.0 | 基本設計レビューチェックリスト適用 | Claude Code | 承認 |
| 2025-01-10 | 3.0 | トレーサビリティ強化・テスタビリティ設計追加・依存関係明確化 | Claude Code | 承認 |
| 2025-01-11 | 4.0 | 実装状況反映・新機能統合・モジュール構造実装対応 | Claude Code | 承認 |

---

**この構造設計文書は、PostPro API Tester Chrome拡張機能の技術的基盤を定義し、効率的で保守性の高い、セキュアなシステム構築を実現するための詳細な設計指針です。チェックリストに基づく品質保証、要件トレーサビリティの確保、テスタビリティ設計の強化により、実装チームが高品質なソフトウェアを開発するための確固たる基盤を提供しています。**