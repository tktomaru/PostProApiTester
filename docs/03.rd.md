# 要件定義文書：PostPro API Tester Chrome 拡張

## 1. 文書概要

### 1.1 文書の目的
本要件定義文書は、要求定義文書に基づいて、PostPro API Tester Chrome拡張機能の実装要件を技術的観点から詳細に定義するものです。開発チームが実装作業を進めるための具体的な仕様と実装指針を提供します。

### 1.2 文書の範囲
- 機能要件の技術仕様
- システムアーキテクチャ要件
- 実装制約と技術選択
- 品質要件と評価基準
- 開発・運用要件

### 1.3 参照文書
- システム企画書（docs/1.sp.md）
- 要求定義文書（docs/2.sa.md）
- プロジェクト構成ファイル（CLAUDE.md）

---

## 2. システムアーキテクチャ要件

### 2.1 全体アーキテクチャ

#### AR-001: Chrome拡張機能アーキテクチャ
**要件ID**: AR-001
**概要**: Manifest V3準拠のアーキテクチャ設計

**技術仕様**:
```typescript
// Chrome拡張機能構成
- Service Worker (background.ts)
- Content Script (content.ts)
- Injected Script (injected.ts)
- Popup UI (index.html + app.ts)
```

**実装要件**:
- Service Workerによるバックグラウンド処理
- Content Scriptによる Webページとの連携
- Popup UIによるメインインターフェース
- Message Passingによるコンポーネント間通信

#### AR-002: モジュラー設計
**要件ID**: AR-002
**概要**: 機能別モジュール分割による保守性確保

**モジュール構成**:
```typescript
// Core Modules
- app.ts: アプリケーションメインロジック
- state.ts: グローバル状態管理
- types.ts: TypeScript型定義

// Feature Modules
- requestManager.ts: リクエスト送信・処理
- collectionManager.ts: コレクション管理
- scenarioManager.ts: シナリオ実行
- variableManager.ts: 変数管理
- historyManager.ts: 履歴管理
- interceptorManager.ts: リクエストインターセプト

// Support Modules
- utils.ts: ユーティリティ関数
- settings.ts: 設定管理
- importExport.ts: データ交換
- postmanTestAPI.ts: Postman互換API
```

### 2.2 データアーキテクチャ

#### AR-003: データ永続化設計
**要件ID**: AR-003
**概要**: Chrome Storage APIによるデータ管理

**ストレージ設計**:
```typescript
interface AppState {
  collections: Collection[];
  environments: Environment[];
  globalVariables: Variables;
  currentEnvironment: string;
  settings: AppSettings;
  history: RequestHistory[];
}

interface Collection {
  id: string;
  name: string;
  description: string;
  variables: Variables;
  requests: Request[];
  folders: Folder[];
}

interface Request {
  id: string;
  name: string;
  method: HttpMethod;
  url: string;
  headers: HeaderMap;
  params: ParamMap;
  body: RequestBody;
  auth: AuthConfig;
  preRequestScript: string;
  testScript: string;
}
```

#### AR-004: 状態管理設計
**要件ID**: AR-004
**概要**: リアクティブ状態管理システム

**実装要件**:
- 中央集権的状態管理（state.ts）
- 状態変更の自動永続化
- コンポーネント間のデータ同期
- 状態変更の履歴管理

---

## 3. 機能実装要件

### 3.1 リクエスト処理機能

#### RQ-001: HTTPリクエスト送信実装
**要件ID**: RQ-001
**実装モジュール**: requestManager.ts

**技術仕様**:
```typescript
class RequestManager {
  async sendRequest(request: Request): Promise<Response> {
    // 1. Pre-requestスクリプト実行
    await this.executePreRequestScript(request);
    
    // 2. 変数置換処理
    const processedRequest = this.processVariables(request);
    
    // 3. HTTPリクエスト送信
    const response = await this.executeHttpRequest(processedRequest);
    
    // 4. テストスクリプト実行
    const testResults = await this.executeTestScript(request, response);
    
    // 5. 履歴保存
    await this.saveToHistory(request, response, testResults);
    
    return response;
  }
}
```

**実装制約**:
- XMLHttpRequestまたはfetch APIを使用
- CORS制約への対応
- タイムアウト処理の実装
- エラーハンドリングの統一

#### RQ-002: 認証機能実装
**要件ID**: RQ-002
**実装モジュール**: requestManager.ts

**認証実装**:
```typescript
interface AuthConfig {
  type: 'none' | 'basic' | 'bearer' | 'apikey' | 'oauth2';
  basic?: { username: string; password: string; };
  bearer?: { token: string; };
  apikey?: { key: string; value: string; in: 'header' | 'query'; };
  oauth2?: OAuth2Config;
}

class AuthManager {
  applyAuth(headers: HeaderMap, params: ParamMap, auth: AuthConfig): void {
    switch (auth.type) {
      case 'basic':
        headers['Authorization'] = `Basic ${btoa(`${auth.basic.username}:${auth.basic.password}`)}`;
        break;
      case 'bearer':
        headers['Authorization'] = `Bearer ${auth.bearer.token}`;
        break;
      case 'apikey':
        if (auth.apikey.in === 'header') {
          headers[auth.apikey.key] = auth.apikey.value;
        } else {
          params[auth.apikey.key] = auth.apikey.value;
        }
        break;
    }
  }
}
```

### 3.2 スクリプト実行機能

#### SC-001: Pre-requestスクリプト実装
**要件ID**: SC-001
**実装モジュール**: requestManager.ts

**実行環境実装**:
```typescript
class ScriptExecutor {
  private createSandbox(variables: Variables): any {
    return {
      pm: {
        globals: {
          set: (key: string, value: any) => this.setGlobalVariable(key, value),
          get: (key: string) => this.getGlobalVariable(key),
        },
        environment: {
          set: (key: string, value: any) => this.setEnvironmentVariable(key, value),
          get: (key: string) => this.getEnvironmentVariable(key),
        },
        collectionVariables: {
          set: (key: string, value: any) => this.setCollectionVariable(key, value),
          get: (key: string) => this.getCollectionVariable(key),
        },
        request: {
          url: this.currentRequest.url,
          method: this.currentRequest.method,
        }
      },
      console: {
        log: (...args) => this.logger.log('PreRequest', ...args),
      }
    };
  }
  
  async executeScript(script: string, timeout: number = 10000): Promise<void> {
    const sandbox = this.createSandbox(this.currentVariables);
    
    // セキュアな実行環境での実行
    const wrappedScript = `
      (function() {
        'use strict';
        ${script}
      })();
    `;
    
    const timeoutPromise = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Script timeout')), timeout)
    );
    
    await Promise.race([
      this.executeInSandbox(wrappedScript, sandbox),
      timeoutPromise
    ]);
  }
}
```

#### SC-002: テストスクリプト実装
**要件ID**: SC-002
**実装モジュール**: postmanTestAPI.ts

**Postman互換API実装**:
```typescript
class PostmanTestAPI {
  constructor(private response: Response, private logger: Logger) {}
  
  test(description: string, testFunction: () => void): void {
    try {
      testFunction();
      this.logger.success(`✓ ${description}`);
    } catch (error) {
      this.logger.error(`✗ ${description}: ${error.message}`);
      throw error;
    }
  }
  
  expect(actual: any): ExpectChain {
    return new ExpectChain(actual);
  }
  
  get response() {
    return {
      to: {
        have: {
          status: (expected: number) => this.expect(this.response.status).to.equal(expected),
          header: (name: string) => this.response.headers.has(name),
          body: () => this.response.body,
          jsonBody: () => JSON.parse(this.response.body),
        }
      },
      responseTime: this.response.responseTime,
      code: this.response.status,
      status: this.response.statusText,
      headers: this.response.headers,
      text: this.response.body,
      json: () => JSON.parse(this.response.body),
    };
  }
}

class ExpectChain {
  constructor(private actual: any) {}
  
  get to() {
    return {
      equal: (expected: any) => this.assertEqual(expected),
      include: (expected: any) => this.assertIncludes(expected),
      match: (pattern: RegExp) => this.assertMatch(pattern),
      be: {
        a: (type: string) => this.assertType(type),
        above: (value: number) => this.assertAbove(value),
        below: (value: number) => this.assertBelow(value),
      }
    };
  }
  
  private assertEqual(expected: any): void {
    if (this.actual !== expected) {
      throw new Error(`Expected ${expected}, but got ${this.actual}`);
    }
  }
}
```

### 3.3 変数管理機能

#### VM-001: 変数システム実装
**要件ID**: VM-001
**実装モジュール**: variableManager.ts

**変数管理実装**:
```typescript
class VariableManager {
  private globalVariables: Variables = {};
  private environmentVariables: Variables = {};
  private collectionVariables: Variables = {};
  
  resolveVariable(key: string): any {
    // 優先順位: Collection > Environment > Global
    return this.collectionVariables[key] 
        ?? this.environmentVariables[key] 
        ?? this.globalVariables[key];
  }
  
  processString(input: string): string {
    return input.replace(/\{\{([^}]+)\}\}/g, (match, varName) => {
      const value = this.resolveVariable(varName.trim());
      return value !== undefined ? String(value) : match;
    });
  }
  
  processRequest(request: Request): Request {
    const processed = { ...request };
    
    // URL変数置換
    processed.url = this.processString(request.url);
    
    // ヘッダー変数置換
    processed.headers = Object.fromEntries(
      Object.entries(request.headers).map(([key, value]) => [
        this.processString(key),
        this.processString(value)
      ])
    );
    
    // パラメータ変数置換
    processed.params = Object.fromEntries(
      Object.entries(request.params).map(([key, value]) => [
        this.processString(key),
        this.processString(value)
      ])
    );
    
    // ボディ変数置換
    if (typeof request.body.data === 'string') {
      processed.body.data = this.processString(request.body.data);
    }
    
    return processed;
  }
}
```

### 3.4 コレクション・シナリオ機能

#### CM-001: コレクション管理実装
**要件ID**: CM-001
**実装モジュール**: collectionManager.ts

**コレクション実装**:
```typescript
class CollectionManager {
  async createCollection(name: string, description: string): Promise<Collection> {
    const collection: Collection = {
      id: generateUuid(),
      name,
      description,
      variables: {},
      requests: [],
      folders: [],
    };
    
    await this.saveCollection(collection);
    return collection;
  }
  
  async runCollection(collectionId: string, environment?: string): Promise<CollectionRunResult> {
    const collection = await this.getCollection(collectionId);
    const results: RequestResult[] = [];
    
    for (const request of collection.requests) {
      try {
        const result = await this.requestManager.sendRequest(request);
        results.push({ request, response: result, status: 'success' });
      } catch (error) {
        results.push({ request, error, status: 'error' });
        // エラー時の継続/停止制御
        if (this.settings.stopOnError) break;
      }
    }
    
    return { collection, results, executedAt: new Date() };
  }
}
```

#### SM-001: シナリオ実行実装
**要件ID**: SM-001
**実装モジュール**: scenarioManager.ts

**シナリオ実装**:
```typescript
class ScenarioManager {
  async executeScenario(scenario: Scenario): Promise<ScenarioResult> {
    const context = new ExecutionContext();
    const results: StepResult[] = [];
    
    for (const step of scenario.steps) {
      const stepResult = await this.executeStep(step, context);
      results.push(stepResult);
      
      // 条件分岐処理
      if (step.conditions) {
        const shouldContinue = this.evaluateConditions(step.conditions, stepResult);
        if (!shouldContinue) break;
      }
      
      // エラーハンドリング
      if (stepResult.status === 'error' && scenario.settings.stopOnError) {
        break;
      }
    }
    
    return { scenario, results, executedAt: new Date() };
  }
  
  private async executeStep(step: ScenarioStep, context: ExecutionContext): Promise<StepResult> {
    switch (step.type) {
      case 'request':
        return await this.executeRequestStep(step, context);
      case 'delay':
        return await this.executeDelayStep(step);
      case 'script':
        return await this.executeScriptStep(step, context);
      default:
        throw new Error(`Unknown step type: ${step.type}`);
    }
  }
}
```

---

## 4. UI/UX実装要件

### 4.1 ユーザーインターフェース実装

#### UI-001: メインインターフェース実装
**要件ID**: UI-001
**実装ファイル**: app.ts, utils.ts

**UI構成実装**:
```typescript
class AppUI {
  private currentTab: 'request' | 'collections' | 'environment' | 'history' = 'request';
  
  initializeUI(): void {
    this.renderTabNavigation();
    this.renderRequestBuilder();
    this.renderCollectionSidebar();
    this.renderResponseViewer();
    this.attachEventListeners();
  }
  
  private renderRequestBuilder(): void {
    const builder = `
      <div id="request-builder">
        <div class="method-url-row">
          <select id="http-method">${this.renderMethodOptions()}</select>
          <input type="text" id="request-url" placeholder="Enter request URL">
          <button id="send-button">Send</button>
        </div>
        <div class="request-tabs">
          <div class="tab-headers">
            <button class="tab-header active" data-tab="params">Params</button>
            <button class="tab-header" data-tab="headers">Headers</button>
            <button class="tab-header" data-tab="body">Body</button>
            <button class="tab-header" data-tab="auth">Auth</button>
            <button class="tab-header" data-tab="pre-request">Pre-request</button>
            <button class="tab-header" data-tab="tests">Tests</button>
          </div>
          <div class="tab-content">
            ${this.renderTabContent()}
          </div>
        </div>
      </div>
    `;
    
    document.getElementById('main-content').innerHTML = builder;
  }
  
  private attachEventListeners(): void {
    // リクエスト送信
    document.getElementById('send-button').addEventListener('click', async () => {
      await this.sendRequest();
    });
    
    // タブ切り替え
    document.querySelectorAll('.tab-header').forEach(tab => {
      tab.addEventListener('click', (e) => {
        this.switchTab(e.target.dataset.tab);
      });
    });
    
    // キーボードショートカット
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === 'Enter') {
        this.sendRequest();
      }
    });
  }
}
```

#### UI-002: レスポンシブデザイン実装
**要件ID**: UI-002
**実装ファイル**: styles.css

**レスポンシブ実装**:
```css
/* メインレイアウト */
.app-container {
  display: grid;
  grid-template-columns: 250px 1fr;
  grid-template-rows: auto 1fr;
  height: 100vh;
  min-width: 800px;
}

/* タブレット対応 */
@media (max-width: 1024px) {
  .app-container {
    grid-template-columns: 200px 1fr;
  }
  
  .request-builder {
    padding: 10px;
  }
}

/* 小画面対応 */
@media (max-width: 768px) {
  .app-container {
    grid-template-columns: 1fr;
    grid-template-rows: auto auto 1fr;
  }
  
  .sidebar {
    order: -1;
  }
}

/* ダークモード対応 */
@media (prefers-color-scheme: dark) {
  :root {
    --bg-primary: #1a1a1a;
    --bg-secondary: #2d2d2d;
    --text-primary: #ffffff;
    --border-color: #404040;
  }
}
```

### 4.2 アクセシビリティ実装

#### AC-001: キーボードナビゲーション実装
**要件ID**: AC-001

**実装要件**:
```typescript
class AccessibilityManager {
  initializeKeyboardNavigation(): void {
    // Tab順序の管理
    this.setupTabIndex();
    
    // キーボードショートカット
    this.setupKeyboardShortcuts();
    
    // フォーカス管理
    this.setupFocusManagement();
  }
  
  private setupKeyboardShortcuts(): void {
    const shortcuts = {
      'Ctrl+Enter': () => this.sendRequest(),
      'Ctrl+N': () => this.newRequest(),
      'Ctrl+S': () => this.saveRequest(),
      'Ctrl+O': () => this.openCollection(),
      'F1': () => this.showHelp(),
    };
    
    document.addEventListener('keydown', (e) => {
      const shortcut = this.getShortcutKey(e);
      if (shortcuts[shortcut]) {
        e.preventDefault();
        shortcuts[shortcut]();
      }
    });
  }
}
```

---

## 5. 品質要件

### 5.1 テスト要件

#### QA-001: 単体テスト実装
**要件ID**: QA-001
**実装ディレクトリ**: tests/unit/

**テスト構成**:
```typescript
// tests/unit/requestManager.test.ts
describe('RequestManager', () => {
  let requestManager: RequestManager;
  
  beforeEach(() => {
    requestManager = new RequestManager();
  });
  
  describe('sendRequest', () => {
    it('should send GET request successfully', async () => {
      const request: Request = {
        method: 'GET',
        url: 'https://api.example.com/users',
        headers: {},
        params: {},
        body: { mode: 'none', data: null }
      };
      
      const response = await requestManager.sendRequest(request);
      expect(response.status).toBe(200);
    });
    
    it('should handle authentication correctly', async () => {
      const request: Request = {
        method: 'GET',
        url: 'https://api.example.com/protected',
        auth: {
          type: 'bearer',
          bearer: { token: 'test-token' }
        }
      };
      
      const response = await requestManager.sendRequest(request);
      expect(response.request.headers['Authorization']).toBe('Bearer test-token');
    });
  });
});

// tests/unit/variableManager.test.ts
describe('VariableManager', () => {
  let variableManager: VariableManager;
  
  beforeEach(() => {
    variableManager = new VariableManager();
  });
  
  describe('variable resolution', () => {
    it('should resolve variables with correct priority', () => {
      variableManager.setGlobalVariable('baseUrl', 'https://global.com');
      variableManager.setEnvironmentVariable('baseUrl', 'https://env.com');
      variableManager.setCollectionVariable('baseUrl', 'https://collection.com');
      
      const resolved = variableManager.resolveVariable('baseUrl');
      expect(resolved).toBe('https://collection.com');
    });
    
    it('should process string with multiple variables', () => {
      variableManager.setGlobalVariable('protocol', 'https');
      variableManager.setGlobalVariable('domain', 'api.example.com');
      
      const input = '{{protocol}}://{{domain}}/users';
      const output = variableManager.processString(input);
      expect(output).toBe('https://api.example.com/users');
    });
  });
});
```

#### QA-002: 統合テスト実装
**要件ID**: QA-002
**実装ファイル**: tests/extension-simplified.test.ts

**統合テスト実装**:
```typescript
// Puppeteer統合テスト
describe('Chrome Extension Integration', () => {
  let browser: Browser;
  let extensionPage: Page;
  
  beforeAll(async () => {
    browser = await puppeteer.launch({
      headless: false,
      args: [
        '--disable-extensions-except=./dist',
        '--load-extension=./dist'
      ]
    });
  });
  
  afterAll(async () => {
    await browser.close();
  });
  
  beforeEach(async () => {
    extensionPage = await browser.newPage();
    await extensionPage.goto('chrome-extension://extension-id/index.html');
  });
  
  it('should load extension successfully', async () => {
    await extensionPage.waitForSelector('#app');
    const title = await extensionPage.title();
    expect(title).toBe('PostPro API Tester');
  });
  
  it('should send request and display response', async () => {
    // リクエスト設定
    await extensionPage.select('#http-method', 'GET');
    await extensionPage.type('#request-url', 'https://reply.tukutano.jp/test');
    
    // リクエスト送信
    await extensionPage.click('#send-button');
    
    // レスポンス確認
    await extensionPage.waitForSelector('#response-body');
    const responseText = await extensionPage.$eval('#response-body', el => el.textContent);
    expect(responseText).toContain('method');
  });
});
```

### 5.2 性能要件

#### PF-001: 性能計測実装
**要件ID**: PF-001

**性能計測実装**:
```typescript
class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map();
  
  startTimer(operation: string): string {
    const timerId = `${operation}_${Date.now()}`;
    performance.mark(`${timerId}_start`);
    return timerId;
  }
  
  endTimer(timerId: string): number {
    performance.mark(`${timerId}_end`);
    performance.measure(timerId, `${timerId}_start`, `${timerId}_end`);
    
    const measure = performance.getEntriesByName(timerId)[0];
    const duration = measure.duration;
    
    const operation = timerId.split('_')[0];
    if (!this.metrics.has(operation)) {
      this.metrics.set(operation, []);
    }
    this.metrics.get(operation).push(duration);
    
    return duration;
  }
  
  getAverageTime(operation: string): number {
    const times = this.metrics.get(operation) || [];
    return times.reduce((sum, time) => sum + time, 0) / times.length;
  }
}

// 使用例
const monitor = new PerformanceMonitor();

async function sendRequest(request: Request): Promise<Response> {
  const timerId = monitor.startTimer('request_send');
  
  try {
    const response = await this.httpClient.send(request);
    return response;
  } finally {
    const duration = monitor.endTimer(timerId);
    if (duration > 1000) {
      console.warn(`Slow request detected: ${duration}ms`);
    }
  }
}
```

---

## 6. セキュリティ要件

### 6.1 データ保護実装

#### SE-001: 認証情報暗号化実装
**要件ID**: SE-001

**暗号化実装**:
```typescript
class SecurityManager {
  private readonly ENCRYPTION_KEY = 'postpro-api-tester-key';
  
  async encryptSensitiveData(data: any): Promise<string> {
    const key = await this.generateKey();
    const iv = crypto.getRandomValues(new Uint8Array(12));
    
    const encodedData = new TextEncoder().encode(JSON.stringify(data));
    
    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      key,
      encodedData
    );
    
    const result = {
      iv: Array.from(iv),
      data: Array.from(new Uint8Array(encrypted))
    };
    
    return btoa(JSON.stringify(result));
  }
  
  async decryptSensitiveData(encryptedData: string): Promise<any> {
    const key = await this.generateKey();
    const { iv, data } = JSON.parse(atob(encryptedData));
    
    const decrypted = await crypto.subtle.decrypt(
      { name: 'AES-GCM', iv: new Uint8Array(iv) },
      key,
      new Uint8Array(data)
    );
    
    const decryptedText = new TextDecoder().decode(decrypted);
    return JSON.parse(decryptedText);
  }
  
  private async generateKey(): Promise<CryptoKey> {
    const keyData = new TextEncoder().encode(this.ENCRYPTION_KEY);
    const hash = await crypto.subtle.digest('SHA-256', keyData);
    
    return await crypto.subtle.importKey(
      'raw',
      hash,
      { name: 'AES-GCM' },
      false,
      ['encrypt', 'decrypt']
    );
  }
}
```

### 6.2 スクリプト実行セキュリティ

#### SE-002: サンドボックス実装
**要件ID**: SE-002

**セキュアな実行環境**:
```typescript
class SecureScriptExecutor {
  private readonly ALLOWED_APIS = [
    'console.log',
    'JSON.parse',
    'JSON.stringify',
    'Date',
    'Math',
    'parseInt',
    'parseFloat'
  ];
  
  createSecureContext(variables: Variables): any {
    const sandbox = {
      // セキュアなAPI
      pm: this.createPostmanAPI(variables),
      console: { log: (...args) => this.logger.log(...args) },
      JSON: { parse: JSON.parse, stringify: JSON.stringify },
      Date,
      Math,
      
      // 危険なAPIの無効化
      eval: undefined,
      Function: undefined,
      setTimeout: undefined,
      setInterval: undefined,
      XMLHttpRequest: undefined,
      fetch: undefined,
      import: undefined,
      require: undefined,
    };
    
    return sandbox;
  }
  
  async executeScript(script: string, context: any, timeout: number = 10000): Promise<void> {
    // スクリプトの静的解析
    this.validateScript(script);
    
    // サンドボックス内での実行
    const wrappedScript = this.wrapScript(script, context);
    
    const worker = new Worker(
      URL.createObjectURL(new Blob([wrappedScript], { type: 'application/javascript' }))
    );
    
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        worker.terminate();
        reject(new Error('Script execution timeout'));
      }, timeout);
      
      worker.onmessage = (event) => {
        clearTimeout(timeoutId);
        worker.terminate();
        resolve(event.data);
      };
      
      worker.onerror = (error) => {
        clearTimeout(timeoutId);
        worker.terminate();
        reject(error);
      };
    });
  }
  
  private validateScript(script: string): void {
    // 危険なAPIの使用チェック
    const dangerousPatterns = [
      /eval\s*\(/,
      /Function\s*\(/,
      /XMLHttpRequest/,
      /fetch\s*\(/,
      /import\s*\(/,
      /require\s*\(/,
      /__proto__/,
      /constructor/,
      /prototype/
    ];
    
    for (const pattern of dangerousPatterns) {
      if (pattern.test(script)) {
        throw new Error(`Script contains dangerous code: ${pattern}`);
      }
    }
  }
}
```

---

## 7. ビルド・デプロイ要件

### 7.1 ビルドシステム要件

#### BD-001: Vite設定実装
**要件ID**: BD-001
**実装ファイル**: vite.config.ts

**ビルド設定**:
```typescript
// vite.config.ts
import { defineConfig } from 'vite';
import { resolve } from 'path';

export default defineConfig({
  build: {
    rollupOptions: {
      input: {
        popup: resolve(__dirname, 'index.html'),
        background: resolve(__dirname, 'src/background.ts'),
        content: resolve(__dirname, 'src/content.ts'),
        injected: resolve(__dirname, 'src/injected.ts'),
      },
      output: {
        entryFileNames: '[name].js',
        chunkFileNames: '[name].js',
        assetFileNames: '[name].[ext]'
      }
    },
    outDir: 'dist',
    emptyOutDir: true,
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true,
      }
    }
  },
  resolve: {
    alias: {
      '@': resolve(__dirname, 'src')
    }
  }
});
```

#### BD-002: TypeScript設定
**要件ID**: BD-002
**実装ファイル**: tsconfig.json

**TypeScript設定**:
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "declaration": true,
    "outDir": "./dist",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

### 7.2 テスト自動化要件

#### BD-003: Jest設定実装
**要件ID**: BD-003
**実装ファイル**: jest.config.js

**テスト設定**:
```javascript
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  roots: ['<rootDir>/src', '<rootDir>/tests'],
  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],
  transform: {
    '^.+\\.ts$': 'ts-jest',
  },
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/types.ts',
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
  setupFilesAfterEnv: ['<rootDir>/tests/setup.ts'],
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
};
```

---

## 8. 運用要件

### 8.1 ログ・監視要件

#### OP-001: ログシステム実装
**要件ID**: OP-001

**ログ実装**:
```typescript
enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
}

class Logger {
  private level: LogLevel = LogLevel.INFO;
  
  debug(message: string, ...args: any[]): void {
    if (this.level <= LogLevel.DEBUG) {
      console.debug(`[DEBUG] ${new Date().toISOString()} - ${message}`, ...args);
    }
  }
  
  info(message: string, ...args: any[]): void {
    if (this.level <= LogLevel.INFO) {
      console.info(`[INFO] ${new Date().toISOString()} - ${message}`, ...args);
    }
  }
  
  warn(message: string, ...args: any[]): void {
    if (this.level <= LogLevel.WARN) {
      console.warn(`[WARN] ${new Date().toISOString()} - ${message}`, ...args);
    }
  }
  
  error(message: string, error?: Error, ...args: any[]): void {
    if (this.level <= LogLevel.ERROR) {
      console.error(`[ERROR] ${new Date().toISOString()} - ${message}`, error, ...args);
      
      // エラー詳細の記録
      if (error) {
        this.recordError(message, error);
      }
    }
  }
  
  private recordError(message: string, error: Error): void {
    const errorRecord = {
      timestamp: new Date().toISOString(),
      message,
      stack: error.stack,
      userAgent: navigator.userAgent,
      url: window.location.href,
    };
    
    // ローカルストレージに保存（デバッグ用）
    const errors = JSON.parse(localStorage.getItem('error_logs') || '[]');
    errors.push(errorRecord);
    
    // 最大100件まで保持
    if (errors.length > 100) {
      errors.splice(0, errors.length - 100);
    }
    
    localStorage.setItem('error_logs', JSON.stringify(errors));
  }
}
```

### 8.2 バックアップ・復旧要件

#### OP-002: データバックアップ実装
**要件ID**: OP-002

**バックアップ実装**:
```typescript
class BackupManager {
  private readonly BACKUP_KEY = 'postpro_backup';
  private readonly MAX_BACKUPS = 10;
  
  async createBackup(): Promise<string> {
    const state = await this.stateManager.exportState();
    const backup = {
      timestamp: new Date().toISOString(),
      version: this.getAppVersion(),
      data: state,
    };
    
    const backupId = this.generateBackupId();
    await this.saveBackup(backupId, backup);
    
    // 古いバックアップの削除
    await this.cleanupOldBackups();
    
    return backupId;
  }
  
  async restoreBackup(backupId: string): Promise<void> {
    const backup = await this.loadBackup(backupId);
    if (!backup) {
      throw new Error(`Backup not found: ${backupId}`);
    }
    
    // データ整合性チェック
    this.validateBackupData(backup.data);
    
    // 現在のデータをバックアップ
    await this.createBackup();
    
    // データ復元
    await this.stateManager.importState(backup.data);
  }
  
  async getBackupList(): Promise<BackupInfo[]> {
    const backups = await chrome.storage.local.get(null);
    return Object.entries(backups)
      .filter(([key]) => key.startsWith(this.BACKUP_KEY))
      .map(([key, value]) => ({
        id: key.replace(`${this.BACKUP_KEY}_`, ''),
        timestamp: value.timestamp,
        version: value.version,
        size: JSON.stringify(value).length,
      }))
      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
  }
  
  private async cleanupOldBackups(): Promise<void> {
    const backups = await this.getBackupList();
    if (backups.length > this.MAX_BACKUPS) {
      const toDelete = backups.slice(this.MAX_BACKUPS);
      for (const backup of toDelete) {
        await chrome.storage.local.remove(`${this.BACKUP_KEY}_${backup.id}`);
      }
    }
  }
}
```

---

## 9. 受入条件

### 9.1 機能受入条件

1. **リクエスト送信機能**:
   - 全てのHTTPメソッド（GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS）が正常に動作する
   - 認証方式（Basic, Bearer, API Key）が適切に設定される
   - Pre-requestスクリプトが10秒以内に実行完了する

2. **レスポンス処理機能**:
   - JSON、XML、HTMLレスポンスが適切に表示される
   - テストスクリプトが正常に実行され、結果が表示される
   - エラーレスポンスが適切にハンドリングされる

3. **変数管理機能**:
   - 3階層の変数システムが正しい優先順位で動作する
   - 変数置換が全ての入力フィールドで正常に動作する
   - 循環参照が検出され、エラーが表示される

4. **コレクション・シナリオ機能**:
   - コレクションの作成、編集、削除が正常に動作する
   - シナリオ実行が指定順序で完了する
   - エラー時の停止・継続制御が適切に動作する

### 9.2 性能受入条件

1. **起動性能**: 拡張機能の初期化が200ms以内に完了する
2. **応答性能**: UI操作からレスポンスまで100ms以内
3. **処理性能**: 1MBのレスポンスを5秒以内に表示する
4. **メモリ使用量**: 50MB以下で動作する

### 9.3 品質受入条件

1. **テストカバレッジ**: 単体テスト80%以上のカバレッジを達成
2. **統合テスト**: Puppeteerテストが全て成功する
3. **型安全性**: TypeScript厳密モードでコンパイルエラーなし
4. **セキュリティ**: 認証情報が暗号化保存される

---

## 10. 開発指針

### 10.1 コーディング規約

1. **TypeScript**: 厳密な型定義を使用し、`any`型の使用を最小限に抑える
2. **非同期処理**: `async/await`を優先し、Promise chainingは避ける
3. **エラーハンドリング**: 全ての非同期処理にtry-catch文を実装
4. **ログ**: 適切なログレベルで処理状況を記録する

### 10.2 実装優先順位

1. **Phase 1**: 基本リクエスト送信機能（FR-001, FR-002, FR-003, FR-004）
2. **Phase 2**: スクリプト実行機能（FR-005, FR-006）
3. **Phase 3**: 変数管理機能（FR-007, FR-008）
4. **Phase 4**: コレクション・シナリオ機能（FR-009, FR-010, FR-011）
5. **Phase 5**: インポート・エクスポート機能（FR-012）
6. **Phase 6**: エコーAPIテスト機能（FR-013, FR-014）

---

## 11. 付録

### 11.1 技術選択の根拠

| 技術 | 選択理由 |
|------|---------|
| TypeScript | 型安全性による品質向上、大規模開発での保守性 |
| Vite | 高速なビルド、モダンなモジュールバンドラー |
| Jest | 豊富な機能、TypeScript対応、モック機能 |
| Puppeteer | Chrome拡張機能のE2Eテスト、実ブラウザ環境 |

### 11.2 更新履歴

| 日付 | バージョン | 更新内容 | 更新者 |
|------|-----------|----------|--------|
| 2025-01-10 | 1.0 | 初版作成 | Claude Code |

---

**この要件定義文書は、PostPro API Tester Chrome拡張機能の技術実装において、開発チームが具体的な実装作業を進めるための詳細な技術仕様を定義したものです。要求定義文書と合わせて、高品質なソフトウェア開発の実現を目指してください。**