# プログラム設計文書：PostPro API Tester Chrome 拡張

## 1. 文書概要

### 1.1 文書の目的
本プログラム設計文書は、詳細設計を基に各プログラムの具体的な動作を設計するものです。各プログラムがどのように動作し、どのように処理を進めるかを詳細に設計します。各プログラムのアルゴリズム、データ処理の流れ、エラー処理などを含み、テスト時に問題が生じないよう、設計段階で細かい部分にも注意を払います。

### 1.2 文書の範囲
- 個別プログラムの詳細設計
- アルゴリズムとデータフローの定義
- エラーハンドリング戦略
- パフォーマンス最適化手法
- テスト可能性を考慮した設計

### 1.3 参照文書
- システム企画書（docs/01.sp.md）
- 要求定義文書（docs/02.sa.md）
- 要件定義文書（docs/03.rd.md）
- 基本設計文書（docs/03.bd.md）
- UI基本設計文書（docs/04.ui.md）
- 外部設計文書（docs/05.ed.md）
- 構造設計文書（docs/06.ss.md）
- プロジェクト構成ファイル（CLAUDE.md）

---

## 2. プログラムモジュール設計

### 2.1 RequestManager プログラム設計

#### 2.1.1 クラス構造と責任
```typescript
class RequestManager {
  private variableManager: VariableManager;
  private scriptExecutor: ScriptExecutor;
  private httpClient: HttpClient;
  private historyManager: HistoryManager;
  private logger: Logger;
  private performanceMonitor: PerformanceMonitor;
  
  // 状態管理
  private activeRequests: Map<string, AbortController> = new Map();
  private requestQueue: PriorityQueue<RequestTask> = new PriorityQueue();
  private readonly maxConcurrentRequests = 5;
  
  constructor(dependencies: RequestManagerDependencies) {
    this.validateDependencies(dependencies);
    this.initializeDependencies(dependencies);
    this.setupPerformanceMonitoring();
  }
}
```

#### 2.1.2 sendRequest メソッドの詳細設計
```typescript
async sendRequest(request: RequestData): Promise<RequestResult> {
  // Phase 1: 前処理とバリデーション
  const requestId = this.generateRequestId();
  const abortController = new AbortController();
  
  try {
    // 1.1 リクエストバリデーション
    this.validateRequest(request);
    
    // 1.2 同期制御（並行実行制限）
    await this.waitForSlot();
    
    // 1.3 アクティブリクエスト登録
    this.activeRequests.set(requestId, abortController);
    
    // 1.4 パフォーマンス監視開始
    const perfTimer = this.performanceMonitor.startTimer('request_execution');
    
    // Phase 2: プリリクエスト処理
    const preProcessedRequest = await this.executePreRequestPhase(
      request, 
      { requestId, abortSignal: abortController.signal }
    );
    
    // Phase 3: HTTPリクエスト実行
    const response = await this.executeHttpRequest(
      preProcessedRequest,
      { requestId, abortSignal: abortController.signal }
    );
    
    // Phase 4: ポストリクエスト処理
    const result = await this.executePostRequestPhase(
      preProcessedRequest,
      response,
      { requestId, abortSignal: abortController.signal }
    );
    
    // Phase 5: 結果処理
    return await this.finalizeRequest(
      requestId,
      preProcessedRequest,
      response,
      result,
      perfTimer
    );
    
  } catch (error) {
    return await this.handleRequestError(requestId, request, error);
  } finally {
    // リソースクリーンアップ
    this.cleanupRequest(requestId);
  }
}
```

#### 2.1.3 プリリクエスト処理の詳細
```typescript
private async executePreRequestPhase(
  request: RequestData, 
  context: RequestContext
): Promise<ProcessedRequest> {
  
  const phaseTimer = this.performanceMonitor.startTimer('pre_request_phase');
  
  try {
    // Step 1: 変数コンテキスト構築
    const variableContext = await this.buildVariableContext(request);
    
    // Step 2: プリリクエストスクリプト実行
    if (request.preRequestScript?.trim()) {
      await this.executePreRequestScript(
        request.preRequestScript,
        variableContext,
        context
      );
    }
    
    // Step 3: 変数置換処理
    const processedRequest = await this.processVariables(request, variableContext);
    
    // Step 4: リクエストデータ正規化
    const normalizedRequest = this.normalizeRequest(processedRequest);
    
    // Step 5: 認証情報処理
    const authenticatedRequest = await this.processAuthentication(normalizedRequest);
    
    return authenticatedRequest;
    
  } catch (error) {
    this.logger.error('Pre-request phase failed', error, {
      requestId: context.requestId,
      requestName: request.name
    });
    throw new PreRequestError('Pre-request processing failed', error);
  } finally {
    this.performanceMonitor.endTimer(phaseTimer);
  }
}
```

#### 2.1.4 変数置換処理のアルゴリズム
```typescript
private async processVariables(
  request: RequestData, 
  context: VariableContext
): Promise<ProcessedRequest> {
  
  const processed: ProcessedRequest = {
    ...request,
    id: this.generateProcessedRequestId(request.id)
  };
  
  // 処理順序の定義（依存関係を考慮）
  const processingOrder = [
    'url',
    'headers', 
    'params',
    'body',
    'auth'
  ];
  
  for (const field of processingOrder) {
    try {
      processed[field] = await this.processFieldVariables(
        request[field], 
        context,
        field
      );
    } catch (error) {
      this.logger.warn(`Variable processing failed for field: ${field}`, error);
      // 非致命的エラーの場合は続行
      if (!this.isCriticalField(field)) {
        processed[field] = request[field]; // 元の値を使用
      } else {
        throw new VariableProcessingError(
          `Critical field ${field} variable processing failed`, 
          error
        );
      }
    }
  }
  
  return processed;
}

private async processFieldVariables(
  fieldValue: any, 
  context: VariableContext,
  fieldName: string
): Promise<any> {
  
  if (typeof fieldValue === 'string') {
    return await this.processStringVariables(fieldValue, context);
  }
  
  if (typeof fieldValue === 'object' && fieldValue !== null) {
    return await this.processObjectVariables(fieldValue, context);
  }
  
  return fieldValue;
}

private async processStringVariables(
  text: string, 
  context: VariableContext
): Promise<string> {
  
  // 変数参照パターン: {{variableName}}
  const variablePattern = /\{\{([^}]+)\}\}/g;
  const processedText = text.replace(variablePattern, (match, varName) => {
    try {
      const trimmedName = varName.trim();
      const value = this.resolveVariable(trimmedName, context);
      
      if (value === undefined || value === null) {
        this.logger.warn(`Undefined variable: ${trimmedName}`);
        return match; // 元の参照を保持
      }
      
      return String(value);
      
    } catch (error) {
      this.logger.error(`Variable resolution failed: ${varName}`, error);
      return match; // エラー時は元の参照を保持
    }
  });
  
  return processedText;
}
```

#### 2.1.5 HTTPリクエスト実行の詳細
```typescript
private async executeHttpRequest(
  request: ProcessedRequest,
  context: RequestContext
): Promise<ResponseData> {
  
  const httpTimer = this.performanceMonitor.startTimer('http_request');
  const startTimestamp = performance.now();
  
  try {
    // Step 1: XMLHttpRequest準備
    const xhr = this.createXMLHttpRequest(request, context);
    
    // Step 2: タイムアウト設定
    const timeout = request.timeout || 30000;
    const timeoutId = setTimeout(() => {
      xhr.abort();
    }, timeout);
    
    // Step 3: リクエスト送信
    const response = await this.sendHttpRequest(xhr, request, context);
    
    // Step 4: レスポンス処理
    clearTimeout(timeoutId);
    const endTimestamp = performance.now();
    
    const processedResponse: ResponseData = {
      ...response,
      duration: endTimestamp - startTimestamp,
      timestamp: new Date().toISOString(),
      requestId: context.requestId
    };
    
    return processedResponse;
    
  } catch (error) {
    const endTimestamp = performance.now();
    
    if (error.name === 'AbortError') {
      throw new RequestTimeoutError('Request timed out', {
        duration: endTimestamp - startTimestamp,
        timeout: request.timeout || 30000
      });
    }
    
    throw new HttpRequestError('HTTP request failed', error, {
      url: request.url,
      method: request.method,
      duration: endTimestamp - startTimestamp
    });
    
  } finally {
    this.performanceMonitor.endTimer(httpTimer);
  }
}

private createXMLHttpRequest(
  request: ProcessedRequest,
  context: RequestContext
): XMLHttpRequest {
  
  const xhr = new XMLHttpRequest();
  
  // 基本設定
  xhr.open(request.method, request.url, true);
  xhr.responseType = 'blob'; // バイナリデータ対応
  
  // ヘッダー設定
  Object.entries(request.headers || {}).forEach(([name, value]) => {
    if (value && value.trim()) {
      try {
        xhr.setRequestHeader(name, value);
      } catch (error) {
        this.logger.warn(`Invalid header: ${name}`, error);
      }
    }
  });
  
  // プログレス監視
  xhr.upload.onprogress = (event) => {
    if (event.lengthComputable) {
      const progress = (event.loaded / event.total) * 100;
      this.notifyProgress(context.requestId, 'upload', progress);
    }
  };
  
  xhr.onprogress = (event) => {
    if (event.lengthComputable) {
      const progress = (event.loaded / event.total) * 100;
      this.notifyProgress(context.requestId, 'download', progress);
    }
  };
  
  // 中断シグナル監視
  context.abortSignal?.addEventListener('abort', () => {
    xhr.abort();
  });
  
  return xhr;
}
```

### 2.2 VariableManager プログラム設計

#### 2.2.1 変数解決アルゴリズム
```typescript
class VariableManager {
  private variables = {
    global: new Map<string, VariableData>(),
    environment: new Map<string, VariableData>(),
    collection: new Map<string, VariableData>(),
    runtime: new Map<string, VariableData>()
  };
  
  private builtInVariables = new Map<string, () => any>();
  private circularReferenceDetector = new CircularReferenceDetector();
  
  constructor() {
    this.initializeBuiltInVariables();
  }
  
  resolveVariable(name: string, context?: VariableContext): any {
    // Step 1: 循環参照チェック
    if (this.circularReferenceDetector.hasCircularReference(name, context)) {
      throw new CircularReferenceError(`Circular reference detected: ${name}`);
    }
    
    // Step 2: 優先順位に基づく解決
    const resolutionOrder = [
      () => this.variables.runtime.get(name),
      () => this.getCollectionVariable(name, context?.collectionId),
      () => this.getEnvironmentVariable(name, context?.environmentId),
      () => this.variables.global.get(name),
      () => this.resolveBuiltInVariable(name)
    ];
    
    for (const resolver of resolutionOrder) {
      try {
        const result = resolver();
        if (result !== undefined) {
          return this.processVariableValue(result, context);
        }
      } catch (error) {
        this.logger.warn(`Variable resolution error for ${name}`, error);
      }
    }
    
    // Step 3: 未定義変数の処理
    this.logger.warn(`Undefined variable: ${name}`);
    return undefined;
  }
}
```

#### 2.2.2 動的変数生成の詳細
```typescript
private initializeBuiltInVariables(): void {
  // タイムスタンプ系
  this.builtInVariables.set('$timestamp', () => Date.now());
  this.builtInVariables.set('$isoTimestamp', () => new Date().toISOString());
  this.builtInVariables.set('$unixTimestamp', () => Math.floor(Date.now() / 1000));
  
  // ランダム値系
  this.builtInVariables.set('$randomInt', () => Math.floor(Math.random() * 1000));
  this.builtInVariables.set('$randomFloat', () => Math.random());
  this.builtInVariables.set('$randomString', () => this.generateRandomString(10));
  this.builtInVariables.set('$randomAlphanumeric', () => this.generateAlphanumeric(8));
  
  // GUID/UUID系
  this.builtInVariables.set('$guid', () => this.generateGUID());
  this.builtInVariables.set('$uuid', () => this.generateUUID());
  
  // 日付・時刻系
  this.builtInVariables.set('$currentDate', () => new Date().toISOString().split('T')[0]);
  this.builtInVariables.set('$currentTime', () => new Date().toTimeString().split(' ')[0]);
  this.builtInVariables.set('$currentYear', () => new Date().getFullYear());
  this.builtInVariables.set('$currentMonth', () => new Date().getMonth() + 1);
  this.builtInVariables.set('$currentDay', () => new Date().getDate());
}

private generateRandomString(length: number): string {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let result = '';
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

private generateGUID(): string {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}
```

#### 2.2.3 循環参照検出アルゴリズム
```typescript
class CircularReferenceDetector {
  private resolutionStack: string[] = [];
  private maxDepth = 10;
  
  hasCircularReference(variableName: string, context?: VariableContext): boolean {
    // 現在の解決スタックをチェック
    if (this.resolutionStack.includes(variableName)) {
      return true;
    }
    
    // 最大深度チェック
    if (this.resolutionStack.length >= this.maxDepth) {
      return true;
    }
    
    return false;
  }
  
  enterResolution(variableName: string): void {
    this.resolutionStack.push(variableName);
  }
  
  exitResolution(variableName: string): void {
    const index = this.resolutionStack.lastIndexOf(variableName);
    if (index !== -1) {
      this.resolutionStack.splice(index, 1);
    }
  }
  
  getResolutionPath(): string[] {
    return [...this.resolutionStack];
  }
}
```

### 2.3 ScriptExecutor プログラム設計

#### 2.3.1 安全なスクリプト実行環境
```typescript
class ScriptExecutor {
  private sandboxPool: SandboxPool = new SandboxPool();
  private securityValidator: SecurityValidator = new SecurityValidator();
  private executionLimiter: ExecutionLimiter = new ExecutionLimiter();
  
  async executeScript(
    script: string, 
    context: ScriptContext,
    options?: ExecutionOptions
  ): Promise<ScriptResult> {
    
    // Phase 1: セキュリティ検証
    const securityResult = await this.securityValidator.validate(script);
    if (!securityResult.isValid) {
      throw new SecurityError('Script contains dangerous patterns', {
        violations: securityResult.violations
      });
    }
    
    // Phase 2: 実行環境準備
    const sandbox = await this.sandboxPool.acquire();
    const executionId = this.generateExecutionId();
    
    try {
      // Phase 3: 実行制限設定
      const limits = this.executionLimiter.createLimits(options);
      
      // Phase 4: スクリプト実行
      const result = await this.executeInSandbox(
        script, 
        context, 
        sandbox, 
        limits,
        executionId
      );
      
      return result;
      
    } catch (error) {
      return this.handleExecutionError(error, script, context, executionId);
    } finally {
      // Phase 5: リソース解放
      await this.sandboxPool.release(sandbox);
      this.executionLimiter.cleanup(executionId);
    }
  }
}
```

#### 2.3.2 Postman API エミュレーション
```typescript
class PostmanAPIEmulator {
  private testRegistry: TestRegistry = new TestRegistry();
  private expectationBuilder: ExpectationBuilder = new ExpectationBuilder();
  
  createPostmanAPI(context: ScriptContext): PostmanAPI {
    return {
      test: (name: string, testFunction: () => void) => {
        this.executeTest(name, testFunction, context);
      },
      
      expect: (actual: any) => {
        return this.expectationBuilder.create(actual);
      },
      
      response: this.createResponseObject(context.response),
      
      variables: this.createVariablesObject(context),
      
      environment: this.createEnvironmentObject(context),
      
      globals: this.createGlobalsObject(context),
      
      request: this.createRequestObject(context.request)
    };
  }
  
  private executeTest(
    name: string, 
    testFunction: () => void, 
    context: ScriptContext
  ): void {
    const testId = this.generateTestId();
    const startTime = performance.now();
    
    try {
      // テスト実行
      testFunction();
      
      // 成功結果の記録
      const result: TestResult = {
        id: testId,
        name,
        passed: true,
        duration: performance.now() - startTime,
        assertions: this.expectationBuilder.getAssertions(),
        timestamp: new Date().toISOString()
      };
      
      this.testRegistry.add(result);
      
    } catch (error) {
      // 失敗結果の記録
      const result: TestResult = {
        id: testId,
        name,
        passed: false,
        error: error.message,
        duration: performance.now() - startTime,
        assertions: this.expectationBuilder.getAssertions(),
        timestamp: new Date().toISOString()
      };
      
      this.testRegistry.add(result);
    } finally {
      this.expectationBuilder.reset();
    }
  }
}
```

#### 2.3.3 期待値検証の実装
```typescript
class ExpectationBuilder {
  private assertions: Assertion[] = [];
  
  create(actual: any): ChaiExpectCompatible {
    return {
      to: {
        equal: (expected: any) => this.assertEqual(actual, expected),
        be: {
          a: (type: string) => this.assertType(actual, type),
          above: (value: number) => this.assertGreaterThan(actual, value),
          below: (value: number) => this.assertLessThan(actual, value),
          true: () => this.assertTrue(actual),
          false: () => this.assertFalse(actual),
          null: () => this.assertNull(actual),
          undefined: () => this.assertUndefined(actual),
          ok: () => this.assertTruthy(actual)
        },
        have: {
          property: (prop: string, value?: any) => 
            this.assertProperty(actual, prop, value),
          length: (length: number) => this.assertLength(actual, length)
        },
        include: (value: any) => this.assertIncludes(actual, value),
        match: (pattern: RegExp) => this.assertMatch(actual, pattern)
      }
    };
  }
  
  private assertEqual(actual: any, expected: any): void {
    const assertion: Assertion = {
      type: 'equal',
      actual,
      expected,
      passed: this.deepEqual(actual, expected),
      message: `Expected ${JSON.stringify(actual)} to equal ${JSON.stringify(expected)}`
    };
    
    this.assertions.push(assertion);
    
    if (!assertion.passed) {
      throw new AssertionError(assertion.message);
    }
  }
  
  private deepEqual(a: any, b: any): boolean {
    if (a === b) return true;
    
    if (a == null || b == null) return a === b;
    
    if (typeof a !== typeof b) return false;
    
    if (typeof a === 'object') {
      if (Array.isArray(a) !== Array.isArray(b)) return false;
      
      const keysA = Object.keys(a);
      const keysB = Object.keys(b);
      
      if (keysA.length !== keysB.length) return false;
      
      for (const key of keysA) {
        if (!keysB.includes(key)) return false;
        if (!this.deepEqual(a[key], b[key])) return false;
      }
      
      return true;
    }
    
    return false;
  }
}
```

### 2.4 CollectionManager プログラム設計

#### 2.4.1 コレクション実行エンジン
```typescript
class CollectionExecutor {
  private collection: Collection;
  private options: RunOptions;
  private executionState: ExecutionState;
  private resultAggregator: ResultAggregator;
  
  constructor(collection: Collection, options: RunOptions) {
    this.collection = collection;
    this.options = this.normalizeOptions(options);
    this.executionState = new ExecutionState();
    this.resultAggregator = new ResultAggregator();
  }
  
  async run(): Promise<CollectionRunResult> {
    const executionId = this.generateExecutionId();
    const startTime = performance.now();
    
    try {
      // Phase 1: 実行計画作成
      const executionPlan = await this.createExecutionPlan();
      
      // Phase 2: 前処理
      await this.executePreCollectionScript();
      
      // Phase 3: リクエスト順次実行
      const results = await this.executeRequests(executionPlan);
      
      // Phase 4: 後処理
      await this.executePostCollectionScript();
      
      // Phase 5: 結果集計
      return this.resultAggregator.aggregate({
        executionId,
        collection: this.collection,
        results,
        duration: performance.now() - startTime,
        options: this.options
      });
      
    } catch (error) {
      return this.handleCollectionError(error, executionId, startTime);
    }
  }
  
  private async executeRequests(plan: ExecutionPlan): Promise<RequestResult[]> {
    const results: RequestResult[] = [];
    
    for (const step of plan.steps) {
      try {
        // Step実行前の条件チェック
        if (!this.shouldExecuteStep(step)) {
          continue;
        }
        
        // 遅延処理
        if (step.delay > 0) {
          await this.delay(step.delay);
        }
        
        // リクエスト実行
        const result = await this.executeStep(step);
        results.push(result);
        
        // 実行状態更新
        this.executionState.update(step, result);
        
        // 失敗時の処理
        if (!result.success && this.options.stopOnFailure) {
          break;
        }
        
      } catch (error) {
        const errorResult = this.createErrorResult(step, error);
        results.push(errorResult);
        
        if (this.options.stopOnFailure) {
          break;
        }
      }
    }
    
    return results;
  }
}
```

#### 2.4.2 依存関係解決アルゴリズム
```typescript
class DependencyResolver {
  
  resolveDependencies(requests: RequestData[]): ExecutionOrder {
    // グラフ構築
    const graph = this.buildDependencyGraph(requests);
    
    // 循環依存チェック
    this.validateNoCycles(graph);
    
    // トポロジカルソート
    const sortedOrder = this.topologicalSort(graph);
    
    return {
      order: sortedOrder,
      batches: this.createParallelBatches(sortedOrder, graph)
    };
  }
  
  private buildDependencyGraph(requests: RequestData[]): DependencyGraph {
    const graph = new Map<string, GraphNode>();
    
    // ノード作成
    requests.forEach(request => {
      graph.set(request.id, {
        id: request.id,
        request,
        dependencies: new Set(),
        dependents: new Set()
      });
    });
    
    // 依存関係構築
    requests.forEach(request => {
      const dependencies = this.extractDependencies(request);
      const node = graph.get(request.id)!;
      
      dependencies.forEach(depId => {
        if (graph.has(depId)) {
          node.dependencies.add(depId);
          graph.get(depId)!.dependents.add(request.id);
        }
      });
    });
    
    return graph;
  }
  
  private extractDependencies(request: RequestData): string[] {
    const dependencies: string[] = [];
    
    // スクリプト内の依存関係を解析
    const scriptContent = `${request.preRequestScript} ${request.testScript}`;
    
    // pm.variables.set() の後に pm.variables.get() で参照されるパターン
    const setMatches = scriptContent.match(/pm\.variables\.set\(['"]([^'"]+)['"]/g);
    const getMatches = scriptContent.match(/pm\.variables\.get\(['"]([^'"]+)['"]/g);
    
    // 変数参照の解析
    const variableRefs = scriptContent.match(/\{\{([^}]+)\}\}/g);
    if (variableRefs) {
      variableRefs.forEach(ref => {
        const varName = ref.slice(2, -2).trim();
        // この変数がどのリクエストで設定されるかを特定
        const sourceRequest = this.findVariableSource(varName);
        if (sourceRequest) {
          dependencies.push(sourceRequest);
        }
      });
    }
    
    return dependencies;
  }
  
  private topologicalSort(graph: DependencyGraph): string[] {
    const result: string[] = [];
    const visited = new Set<string>();
    const visiting = new Set<string>();
    
    const visit = (nodeId: string): void => {
      if (visiting.has(nodeId)) {
        throw new CircularDependencyError(`Circular dependency detected involving ${nodeId}`);
      }
      
      if (visited.has(nodeId)) {
        return;
      }
      
      visiting.add(nodeId);
      
      const node = graph.get(nodeId)!;
      node.dependencies.forEach(depId => {
        visit(depId);
      });
      
      visiting.delete(nodeId);
      visited.add(nodeId);
      result.push(nodeId);
    };
    
    graph.forEach((node, nodeId) => {
      if (!visited.has(nodeId)) {
        visit(nodeId);
      }
    });
    
    return result;
  }
}
```

### 2.5 HttpClient プログラム設計

#### 2.5.1 高パフォーマンスHTTPクライアント
```typescript
class HttpClient {
  private connectionPool: ConnectionPool = new ConnectionPool();
  private requestInterceptors: RequestInterceptor[] = [];
  private responseInterceptors: ResponseInterceptor[] = [];
  private retryHandler: RetryHandler = new RetryHandler();
  
  async send(request: ProcessedRequest): Promise<ResponseData> {
    const requestId = this.generateRequestId();
    const startTime = performance.now();
    
    try {
      // Phase 1: インターセプター適用
      const interceptedRequest = await this.applyRequestInterceptors(request);
      
      // Phase 2: 接続取得
      const connection = await this.connectionPool.acquire(interceptedRequest.url);
      
      // Phase 3: リクエスト送信
      const rawResponse = await this.sendRawRequest(interceptedRequest, connection);
      
      // Phase 4: レスポンス処理
      const processedResponse = await this.processResponse(rawResponse, startTime);
      
      // Phase 5: レスポンスインターセプター適用
      return await this.applyResponseInterceptors(processedResponse);
      
    } catch (error) {
      // リトライ判定
      if (this.retryHandler.shouldRetry(error, request)) {
        return await this.retryHandler.retry(request, this.send.bind(this));
      }
      
      throw this.createHttpError(error, request, performance.now() - startTime);
    }
  }
  
  private async sendRawRequest(
    request: ProcessedRequest, 
    connection: Connection
  ): Promise<RawResponse> {
    
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      
      // 基本設定
      xhr.open(request.method, request.url, true);
      xhr.responseType = 'blob';
      xhr.timeout = request.timeout || 30000;
      
      // イベントリスナー設定
      xhr.onload = () => {
        resolve(this.createRawResponse(xhr));
      };
      
      xhr.onerror = () => {
        reject(new NetworkError('Network request failed'));
      };
      
      xhr.ontimeout = () => {
        reject(new TimeoutError('Request timeout'));
      };
      
      xhr.onabort = () => {
        reject(new AbortError('Request aborted'));
      };
      
      // プログレス監視
      xhr.upload.onprogress = (event) => {
        this.notifyProgress(request.id, 'upload', event);
      };
      
      xhr.onprogress = (event) => {
        this.notifyProgress(request.id, 'download', event);
      };
      
      // ヘッダー設定
      this.setRequestHeaders(xhr, request);
      
      // ボディ準備
      const body = this.prepareRequestBody(request);
      
      // 送信
      xhr.send(body);
    });
  }
}
```

#### 2.5.2 接続プールの実装
```typescript
class ConnectionPool {
  private pools = new Map<string, Connection[]>();
  private activeConnections = new Map<string, number>();
  private readonly maxConnections = 6; // HTTP/1.1 standard
  private readonly maxConnectionsPerHost = 2;
  
  async acquire(url: string): Promise<Connection> {
    const hostname = this.extractHostname(url);
    
    // 接続数制限チェック
    await this.waitForAvailableSlot(hostname);
    
    // 既存接続の再利用
    const reusableConnection = this.findReusableConnection(hostname);
    if (reusableConnection) {
      return reusableConnection;
    }
    
    // 新規接続作成
    return this.createNewConnection(hostname);
  }
  
  release(connection: Connection): void {
    const hostname = connection.hostname;
    
    // Keep-Alive対応
    if (connection.isKeepAlive && !connection.isExpired()) {
      this.addToPool(hostname, connection);
    } else {
      connection.close();
    }
    
    // アクティブ接続数を減少
    const current = this.activeConnections.get(hostname) || 0;
    this.activeConnections.set(hostname, Math.max(0, current - 1));
  }
  
  private async waitForAvailableSlot(hostname: string): Promise<void> {
    const maxRetries = 10;
    const retryDelay = 100;
    
    for (let i = 0; i < maxRetries; i++) {
      const activeCount = this.activeConnections.get(hostname) || 0;
      
      if (activeCount < this.maxConnectionsPerHost) {
        this.activeConnections.set(hostname, activeCount + 1);
        return;
      }
      
      // 少し待ってリトライ
      await this.delay(retryDelay * (i + 1));
    }
    
    throw new ConnectionPoolError(`Connection pool exhausted for ${hostname}`);
  }
}
```

#### 2.5.3 自動リトライ機能
```typescript
class RetryHandler {
  private readonly maxRetries = 3;
  private readonly retryDelays = [1000, 2000, 4000]; // Exponential backoff
  
  shouldRetry(error: Error, request: ProcessedRequest): boolean {
    // リトライ可能エラーの判定
    const retryableErrors = [
      'NetworkError',
      'TimeoutError',
      'ConnectionResetError',
      'DNSError'
    ];
    
    if (!retryableErrors.includes(error.constructor.name)) {
      return false;
    }
    
    // HTTPステータスによる判定
    if (error instanceof HttpResponseError) {
      const retryableStatuses = [408, 429, 500, 502, 503, 504];
      return retryableStatuses.includes(error.status);
    }
    
    return true;
  }
  
  async retry<T>(
    request: ProcessedRequest,
    sendFunction: (request: ProcessedRequest) => Promise<T>
  ): Promise<T> {
    
    let lastError: Error;
    
    for (let attempt = 0; attempt < this.maxRetries; attempt++) {
      try {
        // 遅延実行
        if (attempt > 0) {
          const delay = this.retryDelays[attempt - 1] || 4000;
          await this.delay(delay);
        }
        
        // リクエスト再実行
        const result = await sendFunction(request);
        
        // 成功した場合は結果を返す
        return result;
        
      } catch (error) {
        lastError = error;
        
        // 最終試行の場合は例外を投げる
        if (attempt === this.maxRetries - 1) {
          throw new MaxRetriesExceededError(
            `Request failed after ${this.maxRetries} attempts`,
            lastError
          );
        }
        
        // リトライ判定（動的）
        if (!this.shouldRetry(error, request)) {
          throw error;
        }
      }
    }
    
    throw lastError!;
  }
  
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### 2.6 StateManager プログラム設計

#### 2.6.1 状態管理とリアクティブ更新
```typescript
class StateManager {
  private state: AppState;
  private subscribers = new Map<string, Set<StateSubscriber>>();
  private stateHistory: StateSnapshot[] = [];
  private readonly maxHistorySize = 50;
  private saveDebouncer: Debouncer = new Debouncer(500);
  
  constructor() {
    this.state = this.createInitialState();
    this.setupAutoPersistence();
  }
  
  async loadState(): Promise<void> {
    try {
      const storedState = await this.storageManager.get('appState');
      if (storedState) {
        this.state = this.migrateState(storedState);
      } else {
        this.state = this.createInitialState();
      }
      
      this.notifySubscribers('*', this.state);
      
    } catch (error) {
      this.logger.error('Failed to load state', error);
      this.state = this.createInitialState();
    }
  }
  
  setState(path: string, value: any): void {
    // State snapshot for undo functionality
    this.createSnapshot();
    
    // Update state
    const oldValue = this.getNestedValue(this.state, path);
    this.setNestedValue(this.state, path, value);
    
    // Validate state integrity
    this.validateState();
    
    // Notify subscribers
    this.notifySubscribers(path, value, oldValue);
    
    // Trigger persistent save
    this.scheduleStateSave();
  }
  
  subscribe(path: string, callback: StateSubscriber): UnsubscribeFunction {
    if (!this.subscribers.has(path)) {
      this.subscribers.set(path, new Set());
    }
    
    this.subscribers.get(path)!.add(callback);
    
    // Return unsubscribe function
    return () => {
      this.subscribers.get(path)?.delete(callback);
    };
  }
  
  private notifySubscribers(path: string, newValue: any, oldValue?: any): void {
    // 特定パスのサブスクライバーに通知
    const pathSubscribers = this.subscribers.get(path);
    if (pathSubscribers) {
      pathSubscribers.forEach(subscriber => {
        try {
          subscriber({ path, newValue, oldValue, state: this.state });
        } catch (error) {
          this.logger.error('State subscriber error', error);
        }
      });
    }
    
    // ワイルドカードサブスクライバーに通知
    const wildcardSubscribers = this.subscribers.get('*');
    if (wildcardSubscribers) {
      wildcardSubscribers.forEach(subscriber => {
        try {
          subscriber({ path, newValue, oldValue, state: this.state });
        } catch (error) {
          this.logger.error('Wildcard subscriber error', error);
        }
      });
    }
  }
}
```

#### 2.6.2 状態マイグレーション
```typescript
class StateMigrator {
  private migrations = new Map<string, MigrationFunction>();
  
  constructor() {
    this.registerMigrations();
  }
  
  migrate(state: any): AppState {
    const currentVersion = state.version || '1.0.0';
    const targetVersion = this.getCurrentVersion();
    
    if (currentVersion === targetVersion) {
      return state;
    }
    
    return this.executeMigrationChain(state, currentVersion, targetVersion);
  }
  
  private executeMigrationChain(
    state: any, 
    fromVersion: string, 
    toVersion: string
  ): AppState {
    
    const migrationPath = this.findMigrationPath(fromVersion, toVersion);
    let currentState = state;
    
    for (const migration of migrationPath) {
      try {
        currentState = migration.execute(currentState);
        this.logger.info(`Migrated state from ${migration.from} to ${migration.to}`);
      } catch (error) {
        this.logger.error(`Migration failed: ${migration.from} -> ${migration.to}`, error);
        throw new StateMigrationError(
          `Failed to migrate state from ${migration.from} to ${migration.to}`,
          error
        );
      }
    }
    
    return currentState;
  }
  
  private registerMigrations(): void {
    // v1.0.0 -> v2.0.0: 認証設定の構造変更
    this.migrations.set('1.0.0->2.0.0', {
      from: '1.0.0',
      to: '2.0.0',
      execute: (state: any) => {
        return {
          ...state,
          version: '2.0.0',
          // 認証設定の移行
          collections: state.collections?.map((collection: any) => ({
            ...collection,
            requests: collection.requests?.map((request: any) => ({
              ...request,
              auth: this.migrateAuthConfig(request.auth)
            }))
          }))
        };
      }
    });
    
    // v2.0.0 -> v3.0.0: 環境変数の暗号化対応
    this.migrations.set('2.0.0->3.0.0', {
      from: '2.0.0',
      to: '3.0.0',
      execute: (state: any) => {
        return {
          ...state,
          version: '3.0.0',
          environments: state.environments?.map((env: any) => ({
            ...env,
            variables: this.migrateEnvironmentVariables(env.variables)
          }))
        };
      }
    });
  }
}
```

### 2.7 エラーハンドリング設計

#### 2.7.1 統一エラーハンドリングシステム
```typescript
abstract class AppError extends Error {
  abstract readonly code: string;
  abstract readonly category: ErrorCategory;
  readonly timestamp: string;
  readonly context?: Record<string, any>;
  
  constructor(message: string, context?: Record<string, any>) {
    super(message);
    this.name = this.constructor.name;
    this.timestamp = new Date().toISOString();
    this.context = context;
  }
  
  toJSON(): ErrorData {
    return {
      code: this.code,
      category: this.category,
      name: this.name,
      message: this.message,
      timestamp: this.timestamp,
      context: this.context,
      stack: this.stack
    };
  }
}

class RequestError extends AppError {
  readonly code = 'REQUEST_ERROR';
  readonly category = ErrorCategory.REQUEST;
}

class NetworkError extends AppError {
  readonly code = 'NETWORK_ERROR';
  readonly category = ErrorCategory.NETWORK;
}

class ScriptError extends AppError {
  readonly code = 'SCRIPT_ERROR';
  readonly category = ErrorCategory.SCRIPT;
}

class StorageError extends AppError {
  readonly code = 'STORAGE_ERROR';
  readonly category = ErrorCategory.STORAGE;
}
```

#### 2.7.2 グローバルエラーハンドラー
```typescript
class GlobalErrorHandler {
  private errorReporters: ErrorReporter[] = [];
  private recoveryStrategies = new Map<string, RecoveryStrategy>();
  private errorMetrics: ErrorMetrics = new ErrorMetrics();
  
  initialize(): void {
    // グローバルエラーイベントの監視
    window.addEventListener('error', (event) => {
      this.handleError(new UnhandledError(event.error || event.message));
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      this.handleError(new UnhandledPromiseRejectionError(event.reason));
    });
    
    // Chrome Extension specific error handling
    chrome.runtime.onInstalled.addListener(() => {
      this.setupExtensionErrorHandling();
    });
  }
  
  async handleError(error: Error): Promise<void> {
    try {
      // エラーメトリクスの更新
      this.errorMetrics.record(error);
      
      // エラーのカテゴリ分析
      const errorCategory = this.categorizeError(error);
      
      // 復旧戦略の実行
      const recovered = await this.attemptRecovery(error, errorCategory);
      
      // エラーレポート
      await this.reportError(error, errorCategory, recovered);
      
      // ユーザー通知
      if (this.shouldNotifyUser(error, errorCategory)) {
        this.notifyUser(error, errorCategory);
      }
      
    } catch (handlingError) {
      // エラーハンドリング自体が失敗した場合
      console.error('Error handler failed', handlingError);
      this.fallbackErrorHandling(error, handlingError);
    }
  }
  
  private async attemptRecovery(
    error: Error, 
    category: ErrorCategory
  ): Promise<boolean> {
    
    const strategyKey = `${error.constructor.name}_${category}`;
    const strategy = this.recoveryStrategies.get(strategyKey);
    
    if (!strategy) {
      return false;
    }
    
    try {
      return await strategy.recover(error);
    } catch (recoveryError) {
      this.logger.warn('Recovery strategy failed', recoveryError);
      return false;
    }
  }
  
  private setupRecoveryStrategies(): void {
    // ネットワークエラーの復旧戦略
    this.recoveryStrategies.set('NetworkError_NETWORK', {
      recover: async (error: NetworkError) => {
        // 接続確認
        const isOnline = await this.checkConnectivity();
        if (!isOnline) {
          this.showOfflineMode();
          return true;
        }
        
        // 自動リトライ
        return await this.retryLastRequest();
      }
    });
    
    // ストレージエラーの復旧戦略
    this.recoveryStrategies.set('StorageError_STORAGE', {
      recover: async (error: StorageError) => {
        // ストレージクォータチェック
        const quota = await this.checkStorageQuota();
        if (quota.exceeded) {
          this.showStorageCleanupDialog();
          return true;
        }
        
        // インメモリモードへ切り替え
        this.switchToInMemoryMode();
        return true;
      }
    });
  }
}
```

### 2.8 パフォーマンス最適化

#### 2.8.1 仮想スクロール実装
```typescript
class VirtualScrollManager {
  private container: HTMLElement;
  private itemHeight: number;
  private bufferSize: number = 5;
  private visibleItems = new Map<number, HTMLElement>();
  private itemRenderer: (item: any, index: number) => HTMLElement;
  
  constructor(
    container: HTMLElement, 
    itemHeight: number,
    itemRenderer: (item: any, index: number) => HTMLElement
  ) {
    this.container = container;
    this.itemHeight = itemHeight;
    this.itemRenderer = itemRenderer;
    this.setupScrollListener();
  }
  
  renderItems(items: any[]): void {
    const scrollTop = this.container.scrollTop;
    const containerHeight = this.container.clientHeight;
    
    // 表示範囲の計算
    const startIndex = Math.max(
      0, 
      Math.floor(scrollTop / this.itemHeight) - this.bufferSize
    );
    const endIndex = Math.min(
      items.length - 1,
      Math.ceil((scrollTop + containerHeight) / this.itemHeight) + this.bufferSize
    );
    
    // 不要なアイテムの削除
    this.cleanupInvisibleItems(startIndex, endIndex);
    
    // 必要なアイテムの追加
    this.renderVisibleItems(items, startIndex, endIndex);
    
    // コンテナの高さ設定
    this.updateContainerHeight(items.length);
  }
  
  private cleanupInvisibleItems(startIndex: number, endIndex: number): void {
    for (const [index, element] of this.visibleItems.entries()) {
      if (index < startIndex || index > endIndex) {
        element.remove();
        this.visibleItems.delete(index);
      }
    }
  }
  
  private renderVisibleItems(
    items: any[], 
    startIndex: number, 
    endIndex: number
  ): void {
    
    for (let i = startIndex; i <= endIndex; i++) {
      if (!this.visibleItems.has(i) && items[i]) {
        const element = this.itemRenderer(items[i], i);
        
        // 位置設定
        element.style.position = 'absolute';
        element.style.top = `${i * this.itemHeight}px`;
        element.style.height = `${this.itemHeight}px`;
        element.style.width = '100%';
        
        this.container.appendChild(element);
        this.visibleItems.set(i, element);
      }
    }
  }
  
  private setupScrollListener(): void {
    let scrollTimer: number;
    
    this.container.addEventListener('scroll', () => {
      // スクロールイベントのデバウンス
      clearTimeout(scrollTimer);
      scrollTimer = setTimeout(() => {
        this.handleScroll();
      }, 16); // 60fps
    });
  }
}
```

#### 2.8.2 メモリプール管理
```typescript
class ObjectPool<T> {
  private pool: T[] = [];
  private factory: () => T;
  private resetFunction: (item: T) => void;
  private maxSize: number;
  
  constructor(
    factory: () => T,
    resetFunction: (item: T) => void,
    maxSize: number = 100
  ) {
    this.factory = factory;
    this.resetFunction = resetFunction;
    this.maxSize = maxSize;
  }
  
  acquire(): T {
    if (this.pool.length > 0) {
      return this.pool.pop()!;
    }
    
    return this.factory();
  }
  
  release(item: T): void {
    if (this.pool.length < this.maxSize) {
      this.resetFunction(item);
      this.pool.push(item);
    }
    // プール上限の場合は破棄
  }
  
  clear(): void {
    this.pool.length = 0;
  }
  
  getPoolSize(): number {
    return this.pool.length;
  }
}

// 使用例
class RequestObjectPool {
  private requestPool = new ObjectPool(
    () => this.createRequestObject(),
    (request) => this.resetRequestObject(request),
    50
  );
  
  private responsePool = new ObjectPool(
    () => this.createResponseObject(),
    (response) => this.resetResponseObject(response),
    50
  );
  
  getRequest(): RequestData {
    return this.requestPool.acquire();
  }
  
  returnRequest(request: RequestData): void {
    this.requestPool.release(request);
  }
  
  getResponse(): ResponseData {
    return this.responsePool.acquire();
  }
  
  returnResponse(response: ResponseData): void {
    this.responsePool.release(response);
  }
}
```

---

## 3. テスト設計

### 3.1 単体テスト設計

#### 3.1.1 RequestManager テストケース
```typescript
describe('RequestManager', () => {
  let requestManager: RequestManager;
  let mockVariableManager: jest.Mocked<VariableManager>;
  let mockHttpClient: jest.Mocked<HttpClient>;
  let mockScriptExecutor: jest.Mocked<ScriptExecutor>;
  
  beforeEach(() => {
    mockVariableManager = createMockVariableManager();
    mockHttpClient = createMockHttpClient();
    mockScriptExecutor = createMockScriptExecutor();
    
    requestManager = new RequestManager({
      variableManager: mockVariableManager,
      httpClient: mockHttpClient,
      scriptExecutor: mockScriptExecutor
    });
  });
  
  describe('sendRequest', () => {
    it('should execute complete request flow successfully', async () => {
      // Arrange
      const request = createTestRequest({
        method: 'GET',
        url: 'https://api.example.com/test',
        preRequestScript: 'pm.variables.set("testVar", "testValue");'
      });
      
      mockHttpClient.send.mockResolvedValue(createTestResponse());
      mockScriptExecutor.execute.mockResolvedValue({ success: true });
      
      // Act
      const result = await requestManager.sendRequest(request);
      
      // Assert
      expect(result.success).toBe(true);
      expect(mockScriptExecutor.execute).toHaveBeenCalledTimes(1);
      expect(mockHttpClient.send).toHaveBeenCalledTimes(1);
      expect(result.response).toBeDefined();
    });
    
    it('should handle script execution errors gracefully', async () => {
      // Arrange
      const request = createTestRequest({
        preRequestScript: 'throw new Error("Script error");'
      });
      
      mockScriptExecutor.execute.mockRejectedValue(
        new ScriptError('Script execution failed')
      );
      
      // Act & Assert
      await expect(requestManager.sendRequest(request))
        .rejects.toThrow('Script execution failed');
    });
    
    it('should cancel request when abort signal is triggered', async () => {
      // Arrange
      const request = createTestRequest();
      const abortController = new AbortController();
      
      mockHttpClient.send.mockImplementation(() => {
        return new Promise((_, reject) => {
          abortController.signal.addEventListener('abort', () => {
            reject(new Error('Request aborted'));
          });
        });
      });
      
      // Act
      setTimeout(() => abortController.abort(), 100);
      
      // Assert
      await expect(requestManager.sendRequest(request))
        .rejects.toThrow('Request aborted');
    });
  });
});
```

### 3.2 統合テスト設計

#### 3.2.1 エンドツーエンドシナリオテスト
```typescript
describe('E2E: Complete Request Flow', () => {
  let testEnvironment: TestEnvironment;
  
  beforeAll(async () => {
    testEnvironment = await setupTestEnvironment();
  });
  
  afterAll(async () => {
    await testEnvironment.cleanup();
  });
  
  it('should execute a collection with variables and scripts', async () => {
    // Arrange: テストコレクションの準備
    const collection = await testEnvironment.createCollection({
      name: 'Test Collection',
      requests: [
        {
          name: 'Setup Request',
          method: 'POST',
          url: '{{baseUrl}}/setup',
          preRequestScript: `
            pm.variables.set('sessionId', pm.variables.get('randomString'));
            pm.variables.set('timestamp', new Date().toISOString());
          `,
          testScript: `
            pm.test('Setup successful', function() {
              pm.expect(pm.response.code).to.equal(200);
              const response = pm.response.json();
              pm.variables.set('authToken', response.token);
            });
          `
        },
        {
          name: 'Main Request',
          method: 'GET',
          url: '{{baseUrl}}/data/{{sessionId}}',
          headers: {
            'Authorization': 'Bearer {{authToken}}'
          },
          testScript: `
            pm.test('Data retrieved successfully', function() {
              pm.expect(pm.response.code).to.equal(200);
              pm.expect(pm.response.json()).to.have.property('data');
            });
          `
        }
      ],
      variables: {
        baseUrl: 'https://api.test.com',
        randomString: '{{$randomString}}'
      }
    });
    
    // Act: コレクション実行
    const result = await testEnvironment.runCollection(collection.id);
    
    // Assert: 結果検証
    expect(result.success).toBe(true);
    expect(result.results).toHaveLength(2);
    expect(result.results[0].testResults.passed).toBe(1);
    expect(result.results[1].testResults.passed).toBe(1);
  });
});
```

### 3.3 パフォーマンステスト設計

#### 3.3.1 負荷テストシナリオ
```typescript
describe('Performance Tests', () => {
  let performanceMonitor: PerformanceMonitor;
  
  beforeEach(() => {
    performanceMonitor = new PerformanceMonitor();
  });
  
  it('should handle 100 concurrent requests within acceptable time', async () => {
    // Arrange
    const requestCount = 100;
    const maxExecutionTime = 10000; // 10秒
    const requests = Array.from({ length: requestCount }, (_, i) => 
      createTestRequest({ name: `Request ${i}` })
    );
    
    // Act
    const startTime = performance.now();
    const promises = requests.map(request => 
      requestManager.sendRequest(request)
    );
    
    const results = await Promise.allSettled(promises);
    const endTime = performance.now();
    
    // Assert
    const executionTime = endTime - startTime;
    const successfulRequests = results.filter(r => r.status === 'fulfilled');
    
    expect(executionTime).toBeLessThan(maxExecutionTime);
    expect(successfulRequests.length).toBeGreaterThan(requestCount * 0.95); // 95%成功率
  });
  
  it('should maintain memory usage under 50MB during extended use', async () => {
    // Arrange
    const iterationCount = 1000;
    const memoryThreshold = 50 * 1024 * 1024; // 50MB
    
    // Act
    for (let i = 0; i < iterationCount; i++) {
      const request = createTestRequest();
      await requestManager.sendRequest(request);
      
      // メモリ使用量チェック（100回毎）
      if (i % 100 === 0) {
        const memoryUsage = await getMemoryUsage();
        expect(memoryUsage.usedJSHeapSize).toBeLessThan(memoryThreshold);
      }
    }
    
    // 最終メモリ使用量チェック
    const finalMemoryUsage = await getMemoryUsage();
    expect(finalMemoryUsage.usedJSHeapSize).toBeLessThan(memoryThreshold);
  });
});
```

---

## 4. セキュリティ実装

### 4.1 入力検証とサニタイゼーション

#### 4.1.1 リクエストデータ検証
```typescript
class RequestValidator {
  private urlValidator = new URLValidator();
  private headerValidator = new HeaderValidator();
  private bodyValidator = new BodyValidator();
  
  validate(request: RequestData): ValidationResult {
    const errors: ValidationError[] = [];
    
    try {
      // URL検証
      this.validateURL(request.url, errors);
      
      // メソッド検証
      this.validateMethod(request.method, errors);
      
      // ヘッダー検証
      this.validateHeaders(request.headers, errors);
      
      // ボディ検証
      this.validateBody(request.body, request.bodyType, errors);
      
      // 認証情報検証
      this.validateAuth(request.auth, errors);
      
      return {
        isValid: errors.length === 0,
        errors
      };
      
    } catch (error) {
      return {
        isValid: false,
        errors: [new ValidationError('Validation failed', error)]
      };
    }
  }
  
  private validateURL(url: string, errors: ValidationError[]): void {
    if (!url || typeof url !== 'string') {
      errors.push(new ValidationError('URL is required'));
      return;
    }
    
    // プロトコル検証
    if (!url.match(/^https?:\/\//)) {
      errors.push(new ValidationError('URL must use HTTP or HTTPS protocol'));
    }
    
    // URLの形式検証
    try {
      const parsed = new URL(url);
      
      // ローカルホストの制限（本番環境）
      if (this.isProduction() && this.isLocalhost(parsed.hostname)) {
        errors.push(new ValidationError('Localhost URLs are not allowed in production'));
      }
      
      // プライベートIPアドレスの制限
      if (this.isPrivateIP(parsed.hostname)) {
        errors.push(new ValidationError('Private IP addresses are not allowed'));
      }
      
    } catch (error) {
      errors.push(new ValidationError('Invalid URL format'));
    }
  }
  
  private validateHeaders(
    headers: Record<string, string>, 
    errors: ValidationError[]
  ): void {
    
    if (!headers || typeof headers !== 'object') {
      return;
    }
    
    Object.entries(headers).forEach(([name, value]) => {
      // ヘッダー名の検証
      if (!this.isValidHeaderName(name)) {
        errors.push(new ValidationError(`Invalid header name: ${name}`));
      }
      
      // 危険なヘッダーの検出
      if (this.isDangerousHeader(name)) {
        errors.push(new ValidationError(`Dangerous header detected: ${name}`));
      }
      
      // ヘッダー値の検証
      if (!this.isValidHeaderValue(value)) {
        errors.push(new ValidationError(`Invalid header value for ${name}`));
      }
    });
  }
  
  private isValidHeaderName(name: string): boolean {
    // RFC 7230に準拠したヘッダー名検証
    return /^[a-zA-Z0-9!#$&'*+.^_`|~-]+$/.test(name);
  }
  
  private isDangerousHeader(name: string): boolean {
    const dangerousHeaders = [
      'host',
      'content-length',
      'transfer-encoding',
      'connection',
      'upgrade',
      'expect',
      'proxy-authorization'
    ];
    
    return dangerousHeaders.includes(name.toLowerCase());
  }
}
```

#### 4.1.2 スクリプトセキュリティ検証
```typescript
class ScriptSecurityValidator {
  private dangerousPatterns: RegExp[] = [
    /eval\s*\(/,
    /Function\s*\(/,
    /setTimeout\s*\(/,
    /setInterval\s*\(/,
    /XMLHttpRequest/,
    /fetch\s*\(/,
    /WebSocket/,
    /Worker/,
    /SharedArrayBuffer/,
    /import\s*\(/,
    /require\s*\(/,
    /process\./,
    /global\./,
    /window\./,
    /document\./,
    /__proto__/,
    /constructor\.constructor/,
    /\.call\s*\(/,
    /\.apply\s*\(/,
    /\.bind\s*\(/
  ];
  
  private maxScriptLength = 50000; // 50KB
  private maxExecutionTime = 10000; // 10秒
  
  validate(script: string): SecurityValidationResult {
    const violations: SecurityViolation[] = [];
    
    // 基本チェック
    if (!script || typeof script !== 'string') {
      return { isValid: true, violations: [] };
    }
    
    // スクリプト長制限
    if (script.length > this.maxScriptLength) {
      violations.push({
        type: 'SCRIPT_TOO_LONG',
        message: `Script exceeds maximum length of ${this.maxScriptLength} characters`,
        severity: 'HIGH'
      });
    }
    
    // 危険なパターンの検出
    this.dangerousPatterns.forEach(pattern => {
      if (pattern.test(script)) {
        violations.push({
          type: 'DANGEROUS_PATTERN',
          message: `Dangerous pattern detected: ${pattern}`,
          severity: 'CRITICAL',
          pattern: pattern.toString()
        });
      }
    });
    
    // 文字列リテラル内のコード検出
    const sanitizedScript = this.removeStringLiterals(script);
    if (this.hasObfuscatedCode(sanitizedScript)) {
      violations.push({
        type: 'OBFUSCATED_CODE',
        message: 'Potentially obfuscated code detected',
        severity: 'HIGH'
      });
    }
    
    return {
      isValid: !violations.some(v => v.severity === 'CRITICAL'),
      violations
    };
  }
  
  private removeStringLiterals(script: string): string {
    // 文字列リテラルを除去してコード構造を分析
    return script
      .replace(/"[^"\\]*(?:\\.[^"\\]*)*"/g, '""')  // ダブルクォート文字列
      .replace(/'[^'\\]*(?:\\.[^'\\]*)*'/g, "''")  // シングルクォート文字列
      .replace(/`[^`\\]*(?:\\.[^`\\]*)*`/g, '``'); // テンプレートリテラル
  }
  
  private hasObfuscatedCode(script: string): boolean {
    // 難読化コードの特徴を検出
    const obfuscationIndicators = [
      /\w{20,}/, // 異常に長い識別子
      /[0-9a-fA-F]{32,}/, // 長い16進数文字列
      /\\x[0-9a-fA-F]{2}/, // 16進エスケープシーケンス
      /\\u[0-9a-fA-F]{4}/, // Unicode エスケープシーケンス
      /eval\s*\(\s*['"]/  // eval with string literals
    ];
    
    return obfuscationIndicators.some(pattern => pattern.test(script));
  }
}
```

---

## 5. まとめ

### 5.1 実装ガイドライン

#### 5.1.1 コードの品質基準
- **型安全性**: TypeScriptの厳密な型チェックを活用
- **エラーハンドリング**: 統一されたエラークラス階層の使用
- **テスト可能性**: 依存性注入とモックを活用した設計
- **パフォーマンス**: メモリプールと仮想スクロールの実装
- **セキュリティ**: 入力検証とサンドボックス実行の徹底

#### 5.1.2 実装順序の推奨
1. **基盤モジュール**: StateManager, Logger, ErrorHandler
2. **コアビジネスロジック**: VariableManager, RequestManager
3. **統合モジュール**: CollectionManager, ScriptExecutor
4. **UI コンポーネント**: 基本的なリクエストビルダーから開始
5. **高度な機能**: パフォーマンス最適化、セキュリティ強化

#### 5.1.3 品質保証のポイント
- 各モジュールの単体テストカバレッジ80%以上
- 統合テストによるデータフローの検証
- パフォーマンステストによる負荷検証
- セキュリティテストによる脆弱性検証
- エラーシナリオの包括的なテスト

この詳細なプログラム設計に基づいて、PostPro API Testerの各コンポーネントを段階的に実装し、高品質で保守性の高いソフトウェアを構築してください。

---

**このプログラム設計文書は、PostPro API Tester Chrome拡張機能の実装に必要な詳細なアルゴリズム、データフロー、エラーハンドリング戦略を定義しています。各プログラムモジュールの具体的な実装方法と、テスト時に問題が生じないよう配慮した設計となっています。**