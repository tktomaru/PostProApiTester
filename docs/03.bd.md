# 基本設計文書：PostPro API Tester Chrome 拡張

## 1. 文書概要

### 1.1 文書の目的
本基本設計文書は、要件定義文書（./docs/03.rd.md）とUI基本設計文書（./docs/04.ui.md）に基づいて、PostPro API Tester Chrome拡張機能のシステム全体の構造とデータフローを設計するものです。アプリケーション基本設計とデータベース基本設計の両面から、共通基盤とフレームワーク選定、実装ルールの制定を行い、詳細設計とプログラミングの基礎となる技術的な設計指針を提供します。

### 1.2 文書の範囲
- **アプリケーション基本設計**
  - システムアーキテクチャ設計とコンポーネント配置
  - フレームワークと制御部品設計
  - 共通基盤と実装ルール制定
  - Chrome拡張機能特化アーキテクチャ
- **データベース基本設計**
  - Chrome Storageを基盤としたデータアクセス設計
  - データベース論理設計と規約整備
  - テーブル定義基本方針とストレージ制約対応
  - データフロー設計と性能最適化
- **インターフェース設計とUI連携**
  - UI基本設計との技術的整合性確保
  - 利用体験価値を実現する技術実装方針
  - アクセシビリティ要件の技術実装

### 1.3 参照文書
- システム企画書（docs/01.sp.md）
- 要求定義文書（docs/02.sa.md）
- 要件定義文書（docs/03.rd.md）
- UI基本設計文書（docs/04.ui.md）
- プロジェクト構成ファイル（CLAUDE.md）

---

## 2. アプリケーション基本設計

### 2.1 共通基盤設計

#### 2.1.1 フレームワーク選定と基本方針
PostPro API Testerの共通基盤として、要件定義文書（BM-001, DB-001）とUI基本設計文書の利用体験価値設計に基づき、以下のフレームワークと技術スタックを採用します：

| 項目 | 値 | 説明 |
|-----|---|------|
| **Core Framework** | | |
| runtime | Chrome Extension Manifest V3 | 最新セキュリティ要件対応・Service Worker基盤 |
| architecture | Service Worker + Popup SPA | 要件定義IF-001準拠の分離アーキテクチャ |
| **Development Framework** | | |
| language | TypeScript (厳密モード) | 型安全性による品質向上・保守性確保 |
| bundler | Vite | 高速ビルド・HMR・ES modules対応 |
| testing | Jest + Puppeteer | 包括的テスト戦略（要件QA-001準拠） |
| **Application Framework** | | |
| stateManagement | Observer Pattern + Chrome Storage | 要件DB-001のデータライフサイクル実現 |
| uiFramework | Component-based Vanilla JS | UI設計の段階的機能開示対応 |
| httpClient | XMLHttpRequest + エコーAPI連携 | 要件EX-001準拠の統合テスト環境 |
| **Security Framework** | | |
| scriptExecution | Sandboxed V8 + 危険パターン検出 | セキュアなPre-request/Test実行 |
| dataEncryption | Web Crypto API (AES-256) | 認証情報・機密変数の暗号化 |
| variableSystem | 3階層優先度解決システム | Global/Environment/Collection変数管理 |

#### 2.1.2 制御部品とコアライブラリ
UI基本設計文書の利用体験最適化原則とFlow State維持を実現するための制御部品設計：

| 項目 | 値 | 説明 |
|-----|---|------|
| **State Management** | | |
| purpose | Observer Pattern状態管理による一元制御 | UI-データ双方向バインディング実現 |
| implementation | Event-driven + Chrome Storage API | UI設計のリアルタイム同期要件対応 |
| features | 自動永続化, バックアップ, 変更通知 | 中断最小化とタスク連続性確保 |
| **HTTP Request Engine** | | |
| purpose | 最短3ステップでの目標達成支援 | 価値創造シナリオの技術実装 |
| implementation | XMLHttpRequest + エコーAPI統合 | 要件EX-001準拠の統合テスト |
| features | 認証統合, 変数置換, 適切フィードバック | 認知負荷軽減と成功体験創出 |
| **Script Execution Engine** | | |
| purpose | 学習支援とセキュリティ両立 | 新人開発者価値シナリオ対応 |
| implementation | Sandboxed Runtime + 教育的エラー | 安全な学習環境とガイダンス |
| features | 危険検出, ベストプラクティス提案 | 段階的習得支援機能 |
| **Variable Resolution Engine** | | |
| purpose | チーム協業知見の自動蓄積・活用 | 集合知活用原則の技術実装 |
| implementation | 3階層優先度 + Built-in変数 | 組織学習促進の技術基盤 |
| features | 動的解決, コンテキスト適応 | 情報の論理的階層化実現 |

### 2.2 システムアーキテクチャ設計

#### 2.2.1 階層アーキテクチャ
要件定義IF-001の5画面構成システムとUI基本設計の利用体験価値実現のため、以下の階層構造で設計：

```
┌─────────────────────────────────────────────┐
│            Presentation Layer               │
│  ┌─────────────────┐  ┌─────────────────┐  │
│  │   Popup SPA     │  │  Content Script │  │
│  │ (5画面統合UI)   │  │ (HTTP Intercept) │  │
│  │ ├─メイン画面     │  │  (content.ts)   │  │
│  │ ├─コレクション   │  │                 │  │
│  │ ├─環境管理       │  │                 │  │
│  │ ├─履歴画面       │  │                 │  │
│  │ └─設定画面       │  │                 │  │
│  └─────────────────┘  └─────────────────┘  │
└─────────────────────────────────────────────┘
┌─────────────────────────────────────────────┐
│             Application Layer               │
│  ┌─────────────────┐  ┌─────────────────┐  │
│  │ Request Manager │  │Collection Manager│ │
│  │(エコーAPI統合)   │  │(チーム共有支援)  │  │
│  │ Variable Manager│  │Scenario Manager │  │
│  │(3階層変数管理)   │  │(自動化支援)      │  │
│  │ Test Executor   │  │ History Manager │  │
│  │(学習支援機能)    │  │(検索・再実行)    │  │
│  └─────────────────┘  └─────────────────┘  │
└─────────────────────────────────────────────┘
┌─────────────────────────────────────────────┐
│               Service Layer                 │
│  ┌─────────────────┐  ┌─────────────────┐  │
│  │ Service Worker  │  │ Injected Script │  │
│  │(バックグラウンド │  │(リアルタイム    │  │
│  │ タスク処理)      │  │ インターセプト)  │  │
│  │ background.ts   │  │ injected.ts     │  │
│  └─────────────────┘  └─────────────────┘  │
└─────────────────────────────────────────────┘
┌─────────────────────────────────────────────┐
│                Data Layer                   │
│  ┌─────────────────┐  ┌─────────────────┐  │
│  │ State Manager   │  │ Storage Manager │  │
│  │(Observer Pattern)│  │(Chrome Storage  │  │
│  │ state.ts        │  │ + Encryption)   │  │
│  └─────────────────┘  └─────────────────┘  │
└─────────────────────────────────────────────┘
```

#### Chrome拡張機能アーキテクチャ
```
┌─────────────────────────────────────────────┐
│                Web Page                     │
│  ┌─────────────────┐                       │
│  │ Injected Script │ ←── HTTP Intercept     │
│  │  (injected.ts)  │                       │
│  └─────────────────┘                       │
└─────────────────────────────────────────────┘
            ↕ Message Passing
┌─────────────────────────────────────────────┐
│            Content Script                   │
│  ┌─────────────────┐                       │
│  │  content.ts     │ ←── DOM Interaction    │
│  └─────────────────┘                       │
└─────────────────────────────────────────────┘
            ↕ Message Passing
┌─────────────────────────────────────────────┐
│            Service Worker                   │
│  ┌─────────────────┐                       │
│  │ background.ts   │ ←── Background Tasks   │
│  └─────────────────┘                       │
└─────────────────────────────────────────────┘
            ↕ Message Passing
┌─────────────────────────────────────────────┐
│              Popup UI                       │
│  ┌─────────────────┐                       │
│  │   app.ts        │ ←── User Interface     │
│  │  index.html     │                       │
│  └─────────────────┘                       │
└─────────────────────────────────────────────┘
```

### 2.2 コンポーネント間通信設計

#### Message Passing API設計

**メッセージ型定義**
| 項目 | 値 | 説明 |
|-----|---|------|
| **MessageBase** | | |
| type | string | メッセージタイプ識別子 |
| id | string (optional) | メッセージ固有ID |
| timestamp | number | メッセージ送信時刻 |
| **RequestMessage** | | |
| type | 'SEND_REQUEST' | リクエスト送信メッセージ |
| data.request | Request | 送信するリクエストオブジェクト |
| data.options | RequestOptions (optional) | リクエスト送信オプション |
| **ResponseMessage** | | |
| type | 'REQUEST_RESPONSE' | レスポンス受信メッセージ |
| data.response | Response | 受信したレスポンスオブジェクト |
| data.error | Error (optional) | エラー情報（ある場合） |
| **StateUpdateMessage** | | |
| type | 'STATE_UPDATE' | 状態更新メッセージ |
| data.path | string | 更新対象の状態パス |
| data.value | any | 更新値 |

**メッセージルーティング**
| 項目 | 値 | 説明 |
|-----|---|------|
| handlers | Map<string, MessageHandler[]> | メッセージタイプ別ハンドラー管理 |
| register() | (type: string, handler: MessageHandler) => void | ハンドラー登録メソッド |
| route() | (message: MessageBase) => Promise<any> | メッセージルーティング処理 |

---

## 3. コンポーネント設計

### 3.1 Core Modules

#### 3.1.1 App Controller (app.ts)

| 項目 | 値 | 説明 |
|-----|---|------|
| **クラス構成** | | |
| uiManager | UIManager | UI管理コンポーネント |
| requestManager | RequestManager | リクエスト処理管理 |
| stateManager | StateManager | アプリケーション状態管理 |
| **初期化プロセス** | | |
| constructor() | コンポーネント初期化, イベントリスナー設定 | アプリ起動時の基本セットアップ |
| initialize() | 状態読み込み, UI描画, メッセージハンドラー登録 | 非同期初期化処理 |
| **メッセージ処理** | | |
| registerMessageHandlers() | Chrome Message API ハンドラー登録 | Chrome拡張機能間通信設定 |
| handleMessage() | リクエスト・レスポンス処理 | メッセージ受信時の処理ロジック |

#### 3.1.2 State Manager (state.ts)

**AppState構造**
| 項目 | 値 | 説明 |
|-----|---|------|
| currentRequest | Request | 現在編集中のリクエスト |
| collections | Collection[] | コレクション一覧 |
| environments | Environment[] | 環境設定一覧 |
| globalVariables | Variables | グローバル変数 |
| currentEnvironment | string | 現在選択中の環境 |
| history | RequestHistory[] | リクエスト履歴 |
| settings | AppSettings | アプリケーション設定 |
| ui | UIState | UI状態情報 |

**StateManagerメソッド**
| 項目 | 値 | 説明 |
|-----|---|------|
| state | AppState | アプリケーション状態オブジェクト |
| listeners | StateListener[] | 状態変更リスナー配列 |
| loadState() | Promise<void> | Chrome Storageから状態読み込み |
| saveState() | Promise<void> | Chrome Storageへ状態保存 |
| subscribe() | (listener: StateListener) => void | 状態変更リスナー登録 |
| setState() | (path: string, value: any) => void | 状態更新と通知 |
| getState() | (path?: string) => any | 状態取得（パス指定可能） |

### 3.2 Feature Modules

#### 3.2.1 Request Manager (requestManager.ts)

**依存コンポーネント**
| 項目 | 値 | 説明 |
|-----|---|------|
| httpClient | HttpClient | HTTP通信処理クライアント |
| scriptExecutor | ScriptExecutor | スクリプト実行エンジン |
| variableManager | VariableManager | 変数管理システム |
| performanceMonitor | PerformanceMonitor | 性能監視ツール |

**リクエスト実行フロー**
| 項目 | 値 | 説明 |
|-----|---|------|
| 1. executePreRequestScript() | Pre-requestスクリプト実行 | リクエスト送信前の前処理 |
| 2. processRequest() | 変数置換処理 | URL・ヘッダー・ボディの変数展開 |
| 3. httpClient.send() | HTTPリクエスト送信 | 実際のAPI呼び出し |
| 4. executeTestScript() | テストスクリプト実行 | レスポンス検証処理 |
| 5. recordHistory() | 履歴記録 | リクエスト・レスポンスの保存 |

**スクリプトコンテキスト**
| 項目 | 値 | 説明 |
|-----|---|------|
| pm | PostmanAPI | Postman互換API |
| console | ScriptConsole | ログ出力機能 |
| setTimeout | タイムアウト制御関数 | スクリプト内での時間制御 |

**戻り値（RequestResult）**
| 項目 | 値 | 説明 |
|-----|---|------|
| request | processedRequest | 変数展開後のリクエスト |
| response | Response | HTTPレスポンス |
| testResults | TestResult[] | テスト実行結果 |
| executionTime | number | 実行時間（ミリ秒） |

#### 3.2.2 Variable Manager (variableManager.ts)

**変数スコープ階層**
| 項目 | 値 | 説明 |
|-----|---|------|
| dynamicVariables | Variables | 実行時動的変数（最高優先度） |
| collectionVariables | Variables | コレクション変数 |
| environmentVariables | Variables | 環境変数 |
| globalVariables | Variables | グローバル変数（最低優先度） |

**変数解決プロセス**
| 項目 | 値 | 説明 |
|-----|---|------|
| resolveVariable() | 階層的変数解決 | 優先順位に従った変数値取得 |
| processString() | 文字列内変数置換 | {{variableName}}形式の展開 |
| processRequest() | リクエスト変数処理 | URL・ヘッダー・パラメータ・ボディの変数展開 |

**組み込み変数**
| 項目 | 値 | 説明 |
|-----|---|------|
| $timestamp | Date.now() | 現在のタイムスタンプ（ミリ秒） |
| $isoTimestamp | new Date().toISOString() | ISO 8601形式の現在日時 |
| $randomInt | Math.floor(Math.random() * 1000) | 0-999のランダム整数 |
| $guid | generateGuid() | UUID v4 文字列 |

**変数置換パターン**
| 項目 | 値 | 説明 |
|-----|---|------|
| 置換形式 | {{variableName}} | 波括弧2つで囲む形式 |
| 未定義時動作 | 元の文字列を保持 | 警告ログ出力後、置換せず |
| 型変換 | String(value) | すべての値を文字列に変換 |

#### 3.2.3 Collection Manager (collectionManager.ts)

**コレクション管理**
| 項目 | 値 | 説明 |
|-----|---|------|
| collections | Map<string, Collection> | コレクションのメモリ管理 |
| stateManager | StateManager | 状態管理システム連携 |

**Collectionオブジェクト構造**
| 項目 | 値 | 説明 |
|-----|---|------|
| id | string | 一意識別子（UUID） |
| name | string | コレクション名 |
| description | string | コレクション説明 |
| variables | Variables | コレクション固有変数 |
| requests | Request[] | 含まれるリクエスト一覧 |
| folders | Folder[] | フォルダ階層構造 |
| created | Date | 作成日時 |
| updated | Date | 最終更新日時 |

**主要メソッド**
| 項目 | 値 | 説明 |
|-----|---|------|
| createCollection() | (name, description) => Promise<Collection> | 新規コレクション作成 |
| runCollection() | (collectionId, options) => Promise<CollectionRunResult> | コレクション一括実行 |
| importCollection() | (data, format) => Promise<Collection> | 外部形式からのインポート |

**サポートするインポート形式**
| 項目 | 値 | 説明 |
|-----|---|------|
| postman | PostmanImporter | Postman Collection v2.1 形式 |
| openapi | OpenAPIImporter | OpenAPI 3.0 仕様書 |
| insomnia | InsomniaImporter | Insomnia エクスポート形式 |

### 3.3 Support Modules

#### 3.3.1 HTTP Client (httpClient.ts)

**設定項目**
| 項目 | 値 | 説明 |
|-----|---|------|
| defaultTimeout | 30000 | デフォルトタイムアウト（30秒） |

**リクエスト送信プロセス**
| 項目 | 値 | 説明 |
|-----|---|------|
| 1. createXHR() | XMLHttpRequest作成・設定 | HTTP通信オブジェクトの準備 |
| 2. executeRequest() | 非同期リクエスト実行 | Promise型での通信実行 |
| 3. Response生成 | レスポンスオブジェクト作成 | 実行時間・タイムスタンプ付与 |

**XHR設定項目**
| 項目 | 値 | 説明 |
|-----|---|------|
| method | request.method | HTTPメソッド（GET, POST等） |
| url | request.url | リクエストURL |
| timeout | request.timeout \|\| defaultTimeout | タイムアウト時間（ミリ秒） |
| headers | Object.entries(request.headers) | HTTPヘッダー設定 |
| responseType | 'blob' | レスポンスデータ形式 |

**イベントハンドリング**
| 項目 | 値 | 説明 |
|-----|---|------|
| onload | resolve(createResponse()) | 正常完了時の処理 |
| onerror | reject(Network error) | ネットワークエラー時 |
| ontimeout | reject(Request timeout) | タイムアウト時 |

**レスポンス拡張情報**
| 項目 | 値 | 説明 |
|-----|---|------|
| responseTime | performance.now() - startTime | 実行時間（ミリ秒） |
| timestamp | new Date() | レスポンス受信時刻 |

#### 3.3.2 Script Executor (scriptExecutor.ts)

**実行環境構成**
| 項目 | 値 | 説明 |
|-----|---|------|
| sandbox | ScriptSandbox | 分離された実行環境 |
| logger | Logger | ログ出力システム |

**実行プロセス**
| 項目 | 値 | 説明 |
|-----|---|------|
| 1. validateScript() | セキュリティ検証 | 危険なコードパターンのチェック |
| 2. createSandbox() | サンドボックス作成 | 制限された実行環境の準備 |
| 3. executeInSandbox() | スクリプト実行 | 安全な環境でのコード実行 |

**サンドボックス許可API**
| 項目 | 値 | 説明 |
|-----|---|------|
| pm | context.pm | Postman互換API |
| console | context.console | ログ出力機能 |
| setTimeout | context.setTimeout | タイムアウト制御 |
| JSON | JSON | JSON操作API |
| Date | Date | 日時操作API |
| Math | Math | 数学関数API |

**サンドボックス禁止API**
| 項目 | 値 | 説明 |
|-----|---|------|
| eval | undefined | 動的コード実行の禁止 |
| Function | undefined | Function生成の禁止 |
| XMLHttpRequest | undefined | 直接HTTP通信の禁止 |
| fetch | undefined | fetch APIの禁止 |

**危険パターン検出**
| 項目 | 値 | 説明 |
|-----|---|------|
| eval\\s*\\( | eval関数の使用 | 動的コード実行の検出 |
| Function\\s*\\( | Function コンストラクタ | 動的関数生成の検出 |
| XMLHttpRequest | XMLHttpRequest | 直接HTTP通信の検出 |
| fetch\\s*\\( | fetch API | fetch使用の検出 |
| __proto__ | プロトタイプ操作 | オブジェクト操作の検出 |
| constructor\\.constructor | コンストラクタアクセス | プロトタイプチェーン操作の検出 |

---

## 4. データフロー設計

### 4.1 リクエスト実行フロー

```mermaid
sequenceDiagram
    participant UI as Popup UI
    participant RM as Request Manager
    participant VM as Variable Manager
    participant SE as Script Executor
    participant HC as HTTP Client
    participant SM as State Manager
    
    UI->>RM: sendRequest(request)
    RM->>SE: executePreRequestScript()
    SE->>VM: setVariable(key, value)
    RM->>VM: processRequest(request)
    VM-->>RM: processedRequest
    RM->>HC: send(processedRequest)
    HC-->>RM: response
    RM->>SE: executeTestScript(response)
    SE-->>RM: testResults
    RM->>SM: saveHistory(request, response)
    RM-->>UI: requestResult
```

### 4.2 変数解決フロー

```mermaid
flowchart TD
    A[Variable Reference: {{varName}}] --> B{Dynamic Variables}
    B -->|Found| C[Return Value]
    B -->|Not Found| D{Collection Variables}
    D -->|Found| C
    D -->|Not Found| E{Environment Variables}
    E -->|Found| C
    E -->|Not Found| F{Global Variables}
    F -->|Found| C
    F -->|Not Found| G{Built-in Variables}
    G -->|Found| C
    G -->|Not Found| H[Return Original Reference]
```

### 4.3 状態管理フロー

```mermaid
stateDiagram-v2
    [*] --> Loading
    Loading --> Ready: Load Complete
    Ready --> Executing: Send Request
    Executing --> Processing: Pre-Request Script
    Processing --> Sending: Variable Processing
    Sending --> Testing: HTTP Request
    Testing --> Complete: Test Script
    Complete --> Ready: Save History
    
    Ready --> Saving: Update State
    Saving --> Ready: Save Complete
    
    Executing --> Error: Request Failed
    Processing --> Error: Script Error
    Testing --> Error: Test Failed
    Error --> Ready: Error Handled
```

---

## 5. インターフェース設計

### 5.1 ユーザーインターフェース設計

#### 5.1.1 レイアウト構成
```
┌─────────────────────────────────────────────────────────┐
│                    Header Bar                           │
│  [Logo] [Collections] [Environment] [Settings] [Help]   │
├─────────────────────────────────────────────────────────┤
│ Sidebar          │            Main Content              │
│ ┌─────────────┐  │  ┌─────────────────────────────────┐ │
│ │Collections  │  │  │        Request Builder          │ │
│ │ ├─ Folder1   │  │  │  [METHOD] [URL______] [SEND]   │ │
│ │ │  ├─ Req1   │  │  │                                │ │
│ │ │  └─ Req2   │  │  │  [Params][Headers][Body][Auth] │ │
│ │ ├─ Folder2   │  │  │                                │ │
│ │ └─ Req3      │  │  │  [Pre-request][Tests]          │ │
│ │             │  │  └─────────────────────────────────┘ │
│ │History      │  │                                      │
│ │ ├─ 10:30 GET│  │  ┌─────────────────────────────────┐ │
│ │ ├─ 10:25 POST │  │        Response Viewer            │ │
│ │ └─ 10:20 PUT│  │  │  Status: 200 OK    Time: 234ms  │ │
│ └─────────────┘  │  │                                 │ │
│                  │  │  [Body][Headers][Tests][Cookies]│ │
│                  │  └─────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

#### 5.1.2 コンポーネント階層
```typescript
interface UIComponent {
  render(): HTMLElement;
  update(data: any): void;
  destroy(): void;
}

class AppUI {
  private components: Map<string, UIComponent> = new Map();
  
  // Main components
  private header: HeaderComponent;
  private sidebar: SidebarComponent;
  private requestBuilder: RequestBuilderComponent;
  private responseViewer: ResponseViewerComponent;
  
  constructor() {
    this.initializeComponents();
    this.setupLayout();
  }
  
  private initializeComponents(): void {
    this.header = new HeaderComponent();
    this.sidebar = new SidebarComponent();
    this.requestBuilder = new RequestBuilderComponent();
    this.responseViewer = new ResponseViewerComponent();
    
    // Register components
    this.components.set('header', this.header);
    this.components.set('sidebar', this.sidebar);
    this.components.set('requestBuilder', this.requestBuilder);
    this.components.set('responseViewer', this.responseViewer);
  }
}
```

### 5.2 API設計

#### 5.2.1 Internal API
```typescript
// Request Manager API
interface IRequestManager {
  sendRequest(request: Request): Promise<RequestResult>;
  cancelRequest(requestId: string): Promise<void>;
  getRequestHistory(): Promise<RequestHistory[]>;
}

// Variable Manager API
interface IVariableManager {
  setGlobalVariable(key: string, value: any): void;
  setEnvironmentVariable(key: string, value: any): void;
  setCollectionVariable(key: string, value: any): void;
  getVariable(key: string): any;
  processString(input: string): string;
}

// Collection Manager API
interface ICollectionManager {
  createCollection(name: string): Promise<Collection>;
  updateCollection(id: string, updates: Partial<Collection>): Promise<Collection>;
  deleteCollection(id: string): Promise<void>;
  runCollection(id: string, options?: RunOptions): Promise<CollectionRunResult>;
}
```

#### 5.2.2 Chrome Extension API
```typescript
// Message API between components
interface ChromeMessageAPI {
  // Background Script Messages
  BACKGROUND_REQUEST: 'bg_request';
  BACKGROUND_RESPONSE: 'bg_response';
  
  // Content Script Messages
  CONTENT_INJECT: 'content_inject';
  CONTENT_INTERCEPT: 'content_intercept';
  
  // Popup Messages
  POPUP_STATE_UPDATE: 'popup_state_update';
  POPUP_ACTION: 'popup_action';
}

// Storage API
interface ChromeStorageAPI {
  STATE_KEY: 'postpro_state';
  COLLECTIONS_KEY: 'postpro_collections';
  HISTORY_KEY: 'postpro_history';
  SETTINGS_KEY: 'postpro_settings';
}
```

---

## 6. データベース基本設計

### 6.1 データベースアクセス基本設計

#### 6.1.1 ストレージアーキテクチャ設計
要件定義DB-001とUI基本設計の性能要件（startup: 200ms以内）を満たすため、Chrome Storage APIを基盤とした階層化ストレージシステムを採用：

```typescript
interface StorageArchitecture {
  // ストレージ層の設計（要件DB-001準拠）
  layers: {
    cache: 'メモリキャッシュ層（UI応答性100ms以内対応）';
    storage: 'Chrome Storage API (local) 5MB制限対応';
    backup: '90日保持・自動アーカイブ機能';
  };
  
  // アクセスパターン設計（UI体験最適化）
  accessPatterns: {
    readThrough: 'キャッシュ優先・段階的データ読み込み';
    writeBack: 'バッチ書き込み（500ms遅延）';
    eventDriven: 'Observer Pattern状態変更通知';
  };
  
  // データ整合性保証（チーム協業支援）
  consistency: {
    transactional: 'コレクション単位の原子性保証';
    versioning: 'データスキーマv2.0管理';
    validation: 'TypeScript型定義による検証';
    encryption: 'AES-256認証情報暗号化';
  };
}
```

#### 6.1.2 データベース論理設計規約
要件定義のデータ構造設計と3階層変数管理要件を技術実装するための規約定義：

```typescript
interface DatabaseConventions {
  // 命名規約（要件準拠）
  naming: {
    collections: 'postpro_collections'; // コレクション管理データ
    environments: 'postpro_environments'; // 環境・変数管理画面データ
    history: 'postpro_history'; // 履歴画面データ
    settings: 'postpro_settings'; // 設定画面データ
    state: 'postpro_state'; // メイン画面アプリケーション状態
  };
  
  // データ型規約（型安全性確保）
  dataTypes: {
    id: 'UUID v4 string'; // 一意識別子
    timestamp: 'ISO 8601 string'; // 日時形式統一
    json: 'TypeScript検証済JSON'; // 型安全なJSON
    encrypted: 'AES-256 Base64 string'; // 暗号化データ
  };
  
  // 関係設計規約（チーム協業支援）
  relationships: {
    oneToMany: 'Collection -> Requests[]'; // コレクション-リクエスト
    hierarchy: 'Global > Environment > Collection変数'; // 3階層優先度
    referential: 'TypeScript型による参照整合性'; // 型レベル制約
    versioning: 'スキーマバージョン付きマイグレーション'; // データ進化対応
  };
}
```

### 6.2 テーブル定義基本方針

#### 6.2.1 エンティティ設計方針
Chrome Storage制約（5MB上限）とUI性能要件を両立するエンティティ設計：

```typescript
interface EntityDesignPolicy {
  // 正規化方針（ストレージ効率最適化）
  normalization: {
    level: '第3正規形（冗長性排除）';
    redundancy: 'UI高速表示用の計算済みフィールド許可';
    partitioning: 'コレクション単位分割（要件準拠）';
    compression: '1KB以上データのgzip圧縮';
  };
  
  // インデックス戦略（検索性能向上）
  indexing: {
    primary: 'UUID v4主キー（分散対応）';
    foreign: 'TypeScript型による参照整合性';
    search: 'コレクション・リクエスト名での全文検索';
    temporal: '履歴データの時系列インデックス';
  };
  
  // データライフサイクル（要件DB-001準拠）
  lifecycle: {
    creation: 'ISO 8601タイムスタンプ自動付与';
    modification: 'Observer Pattern変更追跡';
    archival: '90日経過後の自動アーカイブ';
    deletion: '論理削除（deleted: boolean）';
    encryption: '認証情報のリアルタイム暗号化';
  };
}
```

### 6.3 ストレージ構造設計

#### 6.3.1 データベーステーブル設計

#### 6.1.1 ストレージスキーマ

| 項目 | 値 | 説明 |
|-----|---|------|
| **Application State** | | |
| postpro_state.currentRequest | Request | 現在編集中のリクエスト |
| postpro_state.currentEnvironment | string | 選択中環境ID |
| postpro_state.ui | UIState | UI表示状態 |
| postpro_state.lastUpdated | string | 最終更新時刻 |
| **Collections** | | |
| postpro_collections | {[collectionId: string]: Collection} | コレクションデータマップ |
| **Environments** | | |
| postpro_environments | {[environmentId: string]: Environment} | 環境設定データマップ |
| **Global Variables** | | |
| postpro_global_variables | Variables | グローバル変数オブジェクト |
| **Request History** | | |
| postpro_history.items | RequestHistory[] | リクエスト履歴配列 |
| postpro_history.maxItems | number | 最大保持件数 |
| postpro_history.lastCleanup | string | 最終クリーンアップ時刻 |
| **Application Settings** | | |
| postpro_settings | AppSettings | アプリケーション設定 |
| **Backup Data** | | |
| postpro_backups | {[backupId: string]: BackupData} | バックアップデータマップ |

#### 6.1.2 データ制約

| 項目 | 値 | 説明 |
|-----|---|------|
| **Chrome Storage制限** | | |
| MAX_STORAGE_SIZE | 5 * 1024 * 1024 (5MB) | Chrome Storage最大容量 |
| MAX_ITEMS | 512 | 最大アイテム数 |
| **アプリケーション制限** | | |
| MAX_COLLECTIONS | 100 | 最大コレクション数 |
| MAX_REQUESTS_PER_COLLECTION | 1000 | コレクション当たり最大リクエスト数 |
| MAX_HISTORY_ITEMS | 1000 | 最大履歴保持件数 |
| MAX_VARIABLE_VALUE_LENGTH | 8192 | 変数値最大長（文字） |
| **性能制約** | | |
| BATCH_SAVE_DELAY | 500 (ms) | バッチ保存遅延時間 |
| HISTORY_CLEANUP_INTERVAL | 24 * 60 * 60 * 1000 (24時間) | 履歴クリーンアップ間隔 |

### 6.4 データアクセス基本設計

#### 6.4.1 データアクセス層アーキテクチャ
```typescript
interface DataAccessLayer {
  // Repository Pattern実装
  repositories: {
    collectionRepository: 'コレクションデータ操作';
    requestRepository: 'リクエストデータ操作';
    historyRepository: '履歴データ操作';
    variableRepository: '変数データ操作';
  };
  
  // Data Access Object (DAO)
  dataAccessObjects: {
    storageDAO: 'Chrome Storage API抽象化';
    cacheDAO: 'メモリキャッシュ操作';
    backupDAO: 'バックアップデータ操作';
  };
  
  // Transaction Manager
  transactionManager: {
    batchOperations: '複数操作の原子性保証';
    rollbackSupport: 'エラー時の状態復元';
    lockingMechanism: '同時アクセス制御';
  };
}
```

#### 6.4.2 Storage Manager実装

**内部状態管理**
| 項目 | 値 | 説明 |
|-----|---|------|
| cache | Map<string, any> | 高速アクセス用キャッシュ |
| saveQueue | Map<string, any> | バッチ保存用キュー |
| saveTimer | number \| null | 保存遅延タイマー |

**get<T>メソッド（読み取り）**
| 項目 | 値 | 説明 |
|-----|---|------|
| 1. キャッシュ確認 | this.cache.has(key) | メモリキャッシュから高速取得 |
| 2. Chrome Storage読み取り | chrome.storage.local.get(key) | 永続化データから取得 |
| 3. キャッシュ更新 | this.cache.set(key, value) | 次回アクセス高速化 |
| 戻り値 | T \| null | 型安全な値取得 |

**setメソッド（書き込み）**
| 項目 | 値 | 説明 |
|-----|---|------|
| 1. キャッシュ更新 | this.cache.set(key, value) | 即座にメモリ反映 |
| 2. 保存キュー追加 | this.saveQueue.set(key, value) | バッチ処理用キューイング |
| 3. 保存スケジュール | this.scheduleBatchSave() | 遅延バッチ保存の開始 |

**バッチ保存プロセス**
| 項目 | 値 | 説明 |
|-----|---|------|
| scheduleBatchSave() | タイマー設定（500ms遅延） | 複数変更をまとめて処理 |
| executeBatchSave() | chrome.storage.local.set(data) | キュー内容を一括保存 |
| タイマークリア | this.saveTimer = null | 次回処理の準備 |

**性能最適化特徴**
| 項目 | 値 | 説明 |
|-----|---|------|
| Read-through キャッシュ | キャッシュミス時にストレージ読み取り | 読み取り性能向上 |
| Write-back バッチ処理 | 500ms遅延でまとめて保存 | 書き込み性能向上 |
| タイマー再スケジュール | 連続更新時のタイマーリセット | 効率的なバッチング |

---

## 7. セキュリティ設計

### 7.1 認証情報保護

#### 7.1.1 暗号化設計

**暗号化設定**
| 項目 | 値 | 説明 |
|-----|---|------|
| ALGORITHM | 'AES-GCM' | 対称暗号化アルゴリズム |
| KEY_LENGTH | 256 | 暗号化キー長（ビット） |

**暗号化プロセス（encryptSensitiveData）**
| 項目 | 値 | 説明 |
|-----|---|------|
| 1. キー導出 | deriveKey() | PBKDF2による安全なキー生成 |
| 2. IV生成 | crypto.getRandomValues(12) | ランダム初期化ベクトル |
| 3. データエンコード | TextEncoder().encode(JSON.stringify(data)) | JSON文字列化+バイト変換 |
| 4. 暗号化実行 | crypto.subtle.encrypt() | AES-GCM暗号化 |
| 5. 結果構造化 | EncryptedData形式 | アルゴリズム情報・IV・データ・タイムスタンプ |

**復号化プロセス（decryptSensitiveData）**
| 項目 | 値 | 説明 |
|-----|---|------|
| 1. キー導出 | deriveKey() | 暗号化と同じキー生成 |
| 2. 復号化実行 | crypto.subtle.decrypt() | AES-GCM復号化 |
| 3. データデコード | TextDecoder().decode() | バイト配列から文字列へ |
| 4. JSON復元 | JSON.parse(plaintext) | 元のオブジェクト構造へ |

**キー導出プロセス（deriveKey）**
| 項目 | 値 | 説明 |
|-----|---|------|
| baseKey | 'postpro-api-tester-key' | ベースキー文字列 |
| アルゴリズム | PBKDF2 | パスワードベースキー導出 |
| salt | 'postpro-salt' | ソルト値 |
| iterations | 100000 | ハッシュ反復回数 |
| hash | SHA-256 | ハッシュ関数 |

**EncryptedData構造**
| 項目 | 値 | 説明 |
|-----|---|------|
| algorithm | 'AES-GCM' | 使用暗号化アルゴリズム |
| iv | Array<number> | 初期化ベクトル（配列形式） |
| data | Array<number> | 暗号化データ（配列形式） |
| timestamp | number | 暗号化実行時刻 |

### 7.2 スクリプト実行セキュリティ

#### 7.2.1 サンドボックス設計

**許可API一覧**
| 項目 | 値 | 説明 |
|-----|---|------|
| JSON.parse | JSONパース処理 | 安全なJSON解析 |
| JSON.stringify | JSON文字列化 | 安全なJSON生成 |
| Date.now | 現在時刻取得 | タイムスタンプ生成 |
| Math.random | 乱数生成 | ランダム値生成 |
| console.log | ログ出力 | デバッグ情報出力 |

**セキュアコンテキスト構成**
| 項目 | 値 | 説明 |
|-----|---|------|
| pm | createPostmanAPI(variables) | Postman互換API |
| console | createSecureConsole() | 制限されたコンソール |
| JSON | {parse, stringify} | 安全なJSON操作 |
| Date | {now} | 限定的日時API |
| Math | {random, floor} | 限定的数学API |

**ブロック対象API**
| 項目 | 値 | 説明 |
|-----|---|------|
| eval | undefined | 動的コード実行の禁止 |
| Function | undefined | 動的関数生成の禁止 |
| XMLHttpRequest | undefined | 直接HTTP通信の禁止 |
| fetch | undefined | fetch API の禁止 |
| import | undefined | モジュールインポートの禁止 |
| require | undefined | CommonJS require の禁止 |
| process | undefined | Node.js process の禁止 |
| global | undefined | グローバルオブジェクトの禁止 |
| window | undefined | ウィンドウオブジェクトの禁止 |
| document | undefined | DOMアクセスの禁止 |

**危険パターン検証**
| 項目 | 値 | 説明 |
|-----|---|------|
| eval\\s*\\( | 'eval() is not allowed' | eval関数使用の検出 |
| Function\\s*\\( | 'Function constructor is not allowed' | Function生成の検出 |
| XMLHttpRequest | 'XMLHttpRequest is not allowed' | 直接HTTP通信の検出 |
| fetch\\s*\\( | 'fetch() is not allowed' | fetch使用の検出 |
| __proto__ | 'Prototype manipulation is not allowed' | プロトタイプ操作の検出 |
| constructor\\.constructor | 'Constructor access is not allowed' | コンストラクタアクセスの検出 |

**検証結果構造**
| 項目 | 値 | 説明 |
|-----|---|------|
| isValid | violations.length === 0 | スクリプトの安全性判定 |
| violations | string[] | 検出された違反内容一覧 |

---

## 8. 性能設計

### 8.1 性能要件と最適化戦略

#### 8.1.1 レスポンス時間最適化
```typescript
class PerformanceOptimizer {
  private cache: Map<string, CacheEntry> = new Map();
  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes
  
  // Request debouncing
  private debounceMap: Map<string, NodeJS.Timeout> = new Map();
  
  debounce(key: string, fn: Function, delay: number): void {
    if (this.debounceMap.has(key)) {
      clearTimeout(this.debounceMap.get(key)!);
    }
    
    const timeout = setTimeout(() => {
      fn();
      this.debounceMap.delete(key);
    }, delay);
    
    this.debounceMap.set(key, timeout);
  }
  
  // Lazy loading for collections
  async loadCollectionLazy(collectionId: string): Promise<Collection> {
    const cacheKey = `collection_${collectionId}`;
    const cached = this.cache.get(cacheKey);
    
    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
      return cached.data;
    }
    
    const collection = await this.storageManager.get(`collections.${collectionId}`);
    
    this.cache.set(cacheKey, {
      data: collection,
      timestamp: Date.now()
    });
    
    return collection;
  }
  
  // Virtual scrolling for large lists
  createVirtualList(items: any[], itemHeight: number, containerHeight: number): VirtualListData {
    const visibleCount = Math.ceil(containerHeight / itemHeight) + 2; // Buffer
    const totalHeight = items.length * itemHeight;
    
    return {
      totalHeight,
      visibleCount,
      itemHeight,
      getVisibleItems: (scrollTop: number) => {
        const startIndex = Math.floor(scrollTop / itemHeight);
        const endIndex = Math.min(startIndex + visibleCount, items.length);
        return items.slice(startIndex, endIndex);
      }
    };
  }
}
```

### 8.2 メモリ管理

#### 8.2.1 メモリプール設計
```typescript
class MemoryManager {
  private responsePool: Map<string, Response> = new Map();
  private maxPoolSize: number = 100;
  
  // Response caching with LRU eviction
  cacheResponse(requestId: string, response: Response): void {
    if (this.responsePool.size >= this.maxPoolSize) {
      const oldestKey = this.responsePool.keys().next().value;
      this.responsePool.delete(oldestKey);
    }
    
    this.responsePool.set(requestId, response);
  }
  
  getCachedResponse(requestId: string): Response | null {
    const response = this.responsePool.get(requestId);
    if (response) {
      // Move to end (LRU)
      this.responsePool.delete(requestId);
      this.responsePool.set(requestId, response);
    }
    return response || null;
  }
  
  // Memory cleanup
  cleanup(): void {
    this.responsePool.clear();
    
    // Force garbage collection if available
    if (typeof gc === 'function') {
      gc();
    }
  }
  
  // Memory usage monitoring
  getMemoryUsage(): MemoryUsage {
    const used = JSON.stringify(Array.from(this.responsePool.values())).length;
    
    return {
      used: used,
      total: this.maxPoolSize * 1024 * 1024, // Estimated
      percentage: (used / (this.maxPoolSize * 1024 * 1024)) * 100
    };
  }
}
```

---

## 9. テスト設計

### 9.1 テスト戦略

#### 9.1.1 テスト階層
```
┌─────────────────────────────────────────────┐
│              E2E Tests                      │
│  - Chrome Extension Integration             │
│  - User Workflow Testing                    │
│  - Cross-browser Compatibility              │
└─────────────────────────────────────────────┘
┌─────────────────────────────────────────────┐
│           Integration Tests                 │
│  - Component Integration                    │
│  - API Integration                          │
│  - Storage Integration                      │
└─────────────────────────────────────────────┘
┌─────────────────────────────────────────────┐
│             Unit Tests                      │
│  - Individual Function Testing              │
│  - Class Method Testing                     │
│  - Utility Function Testing                 │
└─────────────────────────────────────────────┘
```

#### 9.1.2 テスト実装
```typescript
// Unit Test Example
describe('VariableManager', () => {
  let variableManager: VariableManager;
  
  beforeEach(() => {
    variableManager = new VariableManager();
  });
  
  describe('variable resolution', () => {
    it('should resolve variables with correct priority', () => {
      variableManager.setGlobalVariable('baseUrl', 'https://global.com');
      variableManager.setEnvironmentVariable('baseUrl', 'https://env.com');
      variableManager.setCollectionVariable('baseUrl', 'https://collection.com');
      
      const resolved = variableManager.resolveVariable('baseUrl');
      expect(resolved).toBe('https://collection.com');
    });
  });
});

// Integration Test Example
describe('Request Execution Integration', () => {
  let requestManager: RequestManager;
  let variableManager: VariableManager;
  
  beforeEach(() => {
    variableManager = new VariableManager();
    requestManager = new RequestManager(variableManager);
  });
  
  it('should execute request with variable substitution', async () => {
    variableManager.setGlobalVariable('baseUrl', 'https://httpbin.org');
    
    const request: Request = {
      method: 'GET',
      url: '{{baseUrl}}/get',
      headers: {}
    };
    
    const result = await requestManager.sendRequest(request);
    expect(result.response.status).toBe(200);
    expect(result.request.url).toBe('https://httpbin.org/get');
  });
});
```

---

## 10. デプロイ設計

### 10.1 ビルドパイプライン

#### 10.1.1 ビルドプロセス
```typescript
// Build Configuration
interface BuildConfig {
  mode: 'development' | 'production';
  target: 'chrome' | 'firefox' | 'edge';
  optimization: {
    minify: boolean;
    treeshake: boolean;
    splitChunks: boolean;
  };
}

class BuildManager {
  async build(config: BuildConfig): Promise<BuildResult> {
    const steps = [
      () => this.cleanOutput(),
      () => this.compileTypeScript(config),
      () => this.bundleAssets(config),
      () => this.generateManifest(config),
      () => this.optimizeBundle(config),
      () => this.validateBuild(config)
    ];
    
    for (const step of steps) {
      await step();
    }
    
    return {
      success: true,
      outputPath: './dist',
      size: await this.calculateBundleSize(),
      timestamp: new Date()
    };
  }
  
  private async generateManifest(config: BuildConfig): Promise<void> {
    const manifest = {
      manifest_version: 3,
      name: "PostPro API Tester",
      version: this.getVersion(),
      description: "Advanced API testing tool for developers",
      
      permissions: [
        "storage",
        "activeTab",
        "background"
      ],
      
      host_permissions: [
        "<all_urls>"
      ],
      
      background: {
        service_worker: "background.js"
      },
      
      content_scripts: [{
        matches: ["<all_urls>"],
        js: ["content.js"]
      }],
      
      action: {
        default_popup: "index.html",
        default_title: "PostPro API Tester"
      }
    };
    
    await this.writeFile('./dist/manifest.json', JSON.stringify(manifest, null, 2));
  }
}
```

### 10.2 デプロイメント戦略

#### 10.2.1 環境別設定
```typescript
interface DeploymentConfig {
  development: {
    enableLogging: true;
    enableDebugMode: true;
    apiEndpoint: 'http://localhost:3000';
    storagePrefix: 'dev_';
  };
  
  staging: {
    enableLogging: true;
    enableDebugMode: false;
    apiEndpoint: 'https://api-staging.postpro.com';
    storagePrefix: 'staging_';
  };
  
  production: {
    enableLogging: false;
    enableDebugMode: false;
    apiEndpoint: 'https://api.postpro.com';
    storagePrefix: '';
  };
}

class DeploymentManager {
  async deploy(environment: keyof DeploymentConfig): Promise<void> {
    const config = this.getConfig(environment);
    
    // Build with environment-specific configuration
    await this.buildManager.build({
      mode: environment === 'development' ? 'development' : 'production',
      target: 'chrome',
      optimization: {
        minify: environment === 'production',
        treeshake: environment === 'production',
        splitChunks: environment === 'production'
      }
    });
    
    // Run deployment validation
    await this.validateDeployment(config);
    
    // Package for distribution
    await this.createDistributionPackage(environment);
  }
}
```

---

## 11. 運用設計

### 11.1 監視・ログ設計

#### 11.1.1 ログシステム
```typescript
enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3
}

class Logger {
  private level: LogLevel;
  private storage: LogStorage;
  
  constructor(level: LogLevel = LogLevel.INFO) {
    this.level = level;
    this.storage = new LogStorage();
  }
  
  async error(message: string, error?: Error, context?: any): Promise<void> {
    if (this.level > LogLevel.ERROR) return;
    
    const logEntry: LogEntry = {
      level: 'ERROR',
      message,
      error: error ? {
        name: error.name,
        message: error.message,
        stack: error.stack
      } : undefined,
      context,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: window.location.href
    };
    
    console.error(message, error, context);
    await this.storage.store(logEntry);
    
    // Send to error tracking service in production
    if (this.isProduction()) {
      await this.sendToErrorTracking(logEntry);
    }
  }
  
  async getRecentLogs(count: number = 100): Promise<LogEntry[]> {
    return await this.storage.getRecent(count);
  }
}
```

### 11.2 バックアップ・復旧設計

#### 11.2.1 自動バックアップ
```typescript
class BackupManager {
  private readonly BACKUP_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours
  private readonly MAX_BACKUPS = 7; // Keep 7 days
  
  async startAutoBackup(): Promise<void> {
    setInterval(async () => {
      try {
        await this.createAutoBackup();
      } catch (error) {
        this.logger.error('Auto backup failed', error);
      }
    }, this.BACKUP_INTERVAL);
  }
  
  async createAutoBackup(): Promise<string> {
    const state = await this.stateManager.exportFullState();
    const backupData: BackupData = {
      version: this.getAppVersion(),
      timestamp: new Date().toISOString(),
      type: 'auto',
      data: state,
      checksum: await this.calculateChecksum(state)
    };
    
    const backupId = `auto_${Date.now()}`;
    await this.storeBackup(backupId, backupData);
    
    // Cleanup old backups
    await this.cleanupOldBackups();
    
    return backupId;
  }
  
  async restoreFromBackup(backupId: string): Promise<void> {
    const backup = await this.loadBackup(backupId);
    if (!backup) {
      throw new Error(`Backup not found: ${backupId}`);
    }
    
    // Verify backup integrity
    const calculatedChecksum = await this.calculateChecksum(backup.data);
    if (calculatedChecksum !== backup.checksum) {
      throw new Error('Backup data is corrupted');
    }
    
    // Create current state backup before restore
    await this.createManualBackup('before_restore');
    
    // Restore state
    await this.stateManager.importFullState(backup.data);
    
    this.logger.info(`Successfully restored from backup: ${backupId}`);
  }
}
```

---

## 12. 品質保証設計

### 12.1 品質メトリクス

#### 12.1.1 コード品質指標
```typescript
interface QualityMetrics {
  // Test Coverage
  unitTestCoverage: number;        // Target: >80%
  integrationTestCoverage: number; // Target: >70%
  e2eTestCoverage: number;        // Target: >60%
  
  // Code Quality
  codeComplexity: number;         // Target: <10 per function
  technicalDebt: number;          // Target: <5%
  codeSmellsCount: number;        // Target: <10
  
  // Performance
  bundleSize: number;             // Target: <1MB
  loadTime: number;               // Target: <200ms
  memoryUsage: number;            // Target: <50MB
  
  // Reliability
  errorRate: number;              // Target: <1%
  crashRate: number;              // Target: <0.1%
  uptime: number;                 // Target: >99.9%
}

class QualityAssurance {
  async measureQuality(): Promise<QualityMetrics> {
    return {
      unitTestCoverage: await this.getTestCoverage('unit'),
      integrationTestCoverage: await this.getTestCoverage('integration'),
      e2eTestCoverage: await this.getTestCoverage('e2e'),
      
      codeComplexity: await this.measureComplexity(),
      technicalDebt: await this.calculateTechnicalDebt(),
      codeSmellsCount: await this.countCodeSmells(),
      
      bundleSize: await this.getBundleSize(),
      loadTime: await this.measureLoadTime(),
      memoryUsage: await this.measureMemoryUsage(),
      
      errorRate: await this.calculateErrorRate(),
      crashRate: await this.calculateCrashRate(),
      uptime: await this.calculateUptime()
    };
  }
}
```

---

## 13. 基本設計レビュー結果

### 13.1 アプリケーション基本設計レビュー

#### 13.1.1 共通基盤の設計適切性
✅ **フレームワーク選定と基本方針**
- Chrome Extension Manifest V3 + Service Worker基盤（要件準拠）
- TypeScript厳密モード + Vite による開発効率向上
- Jest + Puppeteer による包括的テスト戦略（要件QA-001準拠）
- エコーAPI統合による統合テスト環境（要件EX-001準拠）

✅ **制御部品の設計と利用体験価値実現**
- Observer Pattern State Manager: UI-データ双方向バインディング実現
- エコーAPI統合Request Engine: 最短3ステップ目標達成支援
- 学習支援Script Engine: 新人開発者価値シナリオ対応
- 3階層Variable Engine: チーム協業知見の自動蓄積・活用

✅ **実装ルールの制定**
- TypeScript厳密モードによる型安全性確保
- UI設計原則（段階的機能開示・認知負荷軽減）の技術実装
- Chrome Extension APIの適切な活用とセキュリティ要件対応

#### 13.1.2 システム構築基本方針
✅ **アーキテクチャ設計と5画面統合**
- 要件IF-001準拠の階層化アーキテクチャ（5画面統合SPA）
- Service Worker + Popup SPA による適切な責任分離
- Message Passing APIによるリアルタイム状態同期

✅ **性能・セキュリティ考慮**
- UI性能要件（startup: 200ms、response: 100ms）対応設計
- AES-256暗号化による認証情報保護
- サンドボックス + 教育的エラーによる学習支援セキュリティ
- メモリ効率とFlow State維持を両立する仮想スクロール

### 13.2 データベース基本設計レビュー

#### 13.2.1 データベースアクセス基本設計
✅ **ストレージアーキテクチャと性能要件対応**
- Chrome Storage API基盤（5MB制限対応）の階層化ストレージ
- メモリキャッシュ層によるUI応答性100ms以内実現
- 90日保持・自動バックアップによるデータ保護（要件DB-001準拠）

✅ **アクセスパターン設計とUI体験最適化**
- Read-through キャッシュ（段階的データ読み込み）
- Write-back バッチ処理（500ms遅延）による性能最適化
- Observer Pattern Event-driven データ変更通知

#### 13.2.2 データベース論理設計規約
✅ **命名規約・データ型規約と要件準拠**
- 5画面構成に対応した命名規則（postpro_prefix + 画面別）
- TypeScript検証済みデータ型定義（UUID v4, ISO 8601）
- AES-256暗号化データの適切な形式定義

✅ **関係設計とチーム協業支援**
- Collection-Request間の1対多関係（コレクション管理要件対応）
- 3階層変数優先順位設計（Global > Environment > Collection）
- TypeScript型による参照整合性とスキーマバージョン管理

#### 13.2.3 テーブル定義基本方針
✅ **正規化とパフォーマンス（Chrome Storage制約対応）**
- 第3正規形による冗長性排除（5MB制限対応）
- UI高速表示用の計算済みフィールド許可
- コレクション単位分割戦略と1KB以上データのgzip圧縮

✅ **データライフサイクル管理（要件DB-001準拠）**
- ISO 8601タイムスタンプ自動付与
- Observer Pattern変更追跡と論理削除（deleted: boolean）
- 90日経過後の自動アーカイブと認証情報リアルタイム暗号化

### 13.3 要件定義・UI設計との整合性

#### 13.3.1 要件定義文書との適合
✅ **機能要件の技術実装（要件定義準拠）**
- BM-001 API開発業務フロー → 5画面統合SPAアーキテクチャ
- DB-001 ローカルストレージ設計 → Chrome Storage + 階層化設計
- EX-001 エコーAPI連携 → HTTPリクエストエンジン統合
- IF-001 UI設計方針 → Component-based Vanilla JS実装

✅ **非機能要件の実装方針**
- 性能要件: UI応答性100ms以内 → メモリキャッシュ + 仮想スクロール
- セキュリティ要件: 認証情報保護 → AES-256暗号化 + サンドボックス
- 品質要件: 包括的テスト → Jest + Puppeteer + エコーAPI統合テスト

#### 13.3.2 UI基本設計との連携
✅ **コンポーネント階層の整合性とレスポンシブ対応**
- Presentation Layer（5画面SPA） → Application Layer → Service Layer
- Observer Pattern State Manager によるリアルタイム双方向バインディング
- Message Passing による Chrome拡張機能間通信とUI状態同期

✅ **利用体験価値設計の技術実現**
- 段階的機能開示 → Component-based Progressive Loading
- 認知負荷軽減 → 情報の論理的階層化とコンテキスト適応UI
- Flow State維持 → 中断最小化アーキテクチャとタスク連続性設計
- チーム協業促進 → 自動蓄積・活用機能の技術基盤

---

## 14. 付録

### 14.1 技術選択理由

| 技術要素 | 選択技術 | 理由 |
|---------|---------|------|
| 言語 | TypeScript | 型安全性、開発効率向上、保守性 |
| バンドラー | Vite | 高速ビルド、HMR、ES modules対応 |
| テストフレームワーク | Jest | 豊富な機能、TypeScript対応 |
| E2Eテスト | Puppeteer | Chrome拡張機能対応、実ブラウザ環境 |
| 状態管理 | Custom State Manager | Chrome拡張機能特有の要件対応 |
| HTTP通信 | XMLHttpRequest | Chrome拡張機能での安定性 |

### 14.2 制約事項と考慮点

**Chrome拡張機能制約**
| 項目 | 値 | 説明 |
|-----|---|------|
| Manifest V3制約 | Service Worker、CSP等 | 新仕様に伴う制限事項 |
| ストレージサイズ制限 | 5MB | Chrome Storage API上限 |
| Cross-Origin制約 | CORS制限 | 外部API呼び出し制限 |
| Content Security Policy | CSP制限 | スクリプト実行制限 |

**パフォーマンス制約**
| 項目 | 値 | 説明 |
|-----|---|------|
| メモリ使用量制限 | 推奨50MB以下 | 安定動作のためのメモリ上限 |
| バンドルサイズ制限 | 推奨1MB以下 | ロード時間短縮のためのサイズ制限 |
| レスポンス時間要件 | 200ms以下 | UI応答性確保のための時間制限 |

### 14.3 更新履歴

| 日付 | バージョン | 更新内容 | 更新者 |
|------|-----------|----------|--------|
| 2025-01-10 | 1.0 | 初版作成 | Claude Code |
| 2025-01-10 | 2.0 | 基本設計レビューチェックリスト適用・要件定義・UI設計との整合性確保 | Claude Code |
| 2025-01-10 | 3.0 | ソースコード部分を表形式に変更 | Claude Code |
| 2025-01-11 | 4.0 | 要件定義文書（03.rd.md）・UI基本設計文書（04.ui.md）との整合性強化・利用体験価値設計の技術実装方針追加 | Claude Code |

---

**この基本設計文書は、PostPro API Tester Chrome拡張機能の詳細設計と実装の基礎となる重要な設計指針を定義したものです。要件定義文書と合わせて、高品質で保守性の高いソフトウェア開発を実現してください。**